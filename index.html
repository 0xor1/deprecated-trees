
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">bitbucket.org\0xor1\task\server\api\v1\account\account_client.go (81.8%)</option>
				
				<option value="file1">bitbucket.org\0xor1\task\server\api\v1\account\account_db_helpers.go (79.8%)</option>
				
				<option value="file2">bitbucket.org\0xor1\task\server\api\v1\account\account_endpoints.go (100.0%)</option>
				
				<option value="file3">bitbucket.org\0xor1\task\server\api\v1\centralaccount\central_account_client.go (83.5%)</option>
				
				<option value="file4">bitbucket.org\0xor1\task\server\api\v1\centralaccount\central_account_db_helpers.go (89.4%)</option>
				
				<option value="file5">bitbucket.org\0xor1\task\server\api\v1\centralaccount\central_account_email_helpers.go (75.0%)</option>
				
				<option value="file6">bitbucket.org\0xor1\task\server\api\v1\centralaccount\central_account_endpoints.go (85.0%)</option>
				
				<option value="file7">bitbucket.org\0xor1\task\server\api\v1\private\private_client.go (72.5%)</option>
				
				<option value="file8">bitbucket.org\0xor1\task\server\api\v1\private\private_db_helpers.go (77.4%)</option>
				
				<option value="file9">bitbucket.org\0xor1\task\server\api\v1\private\private_endpoints.go (81.5%)</option>
				
				<option value="file10">bitbucket.org\0xor1\task\server\api\v1\project\project_client.go (83.8%)</option>
				
				<option value="file11">bitbucket.org\0xor1\task\server\api\v1\project\project_db_helpers.go (78.4%)</option>
				
				<option value="file12">bitbucket.org\0xor1\task\server\api\v1\project\project_endpoints.go (92.9%)</option>
				
				<option value="file13">bitbucket.org\0xor1\task\server\api\v1\task\task_client.go (90.3%)</option>
				
				<option value="file14">bitbucket.org\0xor1\task\server\api\v1\task\task_db_helpers.go (95.9%)</option>
				
				<option value="file15">bitbucket.org\0xor1\task\server\api\v1\task\task_endpoints.go (100.0%)</option>
				
				<option value="file16">bitbucket.org\0xor1\task\server\api\v1\timelog\timelog_client.go (84.2%)</option>
				
				<option value="file17">bitbucket.org\0xor1\task\server\api\v1\timelog\timelog_db_helpers.go (83.0%)</option>
				
				<option value="file18">bitbucket.org\0xor1\task\server\api\v1\timelog\timelog_endpoints.go (87.2%)</option>
				
				<option value="file19">bitbucket.org\0xor1\task\server\util\crypt\crypt.go (100.0%)</option>
				
				<option value="file20">bitbucket.org\0xor1\task\server\util\id\id.go (46.2%)</option>
				
				<option value="file21">bitbucket.org\0xor1\task\server\util\validate\validate.go (45.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package account

import (
        "bitbucket.org/0xor1/task/server/util/activity"
        "bitbucket.org/0xor1/task/server/util/clientsession"
        "bitbucket.org/0xor1/task/server/util/cnst"
        "bitbucket.org/0xor1/task/server/util/id"
        "time"
)

type Client interface {
        //must be account owner
        SetPublicProjectsEnabled(css *clientsession.Store, shard int, account id.Id, publicProjectsEnabled bool) error
        //must be account owner/admin
        GetPublicProjectsEnabled(css *clientsession.Store, shard int, account id.Id) (bool, error)
        //must be account owner/admin
        SetMemberRole(css *clientsession.Store, shard int, account, member id.Id, role cnst.AccountRole) error
        //pointers are optional filters
        GetMembers(css *clientsession.Store, shard int, account id.Id, role *cnst.AccountRole, nameContains *string, after *id.Id, limit int) (*GetMembersResp, error)
        //either one or both of OccurredAfter/Before must be nil
        GetActivities(css *clientsession.Store, shard int, account id.Id, item, member *id.Id, occurredAfter, occurredBefore *time.Time, limit int) ([]*activity.Activity, error)
        //for anyone
        GetMe(css *clientsession.Store, shard int, account id.Id) (*Member, error)
}

func NewClient(host string) Client <span class="cov8" title="1">{
        return &amp;client{
                host: host,
        }
}</span>

type client struct {
        host string
}

func (c *client) SetPublicProjectsEnabled(css *clientsession.Store, shard int, account id.Id, publicProjectsEnabled bool) error <span class="cov8" title="1">{
        _, e := setPublicProjectsEnabled.DoRequest(css, c.host, &amp;setPublicProjectsEnabledArgs{
                Shard:                 shard,
                Account:               account,
                PublicProjectsEnabled: publicProjectsEnabled,
        }, nil, nil)
        return e
}</span>

func (c *client) GetPublicProjectsEnabled(css *clientsession.Store, shard int, account id.Id) (bool, error) <span class="cov8" title="1">{
        respVal := true
        val, e := getPublicProjectsEnabled.DoRequest(css, c.host, &amp;getPublicProjectsEnabledArgs{
                Shard:   shard,
                Account: account,
        }, nil, &amp;respVal)
        if val != nil </span><span class="cov8" title="1">{
                return *val.(*bool), e
        }</span>
        <span class="cov0" title="0">return false, e</span>
}

func (c *client) SetMemberRole(css *clientsession.Store, shard int, account, member id.Id, role cnst.AccountRole) error <span class="cov8" title="1">{
        _, e := setMemberRole.DoRequest(css, c.host, &amp;setMemberRoleArgs{
                Shard:   shard,
                Account: account,
                Member:  member,
                Role:    role,
        }, nil, nil)
        return e
}</span>

func (c *client) GetMembers(css *clientsession.Store, shard int, account id.Id, role *cnst.AccountRole, nameContains *string, after *id.Id, limit int) (*GetMembersResp, error) <span class="cov8" title="1">{
        val, e := getMembers.DoRequest(css, c.host, &amp;getMembersArgs{
                Shard:        shard,
                Account:      account,
                Role:         role,
                NameContains: nameContains,
                After:        after,
                Limit:        limit,
        }, nil, &amp;GetMembersResp{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*GetMembersResp), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) GetActivities(css *clientsession.Store, shard int, account id.Id, itemId *id.Id, member *id.Id, occurredAfter, occurredBefore *time.Time, limit int) ([]*activity.Activity, error) <span class="cov8" title="1">{
        val, e := getActivities.DoRequest(css, c.host, &amp;getActivitiesArgs{
                Shard:          shard,
                Account:        account,
                Item:           itemId,
                Member:         member,
                OccurredAfter:  occurredAfter,
                OccurredBefore: occurredBefore,
                Limit:          limit,
        }, nil, &amp;[]*activity.Activity{})
        if val != nil </span><span class="cov8" title="1">{
                return *val.(*[]*activity.Activity), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) GetMe(css *clientsession.Store, shard int, account id.Id) (*Member, error) <span class="cov8" title="1">{
        val, e := getMe.DoRequest(css, c.host, &amp;getMeArgs{
                Shard:   shard,
                Account: account,
        }, nil, &amp;Member{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*Member), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package account

import (
        "bitbucket.org/0xor1/task/server/util/activity"
        "bitbucket.org/0xor1/task/server/util/cachekey"
        "bitbucket.org/0xor1/task/server/util/cnst"
        "bitbucket.org/0xor1/task/server/util/ctx"
        "bitbucket.org/0xor1/task/server/util/db"
        "bitbucket.org/0xor1/task/server/util/err"
        "bitbucket.org/0xor1/task/server/util/id"
        "bytes"
        "fmt"
        "github.com/0xor1/panic"
        "strings"
        "time"
)

func dbSetPublicProjectsEnabled(ctx ctx.Ctx, shard int, account id.Id, publicProjectsEnabled bool) <span class="cov8" title="1">{
        _, e := ctx.TreeExec(shard, `CALL setPublicProjectsEnabled(?, ?, ?)`, account, ctx.Me(), publicProjectsEnabled)
        panic.If(e)
        cacheKey := cachekey.NewSetDlms().Account(account).AccountActivities(account)
        if !publicProjectsEnabled </span><span class="cov0" title="0">{ //if setting publicProjectsEnabled to false this could have set some projects to not public
                cacheKey.AccountProjectsSet(account)
        }</span>
        <span class="cov8" title="1">ctx.TouchDlms(cacheKey)</span>
}

func dbSetMemberRole(ctx ctx.Ctx, shard int, account, member id.Id, role cnst.AccountRole) <span class="cov8" title="1">{
        db.MakeChangeHelper(ctx, shard, `CALL setAccountMemberRole(?, ?, ?, ?)`, account, ctx.Me(), member, role)
        ctx.TouchDlms(cachekey.NewSetDlms().AccountMember(account, member).AccountActivities(account))
}</span>

func dbGetMember(ctx ctx.Ctx, shard int, account, mem id.Id) *Member <span class="cov8" title="1">{
        res := Member{}
        cacheKey := cachekey.NewGet("account.dbGetMember", shard, account, mem).AccountMember(account, mem)
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return &amp;res
        }</span>
        <span class="cov8" title="1">row := ctx.TreeQueryRow(shard, `SELECT id, name, displayName, hasAvatar, isActive, role FROM accountMembers WHERE account=? AND id=?`, account, mem)
        panic.If(row.Scan(&amp;res.Id, &amp;res.Name, &amp;res.DisplayName, &amp;res.HasAvatar, &amp;res.IsActive, &amp;res.Role))
        ctx.SetCacheValue(res, cacheKey)
        return &amp;res</span>
}

/***
TODO need to determine which of these is most efficient on the db (this applys to project.GetMembers too):
1)
SELECT id, isActive, role
FROM accountMembers
WHERE account=:acc
AND isActive=true
AND (
        (
            name &gt; (SELECT name FROM accountMembers WHERE account=:acc AND id=:id)
            AND role = (SELECT role FROM accountMembers WHERE account=:acc AND id=:id)
        )
        OR role &gt; (SELECT role FROM accountMembers WHERE account=:acc AND id=:id)
)
ORDER BY role ASC, name ASC LIMIT :lim

2)
SELECT a1.id, a1.name, a1.displayName, a1.hasAvatar, a1.isActive, a1.role
FROM accountMembers a1, accountMembers a2
WHERE a1.account=:acc
AND a1.isActive=true
AND a2.account=:acc
AND a2.id=:id
AND (
        (
            a1.name&gt;a2.name
            AND a1.role=a2.role
        )
        OR a1.role&gt;a2.role
)
ORDER BY a1.role ASC, a1.name ASC LIMIT :lim
***/

func dbGetMembers(ctx ctx.Ctx, shard int, account id.Id, role *cnst.AccountRole, nameOrDisplayNameContains *string, after *id.Id, limit int) *GetMembersResp <span class="cov8" title="1">{
        res := GetMembersResp{}
        cacheKey := cachekey.NewGet("account.dbGetMembers", shard, account, role, nameOrDisplayNameContains, after, limit).AccountMembersSet(account)
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return &amp;res
        }</span>
        <span class="cov8" title="1">query := bytes.NewBufferString(`SELECT a1.id, a1.name, a1.displayName, a1.hasAvatar, a1.isActive, a1.role FROM accountMembers a1`)
        args := make([]interface{}, 0, 7)
        if after != nil </span><span class="cov8" title="1">{
                query.WriteString(`, accountMembers a2`)
        }</span>
        <span class="cov8" title="1">query.WriteString(` WHERE a1.account=? AND a1.isActive=true`)
        args = append(args, account)
        if after != nil </span><span class="cov8" title="1">{
                query.WriteString(` AND a2.account=? AND a2.id=? AND ((a1.name&gt;a2.name AND a1.role=a2.role) OR a1.role&gt;a2.role)`)
                args = append(args, account, *after)
        }</span>
        <span class="cov8" title="1">if role != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND a1.role=?`)
                args = append(args, role)
        }</span>
        <span class="cov8" title="1">if nameOrDisplayNameContains != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND (a1.name LIKE ? OR a1.displayName LIKE ?)`)
                strVal := strings.Trim(*nameOrDisplayNameContains, " ")
                strVal = fmt.Sprintf("%%%s%%", strVal)
                args = append(args, strVal, strVal)
        }</span>
        <span class="cov8" title="1">query.WriteString(` ORDER BY a1.role ASC, a1.name ASC LIMIT ?`)
        args = append(args, limit+1)
        rows, e := ctx.TreeQuery(shard, query.String(), args...)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.If(e)
        memSet := make([]*Member, 0, limit+1)
        for rows.Next() </span><span class="cov8" title="1">{
                mem := Member{}
                panic.If(rows.Scan(&amp;mem.Id, &amp;mem.Name, &amp;mem.DisplayName, &amp;mem.HasAvatar, &amp;mem.IsActive, &amp;mem.Role))
                memSet = append(memSet, &amp;mem)
        }</span>
        <span class="cov8" title="1">if len(memSet) == limit+1 </span><span class="cov8" title="1">{
                res.Members = memSet[:limit]
                res.More = true
        }</span><span class="cov8" title="1"> else {
                res.Members = memSet
                res.More = false
        }</span>
        <span class="cov8" title="1">ctx.SetCacheValue(&amp;res, cacheKey)
        return &amp;res</span>
}

func dbGetActivities(ctx ctx.Ctx, shard int, account id.Id, item *id.Id, member *id.Id, occurredAfter, occurredBefore *time.Time, limit int) []*activity.Activity <span class="cov8" title="1">{
        panic.IfTrueWith(occurredAfter != nil &amp;&amp; occurredBefore != nil, err.InvalidArguments)
        res := make([]*activity.Activity, 0, limit)
        cacheKey := cachekey.NewGet("account.dbGetActivities", shard, account, item, member, occurredAfter, occurredBefore, limit).AccountActivities(account)
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return res
        }</span>
        <span class="cov8" title="1">query := bytes.NewBufferString(`SELECT occurredOn, item, member, itemType, itemHasBeenDeleted, action, itemName, extraInfo FROM accountActivities WHERE account=?`)
        args := make([]interface{}, 0, limit)
        args = append(args, account)
        if item != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND item=?`)
                args = append(args, *item)
        }</span>
        <span class="cov8" title="1">if member != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND member=?`)
                args = append(args, *member)
        }</span>
        <span class="cov8" title="1">if occurredAfter != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND occurredOn&gt;? ORDER BY occurredOn ASC`)
                args = append(args, occurredAfter)
        }</span>
        <span class="cov8" title="1">if occurredBefore != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND occurredOn&lt;? ORDER BY occurredOn DESC`)
                args = append(args, occurredBefore)
        }</span>
        <span class="cov8" title="1">if occurredAfter == nil &amp;&amp; occurredBefore == nil </span><span class="cov8" title="1">{
                query.WriteString(` ORDER BY occurredOn DESC`)
        }</span>
        <span class="cov8" title="1">query.WriteString(` LIMIT ?`)
        args = append(args, limit)
        rows, e := ctx.TreeQuery(shard, query.String(), args...)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.If(e)
        for rows.Next() </span><span class="cov8" title="1">{
                act := activity.Activity{}
                panic.If(rows.Scan(&amp;act.OccurredOn, &amp;act.Item, &amp;act.Member, &amp;act.ItemType, &amp;act.ItemHasBeenDeleted, &amp;act.Action, &amp;act.ItemName, &amp;act.ExtraInfo))
                res = append(res, &amp;act)
        }</span>
        <span class="cov8" title="1">ctx.SetCacheValue(res, cacheKey)
        return res</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package account

import (
        "bitbucket.org/0xor1/task/server/util/activity"
        "bitbucket.org/0xor1/task/server/util/cnst"
        "bitbucket.org/0xor1/task/server/util/ctx"
        "bitbucket.org/0xor1/task/server/util/db"
        "bitbucket.org/0xor1/task/server/util/endpoint"
        "bitbucket.org/0xor1/task/server/util/err"
        "bitbucket.org/0xor1/task/server/util/id"
        "bitbucket.org/0xor1/task/server/util/validate"
        "github.com/0xor1/panic"
        "time"
        "net/http"
)

type setPublicProjectsEnabledArgs struct {
        Shard                 int   `json:"shard"`
        Account               id.Id `json:"account"`
        PublicProjectsEnabled bool  `json:"publicProjectsEnabled"`
}

var setPublicProjectsEnabled = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/account/setPublicProjectsEnabled",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setPublicProjectsEnabledArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setPublicProjectsEnabledArgs)
                validate.MemberHasAccountOwnerAccess(db.GetAccountRole(ctx, args.Shard, args.Account, ctx.Me()))
                dbSetPublicProjectsEnabled(ctx, args.Shard, args.Account, args.PublicProjectsEnabled)
                return nil
        }</span>,
}

type getPublicProjectsEnabledArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
}

var getPublicProjectsEnabled = &amp;endpoint.Endpoint{
        Method:                   http.MethodGet,
        Path:                     "/api/v1/account/getPublicProjectsEnabled",
        RequiresSession:          true,
        ExampleResponseStructure: false,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getPublicProjectsEnabledArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getPublicProjectsEnabledArgs)
                validate.MemberHasAccountAdminAccess(db.GetAccountRole(ctx, args.Shard, args.Account, ctx.Me()))
                return db.GetPublicProjectsEnabled(ctx, args.Shard, args.Account)
        }</span>,
}

type setMemberRoleArgs struct {
        Shard   int              `json:"shard"`
        Account id.Id            `json:"account"`
        Member  id.Id            `json:"member"`
        Role    cnst.AccountRole `json:"role"`
}

var setMemberRole = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/account/setMemberRole",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setMemberRoleArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setMemberRoleArgs)
                accountRole := db.GetAccountRole(ctx, args.Shard, args.Account, ctx.Me())
                validate.MemberHasAccountAdminAccess(accountRole)
                args.Role.Validate()
                panic.IfTrueWith(args.Role == cnst.AccountOwner &amp;&amp; *accountRole != cnst.AccountOwner, err.InsufficientPermission)
                dbSetMemberRole(ctx, args.Shard, args.Account, args.Member, args.Role)
                return nil
        }</span>,
}

type getMembersArgs struct {
        Shard        int               `json:"shard"`
        Account      id.Id             `json:"account"`
        Role         *cnst.AccountRole `json:"role,omitempty"`
        NameContains *string           `json:"nameContains,omitempty"`
        After        *id.Id            `json:"after,omitempty"`
        Limit        int               `json:"limit"`
}

type GetMembersResp struct {
        Members []*Member `json:"members"`
        More    bool      `json:"more"`
}

var getMembers = &amp;endpoint.Endpoint{
        Method:                   http.MethodGet,
        Path:                     "/api/v1/account/getMembers",
        RequiresSession:          true,
        ExampleResponseStructure: &amp;GetMembersResp{Members: []*Member{{}}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getMembersArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getMembersArgs)
                validate.MemberHasAccountAdminAccess(db.GetAccountRole(ctx, args.Shard, args.Account, ctx.Me()))
                return dbGetMembers(ctx, args.Shard, args.Account, args.Role, args.NameContains, args.After, validate.Limit(args.Limit, ctx.MaxProcessEntityCount()))
        }</span>,
}

type getActivitiesArgs struct {
        Shard          int        `json:"shard"`
        Account        id.Id      `json:"account"`
        Item           *id.Id     `json:"item,omitempty"`
        Member         *id.Id     `json:"member,omitempty"`
        OccurredAfter  *time.Time `json:"occurredAfter,omitempty"`
        OccurredBefore *time.Time `json:"occurredBefore,omitempty"`
        Limit          int        `json:"limit"`
}

var getActivities = &amp;endpoint.Endpoint{
        Method:                   http.MethodGet,
        Path:                     "/api/v1/account/getActivities",
        RequiresSession:          true,
        ExampleResponseStructure: []*activity.Activity{{}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getActivitiesArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getActivitiesArgs)
                panic.IfTrueWith(args.OccurredAfter != nil &amp;&amp; args.OccurredBefore != nil, err.InvalidArguments)
                validate.MemberHasAccountAdminAccess(db.GetAccountRole(ctx, args.Shard, args.Account, ctx.Me()))
                return dbGetActivities(ctx, args.Shard, args.Account, args.Item, args.Member, args.OccurredAfter, args.OccurredBefore, validate.Limit(args.Limit, ctx.MaxProcessEntityCount()))
        }</span>,
}

type getMeArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
}

var getMe = &amp;endpoint.Endpoint{
        Method:                   http.MethodGet,
        Path:                     "/api/v1/account/getMe",
        RequiresSession:          true,
        ExampleResponseStructure: &amp;Member{},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getMeArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getMeArgs)
                return dbGetMember(ctx, args.Shard, args.Account, ctx.Me())
        }</span>,
}

var Endpoints = []*endpoint.Endpoint{
        setPublicProjectsEnabled,
        getPublicProjectsEnabled,
        setMemberRole,
        getMembers,
        getActivities,
        getMe,
}

type Member struct {
        Id          id.Id            `json:"id"`
        Name        string           `json:"name"`
        DisplayName *string          `json:"displayName,omitempty"`
        HasAvatar   bool             `json:"hasAvatar"`
        Role        cnst.AccountRole `json:"role"`
        IsActive    bool             `json:"isActive"`
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package centralaccount

import (
        "bitbucket.org/0xor1/task/server/util/clientsession"
        "bitbucket.org/0xor1/task/server/util/cnst"
        "bitbucket.org/0xor1/task/server/util/id"
        "bytes"
        "github.com/0xor1/panic"
        "io"
        "io/ioutil"
        "mime/multipart"
)

type Client interface {
        //accessible outside of active session
        GetRegions() ([]string, error)
        Register(name, email, pwd, region, language string, displayName *string, theme cnst.Theme) error
        ResendActivationEmail(email string) error
        Activate(email, activationCode string) error
        Authenticate(css *clientsession.Store, email, pwd string) (*AuthenticateResult, error)
        ConfirmNewEmail(currentEmail, newEmail, confirmationCode string) error
        ResetPwd(email string) error
        SetNewPwdFromPwdReset(newPwd, email, resetPwdCode string) error
        GetAccount(name string) (*Account, error)
        GetAccounts(accounts []id.Id) ([]*Account, error)
        SearchAccounts(nameOrDisplayNameStartsWith string) ([]*Account, error)
        SearchPersonalAccounts(nameOrDisplayNameStartsWith string) ([]*Account, error)
        //requires active session to access
        GetMe(css *clientsession.Store) (*Me, error)
        SetMyPwd(css *clientsession.Store, oldPwd, newPwd string) error
        SetMyEmail(css *clientsession.Store, newEmail string) error
        ResendMyNewEmailConfirmationEmail(css *clientsession.Store) error
        SetAccountName(css *clientsession.Store, account id.Id, newName string) error
        SetAccountDisplayName(css *clientsession.Store, account id.Id, newDisplayName *string) error
        SetAccountAvatar(css *clientsession.Store, account id.Id, avatar io.ReadCloser) error
        MigrateAccount(css *clientsession.Store, account id.Id, newRegion string) error
        CreateAccount(css *clientsession.Store, name, region string, displayName *string) (*Account, error)
        GetMyAccounts(css *clientsession.Store, after *id.Id, limit int) (*GetMyAccountsResult, error)
        DeleteAccount(css *clientsession.Store, account id.Id) error
        //member centric - must be an owner or admin
        AddMembers(css *clientsession.Store, account id.Id, newMembers []*AddMember) error
        RemoveMembers(css *clientsession.Store, account id.Id, existingMembers []id.Id) error
}

func NewClient(host string) Client <span class="cov8" title="1">{
        return &amp;client{
                host: host,
        }
}</span>

type client struct {
        host string
}

func (c *client) GetRegions() ([]string, error) <span class="cov8" title="1">{
        val, e := getRegions.DoRequest(nil, c.host, nil, nil, &amp;[]string{})
        if val != nil </span><span class="cov8" title="1">{
                return *(val.(*[]string)), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) Register(name, email, pwd, region, language string, displayName *string, theme cnst.Theme) error <span class="cov8" title="1">{
        _, e := register.DoRequest(nil, c.host, &amp;registerArgs{
                Name:        name,
                Email:       email,
                Pwd:         pwd,
                Region:      region,
                Language:    language,
                DisplayName: displayName,
                Theme:       theme,
        }, nil, nil)
        return e
}</span>

func (c *client) ResendActivationEmail(email string) error <span class="cov8" title="1">{
        _, e := resendActivationEmail.DoRequest(nil, c.host, &amp;resendActivationEmailArgs{
                Email: email,
        }, nil, nil)
        return e
}</span>

func (c *client) Activate(email, activationCode string) error <span class="cov8" title="1">{
        _, e := activate.DoRequest(nil, c.host, &amp;activateArgs{
                Email:          email,
                ActivationCode: activationCode,
        }, nil, nil)
        return e
}</span>

func (c *client) Authenticate(css *clientsession.Store, email, pwdTry string) (*AuthenticateResult, error) <span class="cov8" title="1">{
        val, e := authenticate.DoRequest(css, c.host, &amp;authenticateArgs{
                Email:  email,
                PwdTry: pwdTry,
        }, nil, &amp;AuthenticateResult{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*AuthenticateResult), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) ConfirmNewEmail(currentEmail, newEmail, confirmationCode string) error <span class="cov8" title="1">{
        _, e := confirmNewEmail.DoRequest(nil, c.host, &amp;confirmNewEmailArgs{
                CurrentEmail:     currentEmail,
                NewEmail:         newEmail,
                ConfirmationCode: confirmationCode,
        }, nil, nil)
        return e
}</span>

func (c *client) ResetPwd(email string) error <span class="cov8" title="1">{
        _, e := resetPwd.DoRequest(nil, c.host, &amp;resetPwdArgs{
                Email: email,
        }, nil, nil)
        return e
}</span>

func (c *client) SetNewPwdFromPwdReset(newPwd, email, resetPwdCode string) error <span class="cov8" title="1">{
        _, e := setNewPwdFromPwdReset.DoRequest(nil, c.host, &amp;setNewPwdFromPwdResetArgs{
                NewPwd:       newPwd,
                Email:        email,
                ResetPwdCode: resetPwdCode,
        }, nil, nil)
        return e
}</span>

func (c *client) GetAccount(name string) (*Account, error) <span class="cov8" title="1">{
        val, e := getAccount.DoRequest(nil, c.host, &amp;getAccountArgs{
                Name: name,
        }, nil, &amp;Account{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*Account), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) GetAccounts(accounts []id.Id) ([]*Account, error) <span class="cov8" title="1">{
        val, e := getAccounts.DoRequest(nil, c.host, &amp;getAccountsArgs{
                Accounts: accounts,
        }, nil, &amp;[]*Account{})
        if val != nil </span><span class="cov8" title="1">{
                return *val.(*[]*Account), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) SearchAccounts(nameOrDisplayNameStartsWith string) ([]*Account, error) <span class="cov8" title="1">{
        val, e := searchAccounts.DoRequest(nil, c.host, &amp;searchAccountsArgs{
                NameOrDisplayNameStartsWith: nameOrDisplayNameStartsWith,
        }, nil, &amp;[]*Account{})
        if val != nil </span><span class="cov8" title="1">{
                return *val.(*[]*Account), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) SearchPersonalAccounts(nameOrDisplayNameStartsWith string) ([]*Account, error) <span class="cov8" title="1">{
        val, e := searchPersonalAccounts.DoRequest(nil, c.host, &amp;searchPersonalAccountsArgs{
                NameOrDisplayNameStartsWith: nameOrDisplayNameStartsWith,
        }, nil, &amp;[]*Account{})
        if val != nil </span><span class="cov8" title="1">{
                return *val.(*[]*Account), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) GetMe(css *clientsession.Store) (*Me, error) <span class="cov8" title="1">{
        val, e := getMe.DoRequest(css, c.host, nil, nil, &amp;Me{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*Me), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) SetMyPwd(css *clientsession.Store, oldPwd, newPwd string) error <span class="cov8" title="1">{
        _, e := setMyPwd.DoRequest(css, c.host, &amp;setMyPwdArgs{
                OldPwd: oldPwd,
                NewPwd: newPwd,
        }, nil, nil)
        return e
}</span>

func (c *client) SetMyEmail(css *clientsession.Store, newEmail string) error <span class="cov8" title="1">{
        _, e := setMyEmail.DoRequest(css, c.host, &amp;setMyEmailArgs{
                NewEmail: newEmail,
        }, nil, nil)
        return e
}</span>

func (c *client) ResendMyNewEmailConfirmationEmail(css *clientsession.Store) error <span class="cov8" title="1">{
        _, e := resendMyNewEmailConfirmationEmail.DoRequest(css, c.host, nil, nil, nil)
        return e
}</span>

func (c *client) SetAccountName(css *clientsession.Store, account id.Id, newName string) error <span class="cov8" title="1">{
        _, e := setAccountName.DoRequest(css, c.host, &amp;setAccountNameArgs{
                Account: account,
                NewName: newName,
        }, nil, nil)
        return e
}</span>

func (c *client) SetAccountDisplayName(css *clientsession.Store, account id.Id, newDisplayName *string) error <span class="cov8" title="1">{
        _, e := setAccountDisplayName.DoRequest(css, c.host, &amp;setAccountDisplayNameArgs{
                Account:        account,
                NewDisplayName: newDisplayName,
        }, nil, nil)
        return e
}</span>

func (c *client) SetAccountAvatar(css *clientsession.Store, account id.Id, avatar io.ReadCloser) error <span class="cov8" title="1">{
        defer avatar.Close()
        _, e := setAccountAvatar.DoRequest(css, c.host, &amp;setAccountAvatarArgs{
                Account: account,
                Avatar:  avatar,
        }, func() (io.ReadCloser, string) </span><span class="cov8" title="1">{
                body := bytes.NewBuffer([]byte{})
                writer := multipart.NewWriter(body)
                part, e := writer.CreateFormFile("avatar", "avatar")
                panic.If(e)
                _, e = io.Copy(part, avatar)
                panic.If(e)
                panic.If(writer.WriteField("account", account.String()))
                panic.If(writer.Close())
                return ioutil.NopCloser(body), writer.FormDataContentType()
        }</span>, nil)
        <span class="cov8" title="1">return e</span>
}

func (c *client) MigrateAccount(css *clientsession.Store, account id.Id, newRegion string) error <span class="cov0" title="0">{
        _, e := migrateAccount.DoRequest(css, c.host, &amp;migrateAccountArgs{
                Account:   account,
                NewRegion: newRegion,
        }, nil, nil)
        return e
}</span>

func (c *client) CreateAccount(css *clientsession.Store, name, region string, displayName *string) (*Account, error) <span class="cov8" title="1">{
        val, e := createAccount.DoRequest(css, c.host, &amp;createAccountArgs{
                Name:        name,
                Region:      region,
                DisplayName: displayName,
        }, nil, &amp;Account{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*Account), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) GetMyAccounts(css *clientsession.Store, after *id.Id, limit int) (*GetMyAccountsResult, error) <span class="cov8" title="1">{
        val, e := getMyAccounts.DoRequest(css, c.host, &amp;getMyAccountsArgs{
                After: after,
                Limit: limit,
        }, nil, &amp;GetMyAccountsResult{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*GetMyAccountsResult), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) DeleteAccount(css *clientsession.Store, account id.Id) error <span class="cov8" title="1">{
        _, e := deleteAccount.DoRequest(css, c.host, &amp;deleteAccountArgs{
                Account: account,
        }, nil, nil)
        return e
}</span>

func (c *client) AddMembers(css *clientsession.Store, account id.Id, newMembers []*AddMember) error <span class="cov8" title="1">{
        _, e := addMembers.DoRequest(css, c.host, &amp;addMembersArgs{
                Account:    account,
                NewMembers: newMembers,
        }, nil, nil)
        return e
}</span>

func (c *client) RemoveMembers(css *clientsession.Store, account id.Id, existingMembers []id.Id) error <span class="cov0" title="0">{
        _, e := removeMembers.DoRequest(css, c.host, &amp;removeMembersArgs{
                Account:         account,
                ExistingMembers: existingMembers,
        }, nil, nil)
        return e
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package centralaccount

import (
        "bitbucket.org/0xor1/task/server/util/ctx"
        "bitbucket.org/0xor1/task/server/util/err"
        "bitbucket.org/0xor1/task/server/util/id"
        "bytes"
        "github.com/0xor1/panic"
)

func dbAccountWithCiNameExists(ctx ctx.Ctx, name string) bool <span class="cov8" title="1">{
        row := ctx.AccountQueryRow(`SELECT COUNT(*) FROM accounts WHERE name = ?`, name)
        count := 0
        panic.If(row.Scan(&amp;count))
        return count != 0
}</span>

func dbGetAccountByCiName(ctx ctx.Ctx, name string) *Account <span class="cov8" title="1">{
        row := ctx.AccountQueryRow(`SELECT id, name, displayName, createdOn, region, newRegion, shard, hasAvatar, isPersonal FROM accounts WHERE name = ?`, name)
        acc := Account{}
        if err.IsSqlErrNoRowsElsePanicIf(row.Scan(&amp;acc.Id, &amp;acc.Name, &amp;acc.DisplayName, &amp;acc.CreatedOn, &amp;acc.Region, &amp;acc.NewRegion, &amp;acc.Shard, &amp;acc.HasAvatar, &amp;acc.IsPersonal)) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;acc</span>
}

func dbCreatePersonalAccount(ctx ctx.Ctx, account *fullPersonalAccountInfo, pwdInfo *pwdInfo) <span class="cov8" title="1">{
        _, e := ctx.AccountExec(`CALL createPersonalAccount(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`, account.Id, account.Name, account.DisplayName, account.CreatedOn, account.Region, account.NewRegion, account.Shard, account.HasAvatar, account.Email, account.Language, account.Theme, account.NewEmail, account.activationCode, account.activatedOn, account.newEmailConfirmationCode, account.resetPwdCode)
        panic.If(e)
        _, e = ctx.PwdExec(`INSERT INTO pwds (id, salt, pwd, n, r, p, keyLen) VALUES (?, ?, ?, ?, ?, ?, ?)`, account.Id, pwdInfo.salt, pwdInfo.pwd, pwdInfo.n, pwdInfo.r, pwdInfo.p, pwdInfo.keyLen)
        panic.If(e)
}</span>

func dbGetPersonalAccountByEmail(ctx ctx.Ctx, email string) *fullPersonalAccountInfo <span class="cov8" title="1">{
        row := ctx.AccountQueryRow(`SELECT a.id, a.name, a.displayName, a.createdOn, a.region, a.newRegion, a.shard, a.hasAvatar, p.email, p.language, p.theme, p.newEmail, p.activationCode, p.activatedOn, p.newEmailConfirmationCode, p.resetPwdCode FROM accounts a, personalAccounts p WHERE a.id = (SELECT id FROM personalAccounts WHERE email = ?) AND p.email = ?`, email, email)
        account := fullPersonalAccountInfo{}
        account.IsPersonal = true
        if err.IsSqlErrNoRowsElsePanicIf(row.Scan(&amp;account.Id, &amp;account.Name, &amp;account.DisplayName, &amp;account.CreatedOn, &amp;account.Region, &amp;account.NewRegion, &amp;account.Shard, &amp;account.HasAvatar, &amp;account.Email, &amp;account.Language, &amp;account.Theme, &amp;account.NewEmail, &amp;account.activationCode, &amp;account.activatedOn, &amp;account.newEmailConfirmationCode, &amp;account.resetPwdCode)) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;account</span>
}

func dbGetPersonalAccountById(ctx ctx.Ctx, id id.Id) *fullPersonalAccountInfo <span class="cov8" title="1">{
        row := ctx.AccountQueryRow(`SELECT a.id, a.name, a.displayName, a.createdOn, a.region, a.newRegion, a.shard, a.hasAvatar, p.email, p.language, p.theme, p.newEmail, p.activationCode, p.activatedOn, p.newEmailConfirmationCode, p.resetPwdCode FROM accounts a, personalAccounts p WHERE a.id = ? AND p.id = ?`, id, id)
        account := fullPersonalAccountInfo{}
        account.IsPersonal = true
        if err.IsSqlErrNoRowsElsePanicIf(row.Scan(&amp;account.Id, &amp;account.Name, &amp;account.DisplayName, &amp;account.CreatedOn, &amp;account.Region, &amp;account.NewRegion, &amp;account.Shard, &amp;account.HasAvatar, &amp;account.Email, &amp;account.Language, &amp;account.Theme, &amp;account.NewEmail, &amp;account.activationCode, &amp;account.activatedOn, &amp;account.newEmailConfirmationCode, &amp;account.resetPwdCode)) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;account</span>
}

func dbGetPwdInfo(ctx ctx.Ctx, id id.Id) *pwdInfo <span class="cov8" title="1">{
        row := ctx.PwdQueryRow(`SELECT salt, pwd, n, r, p, keyLen FROM pwds WHERE id = ?`, id)
        pwd := pwdInfo{}
        if err.IsSqlErrNoRowsElsePanicIf(row.Scan(&amp;pwd.salt, &amp;pwd.pwd, &amp;pwd.n, &amp;pwd.r, &amp;pwd.p, &amp;pwd.keyLen)) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;pwd</span>
}

func dbUpdatePersonalAccount(ctx ctx.Ctx, personalAccountInfo *fullPersonalAccountInfo) <span class="cov8" title="1">{
        _, e := ctx.AccountExec(`CALL updatePersonalAccount(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`, personalAccountInfo.Id, personalAccountInfo.Name, personalAccountInfo.DisplayName, personalAccountInfo.CreatedOn, personalAccountInfo.Region, personalAccountInfo.NewRegion, personalAccountInfo.Shard, personalAccountInfo.HasAvatar, personalAccountInfo.Email, personalAccountInfo.Language, personalAccountInfo.Theme, personalAccountInfo.NewEmail, personalAccountInfo.activationCode, personalAccountInfo.activatedOn, personalAccountInfo.newEmailConfirmationCode, personalAccountInfo.resetPwdCode)
        panic.If(e)
}</span>

func dbUpdateAccount(ctx ctx.Ctx, account *Account) <span class="cov8" title="1">{
        _, e := ctx.AccountExec(`CALL updateAccountInfo(?, ?, ?, ?, ?, ?, ?, ?, ?)`, account.Id, account.Name, account.DisplayName, account.CreatedOn, account.Region, account.NewRegion, account.Shard, account.HasAvatar, account.IsPersonal)
        panic.If(e)
}</span>

func dbUpdatePwdInfo(ctx ctx.Ctx, id id.Id, pwdInfo *pwdInfo) <span class="cov8" title="1">{
        _, e := ctx.PwdExec(`UPDATE pwds SET salt=?, pwd=?, n=?, r=?, p=?, keyLen=? WHERE id = ?`, pwdInfo.salt, pwdInfo.pwd, pwdInfo.n, pwdInfo.r, pwdInfo.p, pwdInfo.keyLen, id)
        panic.If(e)
}</span>

func dbDeleteAccountAndAllAssociatedMemberships(ctx ctx.Ctx, id id.Id) <span class="cov8" title="1">{
        _, e := ctx.AccountExec(`CALL deleteAccountAndAllAssociatedMemberships(?)`, id)
        panic.If(e)
        _, e = ctx.PwdExec(`DELETE FROM pwds WHERE id = ?`, id)
        panic.If(e)
}</span>

func dbGetAccount(ctx ctx.Ctx, id id.Id) *Account <span class="cov8" title="1">{
        row := ctx.AccountQueryRow(`SELECT id, name, displayName, createdOn, region, newRegion, shard, hasAvatar, isPersonal FROM accounts WHERE id = ?`, id)
        a := Account{}
        if err.IsSqlErrNoRowsElsePanicIf(row.Scan(&amp;a.Id, &amp;a.Name, &amp;a.DisplayName, &amp;a.CreatedOn, &amp;a.Region, &amp;a.NewRegion, &amp;a.Shard, &amp;a.HasAvatar, &amp;a.IsPersonal)) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;a</span>
}

func dbGetAccounts(ctx ctx.Ctx, ids []id.Id) []*Account <span class="cov8" title="1">{
        args := make([]interface{}, 0, len(ids))
        args = append(args, ids[0])
        query := bytes.NewBufferString(`SELECT id, name, displayName, createdOn, region, newRegion, shard, hasAvatar, isPersonal FROM accounts WHERE id IN (?`)
        for _, i := range ids[1:] </span><span class="cov0" title="0">{
                query.WriteString(`,?`)
                args = append(args, i)
        }</span>
        <span class="cov8" title="1">query.WriteString(`)`)
        rows, e := ctx.AccountQuery(query.String(), args...)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.If(e)
        res := make([]*Account, 0, len(ids))
        for rows.Next() </span><span class="cov8" title="1">{
                a := Account{}
                panic.If(rows.Scan(&amp;a.Id, &amp;a.Name, &amp;a.DisplayName, &amp;a.CreatedOn, &amp;a.Region, &amp;a.NewRegion, &amp;a.Shard, &amp;a.HasAvatar, &amp;a.IsPersonal))
                res = append(res, &amp;a)
        }</span>
        <span class="cov8" title="1">return res</span>
}

func dbSearchAccounts(ctx ctx.Ctx, nameOrDisplayNameStartsWith string) []*Account <span class="cov8" title="1">{
        searchTerm := nameOrDisplayNameStartsWith + "%"
        //rows, err := ctx.AccountQuery(`SELECT DISTINCT a.id, a.name, a.displayName, a.createdOn, a.region, a.newRegion, a.shard, a.hasAvatar, a.isPersonal FROM ((SELECT id, name, displayName, createdOn, region, newRegion, shard, hasAvatar, isPersonal FROM accounts WHERE name LIKE ? ORDER BY name ASC LIMIT ?, ?) UNION (SELECT id, name, displayName, createdOn, region, newRegion, shard, hasAvatar, isPersonal FROM accounts WHERE displayName LIKE ? ORDER BY name ASC LIMIT ?, ?)) AS a ORDER BY name ASC LIMIT ?, ?`, searchTerm, 0, 100, searchTerm, 0, 100, 0, 100)
        //TODO need to profile these queries to check for best performance
        rows, e := ctx.AccountQuery(`SELECT id, name, displayName, createdOn, region, newRegion, shard, hasAvatar, isPersonal FROM accounts WHERE name LIKE ? OR displayName LIKE ? ORDER BY name ASC LIMIT ?, ?`, searchTerm, searchTerm, 0, 100)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.If(e)

        res := make([]*Account, 0, 100)
        for rows.Next() </span><span class="cov8" title="1">{
                acc := Account{}
                panic.If(rows.Scan(&amp;acc.Id, &amp;acc.Name, &amp;acc.DisplayName, &amp;acc.CreatedOn, &amp;acc.Region, &amp;acc.NewRegion, &amp;acc.Shard, &amp;acc.HasAvatar, &amp;acc.IsPersonal))
                res = append(res, &amp;acc)
        }</span>
        <span class="cov8" title="1">return res</span>
}

func dbSearchPersonalAccounts(ctx ctx.Ctx, nameOrDisplayNameStartsWith string) []*Account <span class="cov8" title="1">{
        //rows, e := ctx.AccountQuery(`SELECT id, name, displayName, createdOn, region, newRegion, shard, hasAvatar FROM accounts WHERE isPersonal=TRUE AND name LIKE ? OR displayName LIKE ? ORDER BY name ASC LIMIT ?`, searchTerm, searchTerm, 100)
        //TODO need to profile these queries to check for best performance
        searchTerm := nameOrDisplayNameStartsWith + "%"
        rows, e := ctx.AccountQuery(`SELECT DISTINCT a.id, a.name, a.displayName, a.createdOn, a.region, a.newRegion, a.shard, a.hasAvatar FROM ((SELECT id, name, displayName, createdOn, region, newRegion, shard, hasAvatar FROM accounts WHERE isPersonal=TRUE AND name LIKE ? ORDER BY name ASC LIMIT ?) UNION (SELECT id, name, displayName, createdOn, region, newRegion, shard, hasAvatar FROM accounts WHERE isPersonal=TRUE AND displayName LIKE ? ORDER BY name ASC LIMIT ?)) AS a ORDER BY name ASC LIMIT ?`, searchTerm, 100, searchTerm, 100, 100)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.If(e)

        res := make([]*Account, 0, 100)
        for rows.Next() </span><span class="cov8" title="1">{
                acc := Account{}
                acc.IsPersonal = true
                panic.If(rows.Scan(&amp;acc.Id, &amp;acc.Name, &amp;acc.DisplayName, &amp;acc.CreatedOn, &amp;acc.Region, &amp;acc.NewRegion, &amp;acc.Shard, &amp;acc.HasAvatar))
                res = append(res, &amp;acc)
        }</span>
        <span class="cov8" title="1">return res</span>
}

func dbGetPersonalAccounts(ctx ctx.Ctx, ids []id.Id) []*Account <span class="cov8" title="1">{
        args := make([]interface{}, 0, len(ids))
        args = append(args, ids[0])
        query := bytes.NewBufferString(` SELECT id, name, displayName, createdOn, region, newRegion, shard, hasAvatar FROM accounts WHERE id IN (SELECT id FROM personalAccounts WHERE id IN (?`)
        for _, i := range ids[1:] </span><span class="cov8" title="1">{
                query.WriteString(`,?`)
                args = append(args, i)
        }</span>
        <span class="cov8" title="1">query.WriteString(`) AND activatedOn IS NOT NULL)`)
        rows, e := ctx.AccountQuery(query.String(), args...)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.If(e)
        res := make([]*Account, 0, len(ids))
        for rows.Next() </span><span class="cov8" title="1">{
                acc := Account{}
                acc.IsPersonal = true
                panic.If(rows.Scan(&amp;acc.Id, &amp;acc.Name, &amp;acc.DisplayName, &amp;acc.CreatedOn, &amp;acc.Region, &amp;acc.NewRegion, &amp;acc.Shard, &amp;acc.HasAvatar))
                res = append(res, &amp;acc)
        }</span>
        <span class="cov8" title="1">return res</span>
}

func dbCreateGroupAccountAndMembership(ctx ctx.Ctx, account *Account, member id.Id) <span class="cov8" title="1">{
        _, e := ctx.AccountExec(`CALL  createGroupAccountAndMembership(?, ?, ?, ?, ?, ?, ?, ?, ?)`, account.Id, account.Name, account.DisplayName, account.CreatedOn, account.Region, account.NewRegion, account.Shard, account.HasAvatar, member)
        panic.If(e)
}</span>

func dbGetGroupAccounts(ctx ctx.Ctx, member id.Id, after *id.Id, limit int) ([]*Account, bool) <span class="cov8" title="1">{
        args := make([]interface{}, 0, 3)
        query := bytes.NewBufferString(`SELECT id, name, displayName, createdOn, region, newRegion, shard, hasAvatar, isPersonal FROM accounts WHERE id IN (SELECT account FROM memberships WHERE member = ?)`)
        args = append(args, member)
        if after != nil </span><span class="cov8" title="1">{
                query.WriteString(` AND name &gt; (SELECT name FROM accounts WHERE id = ?)`)
                args = append(args, *after)
        }</span>
        <span class="cov8" title="1">query.WriteString(` ORDER BY name ASC LIMIT ?`)
        args = append(args, limit+1)
        rows, e := ctx.AccountQuery(query.String(), args...)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.If(e)
        res := make([]*Account, 0, limit+1)
        for rows.Next() </span><span class="cov8" title="1">{
                a := Account{}
                panic.If(rows.Scan(&amp;a.Id, &amp;a.Name, &amp;a.DisplayName, &amp;a.CreatedOn, &amp;a.Region, &amp;a.NewRegion, &amp;a.Shard, &amp;a.HasAvatar, &amp;a.IsPersonal))
                res = append(res, &amp;a)
        }</span>
        <span class="cov8" title="1">if len(res) == limit+1 </span><span class="cov8" title="1">{
                return res[:limit], true
        }</span>
        <span class="cov8" title="1">return res, false</span>
}

func dbCreateMemberships(ctx ctx.Ctx, account id.Id, members []id.Id) <span class="cov8" title="1">{
        args := make([]interface{}, 0, len(members)*2)
        args = append(args, account, members[0])
        query := bytes.NewBufferString(`INSERT INTO memberships (account, member) VALUES (?,?)`)
        for _, member := range members[1:] </span><span class="cov8" title="1">{
                query.WriteString(`,(?,?)`)
                args = append(args, account, member)
        }</span>
        <span class="cov8" title="1">_, e := ctx.AccountExec(query.String(), args...)
        panic.If(e)</span>
}

func dbDeleteMemberships(ctx ctx.Ctx, account id.Id, members []id.Id) <span class="cov0" title="0">{
        args := make([]interface{}, 0, len(members)+1)
        args = append(args, account, members[0])
        query := bytes.NewBufferString(`DELETE FROM memberships WHERE account=? AND member IN (?`)
        for _, member := range members[1:] </span><span class="cov0" title="0">{
                query.WriteString(`,?`)
                args = append(args, member)
        }</span>
        <span class="cov0" title="0">query.WriteString(`)`)
        _, e := ctx.AccountExec(query.String(), args...)
        panic.If(e)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package centralaccount

import (
        "bitbucket.org/0xor1/task/server/util/ctx"
        "fmt"
)

func emailSendMultipleAccountPolicyNotice(ctx ctx.Ctx, address string) <span class="cov0" title="0">{
        ctx.MailClient().Send([]string{address}, "sendMultipleAccountPolicyNotice")
}</span>

func emailSendActivationLink(ctx ctx.Ctx, address, activationCode string) <span class="cov8" title="1">{
        ctx.MailClient().Send([]string{address}, fmt.Sprintf("sendActivationLink: activationCode: %s", activationCode))
}</span>

func emailSendPwdResetLink(ctx ctx.Ctx, address, resetCode string) <span class="cov8" title="1">{
        ctx.MailClient().Send([]string{address}, fmt.Sprintf("sendPwdResetLink: resetCode: %s", resetCode))
}</span>

func emailSendNewEmailConfirmationLink(ctx ctx.Ctx, currentAddress, newAddress, confirmationCode string) <span class="cov8" title="1">{
        ctx.MailClient().Send([]string{newAddress}, fmt.Sprintf("sendNewEmailConfirmationLink: currentAddress: %s newAddress: %s confirmationCode: %s", currentAddress, newAddress, confirmationCode))
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package centralaccount

import (
        "bitbucket.org/0xor1/task/server/util/cnst"
        "bitbucket.org/0xor1/task/server/util/crypt"
        "bitbucket.org/0xor1/task/server/util/ctx"
        "bitbucket.org/0xor1/task/server/util/endpoint"
        "bitbucket.org/0xor1/task/server/util/err"
        "bitbucket.org/0xor1/task/server/util/id"
        "bitbucket.org/0xor1/task/server/util/private"
        t "bitbucket.org/0xor1/task/server/util/time"
        "bitbucket.org/0xor1/task/server/util/validate"
        "bytes"
        "github.com/0xor1/panic"
        "github.com/nfnt/resize"
        "image"
        _ "image/gif"
        _ "image/jpeg"
        "image/png"
        "io"
        "net/http"
        "strings"
        "time"
        "unicode/utf8"
)

var (
        // errors
        noSuchAccountErr                      = &amp;err.Err{Code: "c_v1_ca_nsa", Message: "no such account"}
        invalidActivationAttemptErr           = &amp;err.Err{Code: "c_v1_ca_iaa", Message: "invalid activation attempt"}
        invalidResetPwdAttemptErr             = &amp;err.Err{Code: "c_v1_ca_irpa", Message: "invalid reset password attempt"}
        invalidNewEmailConfirmationAttemptErr = &amp;err.Err{Code: "c_v1_ca_ineca", Message: "invalid new email confirmation attempt"}
        invalidNameOrPwdErr                   = &amp;err.Err{Code: "c_v1_ca_inop", Message: "invalid name or password"}
        incorrectPwdErr                       = &amp;err.Err{Code: "c_v1_ca_ip", Message: "password incorrect"}
        accountNotActivatedErr                = &amp;err.Err{Code: "c_v1_ca_ana", Message: "account not activated"}
        emailAlreadyInUseErr                  = &amp;err.Err{Code: "c_v1_ca_eaiu", Message: "email already in use"}
        nameAlreadyInUseErr                   = &amp;err.Err{Code: "c_v1_ca_naiu", Message: "name already in use"}
        emailConfirmationCodeErr              = &amp;err.Err{Code: "c_v1_ca_ecc", Message: "email confirmation code is of zero length"}
        noNewEmailRegisteredErr               = &amp;err.Err{Code: "c_v1_ca_nner", Message: "no new email registered"}
        onlyOwnerMemberErr                    = &amp;err.Err{Code: "c_v1_ca_oom", Message: "can't delete member who is the only owner of an account"}
        invalidAvatarShapeErr                 = &amp;err.Err{Code: "c_v1_ca_ias", Message: "avatar images must be square"}
)

//endpoints

var getRegions = &amp;endpoint.Endpoint{
        Method:                   http.MethodGet,
        Path:                     "/api/v1/centralAccount/getRegions",
        RequiresSession:          false,
        ExampleResponseStructure: []string{"use", "usw", "eu"},
        CtxHandler: func(ctx ctx.Ctx, _ interface{}) interface{} <span class="cov8" title="1">{
                return ctx.RegionalV1PrivateClient().GetRegions()
        }</span>,
}

type registerArgs struct {
        Name        string     `json:"name"`
        Email       string     `json:"email"`
        Pwd         string     `json:"pwd"`
        Region      string     `json:"region"`
        Language    string     `json:"language"`
        DisplayName *string    `json:"displayName"`
        Theme       cnst.Theme `json:"theme"`
}

var register = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/centralAccount/register",
        RequiresSession: false,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;registerArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*registerArgs)
                args.Name = strings.Trim(args.Name, " ")
                validate.StringArg("name", args.Name, ctx.NameMinRuneCount(), ctx.NameMaxRuneCount(), ctx.NameRegexMatchers())
                args.Email = strings.Trim(args.Email, " ")
                validate.Email(args.Email)
                validate.StringArg("pwd", args.Pwd, ctx.PwdMinRuneCount(), ctx.PwdMaxRuneCount(), ctx.PwdRegexMatchers())
                args.Language = strings.Trim(args.Language, " ") // may need more validation than this at some point to check it is a language we support and not a junk value, but it isnt critical right now
                args.Theme.Validate()
                if args.DisplayName != nil </span><span class="cov8" title="1">{
                        *args.DisplayName = strings.Trim(*args.DisplayName, " ")
                        if *args.DisplayName == "" </span><span class="cov0" title="0">{
                                args.DisplayName = nil
                        }</span>
                }

                <span class="cov8" title="1">panic.IfTrueWith(!ctx.RegionalV1PrivateClient().IsValidRegion(args.Region), err.NoSuchRegion)
                panic.IfTrueWith(dbAccountWithCiNameExists(ctx, args.Name), nameAlreadyInUseErr)

                if acc := dbGetPersonalAccountByEmail(ctx, args.Email); acc != nil </span><span class="cov0" title="0">{
                        emailSendMultipleAccountPolicyNotice(ctx, acc.Email)
                }</span>

                <span class="cov8" title="1">activationCode := crypt.UrlSafeString(ctx.CryptCodeLen())
                acc := &amp;fullPersonalAccountInfo{}
                acc.Id = id.New()
                acc.Name = args.Name
                acc.DisplayName = args.DisplayName
                acc.CreatedOn = t.Now()
                acc.Region = args.Region

                defer func() </span><span class="cov8" title="1">{
                        r := recover()
                        if r != nil </span><span class="cov0" title="0">{
                                dbDeleteAccountAndAllAssociatedMemberships(ctx, acc.Id)
                                panic.If(r)
                        }</span>
                }()
                <span class="cov8" title="1">var e error
                acc.Shard, e = ctx.RegionalV1PrivateClient().CreateAccount(acc.Region, acc.Id, acc.Id, acc.Name, acc.DisplayName, acc.HasAvatar)
                panic.If(e)
                acc.IsPersonal = true
                acc.Email = args.Email
                acc.Language = args.Language
                acc.Theme = args.Theme
                acc.activationCode = &amp;activationCode

                pwdInfo := &amp;pwdInfo{}
                pwdInfo.salt = crypt.Bytes(ctx.SaltLen())
                pwdInfo.pwd = crypt.ScryptKey([]byte(args.Pwd), pwdInfo.salt, ctx.ScryptN(), ctx.ScryptR(), ctx.ScryptP(), ctx.ScryptKeyLen())
                pwdInfo.n = ctx.ScryptN()
                pwdInfo.r = ctx.ScryptR()
                pwdInfo.p = ctx.ScryptP()
                pwdInfo.keyLen = ctx.ScryptKeyLen()

                dbCreatePersonalAccount(ctx, acc, pwdInfo)

                emailSendActivationLink(ctx, args.Email, *acc.activationCode)
                return nil</span>
        },
}

type resendActivationEmailArgs struct {
        Email string `json:"email"`
}

var resendActivationEmail = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/centralAccount/resendActivationEmail",
        RequiresSession: false,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;resendActivationEmailArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*resendActivationEmailArgs)
                args.Email = strings.Trim(args.Email, " ")
                acc := dbGetPersonalAccountByEmail(ctx, args.Email)
                if acc == nil || acc.isActivated() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">emailSendActivationLink(ctx, args.Email, *acc.activationCode)
                return nil</span>
        },
}

type activateArgs struct {
        Email          string `json:"email"`
        ActivationCode string `json:"activationCode"`
}

var activate = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/centralAccount/activate",
        RequiresSession: false,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;activateArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*activateArgs)
                args.ActivationCode = strings.Trim(args.ActivationCode, " ")
                acc := dbGetPersonalAccountByEmail(ctx, args.Email)
                panic.IfTrueWith(acc == nil || acc.activationCode == nil || args.ActivationCode != *acc.activationCode, invalidActivationAttemptErr)
                acc.activationCode = nil
                activationTime := t.Now()
                acc.activatedOn = &amp;activationTime
                dbUpdatePersonalAccount(ctx, acc)
                return nil
        }</span>,
}

type authenticateArgs struct {
        Email  string `json:"email"`
        PwdTry string `json:"pwdTry"`
}

type AuthenticateResult struct{
        Me *Me                          `json:"me"`
        MyAccounts *GetMyAccountsResult `json:"myAccounts"`
}

func (ar *AuthenticateResult) Id() id.Id <span class="cov8" title="1">{
        return ar.Me.Id
}</span>

var authenticate = &amp;endpoint.Endpoint{
        Method:                   http.MethodPost,
        Path:                     "/api/v1/centralAccount/authenticate",
        RequiresSession:          false,
        ExampleResponseStructure: &amp;Me{},
        IsAuthentication:         true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;authenticateArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*authenticateArgs)
                args.Email = strings.Trim(args.Email, " ")
                acc := dbGetPersonalAccountByEmail(ctx, args.Email)
                panic.IfTrueWith(acc == nil, invalidNameOrPwdErr)

                pwdInfo := dbGetPwdInfo(ctx, acc.Id)
                scryptPwdTry := crypt.ScryptKey([]byte(args.PwdTry), pwdInfo.salt, pwdInfo.n, pwdInfo.r, pwdInfo.p, pwdInfo.keyLen)
                panic.IfTrueWith(!pwdsMatch(pwdInfo.pwd, scryptPwdTry), invalidNameOrPwdErr)

                //must do this after checking the acc has the correct pwd otherwise it allows anyone to fish for valid emails on the system
                panic.IfTrueWith(!acc.isActivated(), accountNotActivatedErr)

                //if there was an outstanding password reset on this acc, remove it, they have since remembered their password
                if acc.resetPwdCode != nil &amp;&amp; len(*acc.resetPwdCode) &gt; 0 </span><span class="cov0" title="0">{
                        acc.resetPwdCode = nil
                        dbUpdatePersonalAccount(ctx, acc)
                }</span>
                // check that the password is encrypted with the latest scrypt settings, if not, encrypt again using the latest settings
                <span class="cov8" title="1">if pwdInfo.n != ctx.ScryptN() || pwdInfo.r != ctx.ScryptR() || pwdInfo.p != ctx.ScryptP() || pwdInfo.keyLen != ctx.ScryptKeyLen() || len(pwdInfo.salt) != ctx.SaltLen() </span><span class="cov0" title="0">{
                        pwdInfo.salt = crypt.Bytes(ctx.SaltLen())
                        pwdInfo.n = ctx.ScryptN()
                        pwdInfo.r = ctx.ScryptR()
                        pwdInfo.p = ctx.ScryptP()
                        pwdInfo.keyLen = ctx.ScryptKeyLen()
                        pwdInfo.pwd = crypt.ScryptKey([]byte(args.PwdTry), pwdInfo.salt, pwdInfo.n, pwdInfo.r, pwdInfo.p, pwdInfo.keyLen)
                        dbUpdatePwdInfo(ctx, acc.Id, pwdInfo)
                }</span>

                <span class="cov8" title="1">myAccounts, more := dbGetGroupAccounts(ctx, acc.Id, nil, 100)
                return &amp;AuthenticateResult{
                        Me: &amp;acc.Me,
                        MyAccounts: &amp;GetMyAccountsResult{
                                Accounts: myAccounts,
                                More: more,
                        },
                }</span>
        },
}

type confirmNewEmailArgs struct {
        CurrentEmail     string `json:"currentEmail"`
        NewEmail         string `json:"newEmail"`
        ConfirmationCode string `json:"confirmationCode"`
}

var confirmNewEmail = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/centralAccount/confirmNewEmail",
        RequiresSession: false,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;confirmNewEmailArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*confirmNewEmailArgs)
                acc := dbGetPersonalAccountByEmail(ctx, args.CurrentEmail)
                panic.IfTrueWith(acc == nil || acc.NewEmail == nil || args.NewEmail != *acc.NewEmail || acc.newEmailConfirmationCode == nil || args.ConfirmationCode != *acc.newEmailConfirmationCode, invalidNewEmailConfirmationAttemptErr)

                newAcc := dbGetPersonalAccountByEmail(ctx, args.NewEmail)
                panic.IfTrueWith(newAcc != nil, emailAlreadyInUseErr)

                acc.Email = args.NewEmail
                acc.NewEmail = nil
                acc.newEmailConfirmationCode = nil
                dbUpdatePersonalAccount(ctx, acc)
                return nil
        }</span>,
}

type resetPwdArgs struct {
        Email string `json:"email"`
}

var resetPwd = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/centralAccount/resetPwd",
        RequiresSession: false,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;resetPwdArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*resetPwdArgs)
                args.Email = strings.Trim(args.Email, " ")
                acc := dbGetPersonalAccountByEmail(ctx, args.Email)
                if acc == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">resetPwdCode := crypt.UrlSafeString(ctx.CryptCodeLen())

                acc.resetPwdCode = &amp;resetPwdCode
                dbUpdatePersonalAccount(ctx, acc)

                emailSendPwdResetLink(ctx, args.Email, resetPwdCode)
                return nil</span>
        },
}

type setNewPwdFromPwdResetArgs struct {
        Email        string `json:"email"`
        ResetPwdCode string `json:"resetCode"`
        NewPwd       string `json:"newPwd"`
}

var setNewPwdFromPwdReset = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/centralAccount/setNewPwdFromPwdReset",
        RequiresSession: false,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setNewPwdFromPwdResetArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setNewPwdFromPwdResetArgs)
                validate.StringArg("pwd", args.NewPwd, ctx.PwdMinRuneCount(), ctx.PwdMaxRuneCount(), ctx.PwdRegexMatchers())

                acc := dbGetPersonalAccountByEmail(ctx, args.Email)
                panic.IfTrueWith(acc == nil || acc.resetPwdCode == nil || args.ResetPwdCode != *acc.resetPwdCode, invalidResetPwdAttemptErr)

                scryptSalt := crypt.Bytes(ctx.SaltLen())
                scryptPwd := crypt.ScryptKey([]byte(args.NewPwd), scryptSalt, ctx.ScryptN(), ctx.ScryptR(), ctx.ScryptP(), ctx.ScryptKeyLen())

                acc.activationCode = nil
                acc.resetPwdCode = nil
                dbUpdatePersonalAccount(ctx, acc)

                pwdInfo := &amp;pwdInfo{}
                pwdInfo.pwd = scryptPwd
                pwdInfo.salt = scryptSalt
                pwdInfo.n = ctx.ScryptN()
                pwdInfo.r = ctx.ScryptR()
                pwdInfo.p = ctx.ScryptP()
                pwdInfo.keyLen = ctx.ScryptKeyLen()
                dbUpdatePwdInfo(ctx, acc.Id, pwdInfo)
                return nil
        }</span>,
}

type getAccountArgs struct {
        Name string `json:"name"`
}

var getAccount = &amp;endpoint.Endpoint{
        Method:                   http.MethodGet,
        Path:                     "/api/v1/centralAccount/getAccount",
        RequiresSession:          false,
        ExampleResponseStructure: &amp;Account{},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getAccountArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getAccountArgs)
                return dbGetAccountByCiName(ctx, strings.Trim(args.Name, " "))
        }</span>,
}

type getAccountsArgs struct {
        Accounts []id.Id `json:"accounts"`
}

var getAccounts = &amp;endpoint.Endpoint{
        Method:                   http.MethodGet,
        Path:                     "/api/v1/centralAccount/getAccounts",
        RequiresSession:          false,
        ExampleResponseStructure: []*Account{{}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getAccountsArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getAccountsArgs)
                validate.EntityCount(len(args.Accounts), ctx.MaxProcessEntityCount())

                return dbGetAccounts(ctx, args.Accounts)
        }</span>,
}

type searchAccountsArgs struct {
        NameOrDisplayNameStartsWith string `json:"nameOrDisplayNameStartsWith"`
}

var searchAccounts = &amp;endpoint.Endpoint{
        Method:                   http.MethodGet,
        Path:                     "/api/v1/centralAccount/searchAccounts",
        RequiresSession:          false,
        ExampleResponseStructure: []*Account{{}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;searchAccountsArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*searchAccountsArgs)
                args.NameOrDisplayNameStartsWith = strings.Trim(args.NameOrDisplayNameStartsWith, " ")
                panic.IfTrueWith(utf8.RuneCountInString(args.NameOrDisplayNameStartsWith) &lt; 3 || strings.Contains(args.NameOrDisplayNameStartsWith, "%"), err.InvalidArguments)
                return dbSearchAccounts(ctx, args.NameOrDisplayNameStartsWith)
        }</span>,
}

type searchPersonalAccountsArgs struct {
        NameOrDisplayNameStartsWith string `json:"nameOrDisplayNameStartsWith"`
}

var searchPersonalAccounts = &amp;endpoint.Endpoint{
        Method:                   http.MethodGet,
        Path:                     "/api/v1/centralAccount/searchPersonalAccounts",
        RequiresSession:          false,
        ExampleResponseStructure: []*Account{{}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;searchPersonalAccountsArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*searchPersonalAccountsArgs)
                args.NameOrDisplayNameStartsWith = strings.Trim(args.NameOrDisplayNameStartsWith, " ")
                panic.IfTrueWith(utf8.RuneCountInString(args.NameOrDisplayNameStartsWith) &lt; 3 || strings.Contains(args.NameOrDisplayNameStartsWith, "%"), err.InvalidArguments)
                return dbSearchPersonalAccounts(ctx, args.NameOrDisplayNameStartsWith)
        }</span>,
}

var getMe = &amp;endpoint.Endpoint{
        Method:                   http.MethodGet,
        Path:                     "/api/v1/centralAccount/getMe",
        RequiresSession:          true,
        ExampleResponseStructure: &amp;Me{},
        CtxHandler: func(ctx ctx.Ctx, _ interface{}) interface{} <span class="cov8" title="1">{
                acc := dbGetPersonalAccountById(ctx, ctx.Me())
                panic.IfTrueWith(acc == nil, noSuchAccountErr)
                return &amp;acc.Me
        }</span>,
}

type setMyPwdArgs struct {
        NewPwd string `json:"newPwd"`
        OldPwd string `json:"oldPwd"`
}

var setMyPwd = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/centralAccount/setMyPwd",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setMyPwdArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setMyPwdArgs)
                validate.StringArg("pwd", args.NewPwd, ctx.PwdMinRuneCount(), ctx.PwdMaxRuneCount(), ctx.PwdRegexMatchers())

                pwdInfo := dbGetPwdInfo(ctx, ctx.Me())
                panic.IfTrueWith(pwdInfo == nil, noSuchAccountErr)

                scryptPwdTry := crypt.ScryptKey([]byte(args.OldPwd), pwdInfo.salt, pwdInfo.n, pwdInfo.r, pwdInfo.p, pwdInfo.keyLen)

                panic.IfTrueWith(!pwdsMatch(pwdInfo.pwd, scryptPwdTry), incorrectPwdErr)

                pwdInfo.salt = crypt.Bytes(ctx.SaltLen())
                pwdInfo.pwd = crypt.ScryptKey([]byte(args.NewPwd), pwdInfo.salt, ctx.ScryptN(), ctx.ScryptR(), ctx.ScryptP(), ctx.ScryptKeyLen())
                pwdInfo.n = ctx.ScryptN()
                pwdInfo.r = ctx.ScryptR()
                pwdInfo.p = ctx.ScryptP()
                pwdInfo.keyLen = ctx.ScryptKeyLen()
                dbUpdatePwdInfo(ctx, ctx.Me(), pwdInfo)
                return nil
        }</span>,
}

type setMyEmailArgs struct {
        NewEmail string `json:"newEmail"`
}

var setMyEmail = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/centralAccount/setMyEmail",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setMyEmailArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setMyEmailArgs)
                args.NewEmail = strings.Trim(args.NewEmail, " ")
                validate.Email(args.NewEmail)

                if acc := dbGetPersonalAccountByEmail(ctx, args.NewEmail); acc != nil </span><span class="cov0" title="0">{
                        emailSendMultipleAccountPolicyNotice(ctx, acc.Email)
                }</span>

                <span class="cov8" title="1">acc := dbGetPersonalAccountById(ctx, ctx.Me())
                panic.IfTrueWith(acc == nil, noSuchAccountErr)

                confirmationCode := crypt.UrlSafeString(ctx.CryptCodeLen())

                acc.NewEmail = &amp;args.NewEmail
                acc.newEmailConfirmationCode = &amp;confirmationCode
                dbUpdatePersonalAccount(ctx, acc)
                emailSendNewEmailConfirmationLink(ctx, acc.Email, args.NewEmail, confirmationCode)
                return nil</span>
        },
}

var resendMyNewEmailConfirmationEmail = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/centralAccount/resendMyNewEmailConfirmationEmail",
        RequiresSession: true,
        CtxHandler: func(ctx ctx.Ctx, _ interface{}) interface{} <span class="cov8" title="1">{
                acc := dbGetPersonalAccountById(ctx, ctx.Me())
                panic.IfTrueWith(acc == nil, noSuchAccountErr)

                // check the acc has actually registered a new email
                panic.IfTrueWith(acc.NewEmail == nil, noNewEmailRegisteredErr)

                // just in case something has gone crazy wrong
                panic.IfTrueWith(acc.newEmailConfirmationCode == nil, emailConfirmationCodeErr)

                emailSendNewEmailConfirmationLink(ctx, acc.Email, *acc.NewEmail, *acc.newEmailConfirmationCode)
                return nil
        }</span>,
}

type setAccountNameArgs struct {
        Account id.Id  `json:"account"`
        NewName string `json:"newName"`
}

var setAccountName = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/centralAccount/setAccountName",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setAccountNameArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setAccountNameArgs)
                args.NewName = strings.Trim(args.NewName, " ")
                validate.StringArg("name", args.NewName, ctx.NameMinRuneCount(), ctx.NameMaxRuneCount(), ctx.NameRegexMatchers())

                panic.IfTrueWith(dbAccountWithCiNameExists(ctx, args.NewName), nameAlreadyInUseErr)

                acc := dbGetAccount(ctx, args.Account)
                panic.IfTrueWith(acc == nil, noSuchAccountErr)

                if !ctx.Me().Equal(args.Account) </span><span class="cov0" title="0">{
                        panic.IfTrueWith(acc.IsPersonal, err.InsufficientPermission) // can't rename someone else's personal account

                        isAccountOwner, e := ctx.RegionalV1PrivateClient().MemberIsAccountOwner(acc.Region, acc.Shard, args.Account, ctx.Me())
                        panic.If(e)
                        panic.IfTrueWith(!isAccountOwner, err.InsufficientPermission)
                }</span>

                <span class="cov8" title="1">acc.Name = args.NewName
                dbUpdateAccount(ctx, acc)

                if ctx.Me().Equal(args.Account) </span><span class="cov8" title="1">{ // if i did rename my personal account, i need to update all the stored names in all the accounts Im a member of
                        ctx.RegionalV1PrivateClient().SetMemberName(acc.Region, acc.Shard, acc.Id, ctx.Me(), args.NewName) //first rename myself in my personal org
                        var after *id.Id
                        for </span><span class="cov8" title="1">{
                                accs, more := dbGetGroupAccounts(ctx, ctx.Me(), after, 100)
                                for _, acc := range accs </span><span class="cov0" title="0">{
                                        ctx.RegionalV1PrivateClient().SetMemberName(acc.Region, acc.Shard, acc.Id, ctx.Me(), args.NewName)
                                }</span>
                                <span class="cov8" title="1">if more </span><span class="cov0" title="0">{
                                        after = &amp;accs[len(accs)-1].Id
                                }</span><span class="cov8" title="1"> else {
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">return nil</span>
        },
}

type setAccountDisplayNameArgs struct {
        Account        id.Id   `json:"account"`
        NewDisplayName *string `json:"newDisplayName"`
}

var setAccountDisplayName = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/centralAccount/setAccountDisplayName",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setAccountDisplayNameArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setAccountDisplayNameArgs)
                if args.NewDisplayName != nil </span><span class="cov8" title="1">{
                        *args.NewDisplayName = strings.Trim(*args.NewDisplayName, " ")
                        if *args.NewDisplayName == "" </span><span class="cov0" title="0">{
                                args.NewDisplayName = nil
                        }</span>
                }

                <span class="cov8" title="1">acc := dbGetAccount(ctx, args.Account)
                panic.IfTrueWith(acc == nil, noSuchAccountErr)

                if !ctx.Me().Equal(args.Account) </span><span class="cov0" title="0">{
                        panic.IfTrueWith(acc.IsPersonal, err.InsufficientPermission) // can't rename someone else's personal account

                        isAccountOwner, e := ctx.RegionalV1PrivateClient().MemberIsAccountOwner(acc.Region, acc.Shard, args.Account, ctx.Me())
                        panic.If(e)
                        panic.IfTrueWith(!isAccountOwner, err.InsufficientPermission)
                }</span>

                <span class="cov8" title="1">if (acc.DisplayName == nil &amp;&amp; args.NewDisplayName == nil) || (acc.DisplayName != nil &amp;&amp; args.NewDisplayName != nil &amp;&amp; *acc.DisplayName == *args.NewDisplayName) </span><span class="cov0" title="0">{
                        return nil //if there is no change, dont do any redundant work
                }</span>

                <span class="cov8" title="1">acc.DisplayName = args.NewDisplayName
                dbUpdateAccount(ctx, acc)

                if ctx.Me().Equal(args.Account) </span><span class="cov8" title="1">{ // if i did set my personal account displayName, i need to update all the stored displayNames in all the accounts Im a member of
                        ctx.RegionalV1PrivateClient().SetMemberDisplayName(acc.Region, acc.Shard, acc.Id, ctx.Me(), args.NewDisplayName) //first set my display name in my personal org
                        var after *id.Id
                        for </span><span class="cov8" title="1">{
                                accs, more := dbGetGroupAccounts(ctx, ctx.Me(), after, 100)
                                for _, acc := range accs </span><span class="cov0" title="0">{
                                        ctx.RegionalV1PrivateClient().SetMemberDisplayName(acc.Region, acc.Shard, acc.Id, ctx.Me(), args.NewDisplayName)
                                }</span>
                                <span class="cov8" title="1">if more </span><span class="cov0" title="0">{
                                        after = &amp;accs[len(accs)-1].Id
                                }</span><span class="cov8" title="1"> else {
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">return nil</span>
        },
}

type setAccountAvatarArgs struct {
        Account id.Id         `json:"account"`
        Avatar  io.ReadCloser `json:"avatar"`
}

var setAccountAvatar = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/centralAccount/setAccountAvatar",
        RequiresSession: true,
        FormStruct: map[string]string{
                "account": "Id",
                "avatar":  "file (png, jpeg, gif)",
        },
        ProcessForm: func(w http.ResponseWriter, r *http.Request) interface{} <span class="cov8" title="1">{
                r.Body = http.MaxBytesReader(w, r.Body, 600000) //limit to 6kb
                f, _, err := r.FormFile("avatar")
                if err != nil </span><span class="cov0" title="0">{
                        f = nil
                }</span>
                <span class="cov8" title="1">return &amp;setAccountAvatarArgs{
                        Account: id.Parse(r.FormValue("account")),
                        Avatar:  f,
                }</span>
        },
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setAccountAvatarArgs)
                if args.Avatar != nil </span><span class="cov8" title="1">{
                        defer args.Avatar.Close()
                }</span>

                <span class="cov8" title="1">account := dbGetAccount(ctx, args.Account)
                panic.IfTrueWith(account == nil, noSuchAccountErr)

                if !ctx.Me().Equal(args.Account) </span><span class="cov0" title="0">{
                        panic.IfTrueWith(account.IsPersonal, err.InsufficientPermission) // can't set avatar on someone else's personal account

                        isAccountOwner, e := ctx.RegionalV1PrivateClient().MemberIsAccountOwner(account.Region, account.Shard, args.Account, ctx.Me())
                        panic.If(e)
                        panic.IfTrueWith(!isAccountOwner, err.InsufficientPermission)
                }</span>

                <span class="cov8" title="1">hasAvatarStatusChanged := false
                if args.Avatar != nil </span><span class="cov8" title="1">{
                        avatarImage, _, e := image.Decode(args.Avatar)
                        panic.If(e)
                        bounds := avatarImage.Bounds()
                        panic.IfTrueWith(bounds.Max.X-bounds.Min.X != bounds.Max.Y-bounds.Min.Y, invalidAvatarShapeErr) //if it  isn't square, then error
                        if uint(bounds.Max.X-bounds.Min.X) &gt; ctx.AvatarClient().MaxAvatarDim() </span><span class="cov8" title="1">{                        // if it is larger than allowed then resize
                                avatarImage = resize.Resize(ctx.AvatarClient().MaxAvatarDim(), ctx.AvatarClient().MaxAvatarDim(), avatarImage, resize.NearestNeighbor)
                        }</span>
                        <span class="cov8" title="1">buff := &amp;bytes.Buffer{}
                        panic.If(png.Encode(buff, avatarImage))
                        data := buff.Bytes()
                        reader := bytes.NewReader(data)
                        ctx.AvatarClient().Save(ctx.Me().String(), "image/png", reader)
                        hasAvatarStatusChanged = !account.HasAvatar</span>
                }<span class="cov0" title="0"> else {
                        ctx.AvatarClient().Delete(ctx.Me().String())
                        hasAvatarStatusChanged = account.HasAvatar
                }</span>
                <span class="cov8" title="1">if hasAvatarStatusChanged </span><span class="cov8" title="1">{
                        account.HasAvatar = !account.HasAvatar
                        dbUpdateAccount(ctx, account)
                        ctx.RegionalV1PrivateClient().SetMemberHasAvatar(account.Region, account.Shard, account.Id, ctx.Me(), account.HasAvatar) //first set hasAvatar in my personal org
                        var after *id.Id
                        for </span><span class="cov8" title="1">{
                                accs, more := dbGetGroupAccounts(ctx, ctx.Me(), after, 100)
                                for _, acc := range accs </span><span class="cov0" title="0">{
                                        ctx.RegionalV1PrivateClient().SetMemberHasAvatar(acc.Region, acc.Shard, acc.Id, ctx.Me(), account.HasAvatar)
                                }</span>
                                <span class="cov8" title="1">if more </span><span class="cov0" title="0">{
                                        after = &amp;accs[len(accs)-1].Id
                                }</span><span class="cov8" title="1"> else {
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">return nil</span>
        },
}

type migrateAccountArgs struct {
        Account   id.Id  `json:"account"`
        NewRegion string `json:"newRegion"`
}

var migrateAccount = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/centralAccount/migrateAccount",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;migrateAccountArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, _ interface{}) interface{} <span class="cov0" title="0">{
                panic.If(err.NotImplemented)
                return nil
        }</span>,
}

type createAccountArgs struct {
        Name        string  `json:"name"`
        Region      string  `json:"region"`
        DisplayName *string `json:"displayName"`
}

var createAccount = &amp;endpoint.Endpoint{
        Method:                   http.MethodPost,
        Path:                     "/api/v1/centralAccount/createAccount",
        RequiresSession:          true,
        ExampleResponseStructure: &amp;Account{},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;createAccountArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*createAccountArgs)
                args.Name = strings.Trim(args.Name, " ")
                validate.StringArg("name", args.Name, ctx.NameMinRuneCount(), ctx.NameMaxRuneCount(), ctx.NameRegexMatchers())

                panic.IfTrueWith(!ctx.RegionalV1PrivateClient().IsValidRegion(args.Region), err.NoSuchRegion)
                panic.IfTrueWith(dbAccountWithCiNameExists(ctx, args.Name), nameAlreadyInUseErr)

                account := &amp;Account{}
                account.Id = id.New()
                account.Name = args.Name
                account.DisplayName = args.DisplayName
                account.CreatedOn = t.Now()
                account.Region = args.Region
                account.Shard = -1
                account.IsPersonal = false
                dbCreateGroupAccountAndMembership(ctx, account, ctx.Me())

                owner := dbGetPersonalAccountById(ctx, ctx.Me())
                panic.IfTrueWith(owner == nil, noSuchAccountErr)

                defer func() </span><span class="cov8" title="1">{
                        r := recover()
                        if r != nil </span><span class="cov0" title="0">{
                                dbDeleteAccountAndAllAssociatedMemberships(ctx, account.Id)
                                panic.If(r)
                        }</span>
                }()
                <span class="cov8" title="1">shard, e := ctx.RegionalV1PrivateClient().CreateAccount(args.Region, account.Id, ctx.Me(), owner.Name, owner.DisplayName, owner.HasAvatar)
                panic.If(e)

                account.Shard = shard
                dbUpdateAccount(ctx, account)
                return account</span>
        },
}

type getMyAccountsArgs struct {
        After *id.Id `json:"after"`
        Limit int    `json:"limit"`
}

type GetMyAccountsResult struct {
        Accounts []*Account `json:"accounts"`
        More     bool       `json:"more"`
}

var getMyAccounts = &amp;endpoint.Endpoint{
        Method:                   http.MethodGet,
        Path:                     "/api/v1/centralAccount/getMyAccounts",
        RequiresSession:          true,
        ExampleResponseStructure: &amp;GetMyAccountsResult{Accounts: []*Account{{}}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getMyAccountsArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getMyAccountsArgs)
                res := &amp;GetMyAccountsResult{}
                res.Accounts, res.More = dbGetGroupAccounts(ctx, ctx.Me(), args.After, validate.Limit(args.Limit, ctx.MaxProcessEntityCount()))
                return res
        }</span>,
}

type deleteAccountArgs struct {
        Account id.Id `json:"account"`
}

var deleteAccount = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/centralAccount/deleteAccount",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;deleteAccountArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*deleteAccountArgs)
                acc := dbGetAccount(ctx, args.Account)
                panic.IfTrueWith(acc == nil, noSuchAccountErr)

                if !ctx.Me().Equal(args.Account) </span><span class="cov8" title="1">{
                        panic.IfTrueWith(acc.IsPersonal, err.InsufficientPermission) // can't delete someone else's personal account

                        //otherwise attempting to delete a group account
                        isAccountOwner, e := ctx.RegionalV1PrivateClient().MemberIsAccountOwner(acc.Region, acc.Shard, args.Account, ctx.Me())
                        panic.If(e)
                        panic.IfTrueWith(!isAccountOwner, err.InsufficientPermission)
                }</span>

                <span class="cov8" title="1">ctx.RegionalV1PrivateClient().DeleteAccount(acc.Region, acc.Shard, args.Account, ctx.Me())
                dbDeleteAccountAndAllAssociatedMemberships(ctx, args.Account)

                if ctx.Me().Equal(args.Account) </span><span class="cov8" title="1">{
                        var after *id.Id
                        for </span><span class="cov8" title="1">{
                                accs, more := dbGetGroupAccounts(ctx, ctx.Me(), after, 100)
                                for _, acc := range accs </span><span class="cov0" title="0">{
                                        isAccountOwner, e := ctx.RegionalV1PrivateClient().MemberIsAccountOwner(acc.Region, acc.Shard, acc.Id, ctx.Me())
                                        panic.If(e)
                                        panic.IfTrueWith(isAccountOwner, onlyOwnerMemberErr)
                                }</span>
                                <span class="cov8" title="1">for _, acc := range accs </span><span class="cov0" title="0">{
                                        ctx.RegionalV1PrivateClient().RemoveMembers(acc.Region, acc.Shard, acc.Id, ctx.Me(), []id.Id{ctx.Me()})
                                }</span>
                                <span class="cov8" title="1">if more </span><span class="cov0" title="0">{
                                        after = &amp;accs[len(accs)-1].Id
                                }</span><span class="cov8" title="1"> else {
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">return nil</span>
        },
}

type addMembersArgs struct {
        Account    id.Id        `json:"account"`
        NewMembers []*AddMember `json:"newMembers"`
}

var addMembers = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/centralAccount/addMembers",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;addMembersArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*addMembersArgs)
                panic.IfTrueWith(args.Account.Equal(ctx.Me()), err.InvalidOperation)
                validate.EntityCount(len(args.NewMembers), ctx.MaxProcessEntityCount())

                account := dbGetAccount(ctx, args.Account)
                panic.IfTrueWith(account == nil, noSuchAccountErr)

                ids := make([]id.Id, 0, len(args.NewMembers))
                addMembersMap := map[string]*AddMember{}
                for _, member := range args.NewMembers </span><span class="cov8" title="1">{
                        ids = append(ids, member.Id)
                        addMembersMap[member.Id.String()] = member
                }</span>

                <span class="cov8" title="1">accs := dbGetPersonalAccounts(ctx, ids)

                members := make([]*private.AddMember, 0, len(accs))
                for _, acc := range accs </span><span class="cov8" title="1">{
                        role := addMembersMap[acc.Id.String()].Role
                        role.Validate()
                        ami := &amp;private.AddMember{}
                        ami.Id = acc.Id
                        ami.Role = role
                        ami.Name = acc.Name
                        ami.DisplayName = acc.DisplayName
                        ami.HasAvatar = acc.HasAvatar
                        members = append(members, ami)
                }</span>

                <span class="cov8" title="1">ctx.RegionalV1PrivateClient().AddMembers(account.Region, account.Shard, args.Account, ctx.Me(), members)
                dbCreateMemberships(ctx, args.Account, ids)
                return nil</span>
        },
}

type removeMembersArgs struct {
        Account         id.Id   `json:"account"`
        ExistingMembers []id.Id `json:"existingMembers"`
}

var removeMembers = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/centralAccount/removeMembers",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;removeMembersArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov0" title="0">{
                args := a.(*removeMembersArgs)
                panic.IfTrueWith(args.Account.Equal(ctx.Me()), err.InvalidOperation)
                validate.EntityCount(len(args.ExistingMembers), ctx.MaxProcessEntityCount())

                account := dbGetAccount(ctx, args.Account)
                panic.IfTrueWith(account == nil, noSuchAccountErr)

                ctx.RegionalV1PrivateClient().RemoveMembers(account.Region, account.Shard, args.Account, ctx.Me(), args.ExistingMembers)
                dbDeleteMemberships(ctx, args.Account, args.ExistingMembers)
                return nil
        }</span>,
}

var Endpoints = []*endpoint.Endpoint{
        getRegions,
        register,
        resendActivationEmail,
        activate,
        authenticate,
        confirmNewEmail,
        resetPwd,
        setNewPwdFromPwdReset,
        getAccount,
        getAccounts,
        searchAccounts,
        searchPersonalAccounts,
        getMe,
        setMyPwd,
        setMyEmail,
        resendMyNewEmailConfirmationEmail,
        setAccountName,
        setAccountDisplayName,
        setAccountAvatar,
        migrateAccount,
        createAccount,
        getMyAccounts,
        deleteAccount,
        addMembers,
        removeMembers,
}

//structs
type Account struct {
        Id          id.Id     `json:"id"`
        Name        string    `json:"name"`
        DisplayName *string   `json:"displayName"`
        CreatedOn   time.Time `json:"createdOn"`
        Region      string    `json:"region"`
        NewRegion   *string   `json:"newRegion,omitempty"`
        Shard       int       `json:"shard"`
        HasAvatar   bool      `json:"hasAvatar"`
        IsPersonal  bool      `json:"isPersonal"`
}

func (a *Account) isMigrating() bool <span class="cov0" title="0">{
        return a.NewRegion != nil
}</span>

type Me struct {
        Account
        Email    string     `json:"email"`
        Language string     `json:"language"`
        Theme    cnst.Theme `json:"theme"`
        NewEmail *string    `json:"newEmail,omitempty"`
}

type fullPersonalAccountInfo struct {
        Me
        activationCode           *string
        activatedOn              *time.Time
        newEmailConfirmationCode *string
        resetPwdCode             *string
}

func (a *fullPersonalAccountInfo) isActivated() bool <span class="cov8" title="1">{
        return a.activatedOn != nil
}</span>

type pwdInfo struct {
        salt   []byte
        pwd    []byte
        n      int
        r      int
        p      int
        keyLen int
}

func pwdsMatch(a, b []byte) bool <span class="cov8" title="1">{
        return bytes.Compare(a, b) == 0
}</span>

type AddMember struct {
        Id   id.Id            `json:"id"`
        Role cnst.AccountRole `json:"role"`
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package private

import (
        "bitbucket.org/0xor1/task/server/util/err"
        "bitbucket.org/0xor1/task/server/util/id"
        "bitbucket.org/0xor1/task/server/util/private"
        "github.com/0xor1/panic"
        "strings"
)

func NewClient(regions map[string]string) private.V1Client <span class="cov8" title="1">{
        lowerRegionsMap := map[string]string{}
        for k, v := range regions </span><span class="cov8" title="1">{
                lowerRegionsMap[strings.ToLower(k)] = v
        }</span>
        <span class="cov8" title="1">return &amp;client{
                regions: lowerRegionsMap,
        }</span>
}

type client struct {
        regions map[string]string
}

func (c *client) getHost(region string) string <span class="cov8" title="1">{
        host, exists := c.regions[strings.ToLower(region)]
        panic.IfTrueWith(!exists, err.NoSuchRegion)
        return host
}</span>

func (c *client) GetRegions() []string <span class="cov0" title="0">{
        regions := make([]string, 0, len(c.regions))
        for r := range c.regions </span><span class="cov0" title="0">{
                regions = append(regions, r)
        }</span>
        <span class="cov0" title="0">return regions</span>
}

func (c *client) IsValidRegion(region string) bool <span class="cov0" title="0">{
        _, exists := c.regions[strings.ToLower(region)]
        return exists
}</span>

func (c *client) CreateAccount(region string, account, me id.Id, myName string, myDisplayName *string, hasAvatar bool) (int, error) <span class="cov8" title="1">{
        respVal := 0
        val, e := createAccount.DoRequest(nil, c.getHost(region), &amp;createAccountArgs{
                Account:       account,
                Me:            me,
                MyName:        myName,
                MyDisplayName: myDisplayName,
                HasAvatar:     hasAvatar,
        }, nil, &amp;respVal)
        if val != nil </span><span class="cov8" title="1">{
                return *val.(*int), e
        }</span>
        <span class="cov0" title="0">return 0, e</span>
}

func (c *client) DeleteAccount(region string, shard int, account, me id.Id) error <span class="cov8" title="1">{
        _, e := deleteAccount.DoRequest(nil, c.getHost(region), &amp;deleteAccountArgs{
                Shard:   shard,
                Account: account,
                Me:      me,
        }, nil, nil)
        return e
}</span>

func (c *client) AddMembers(region string, shard int, account, me id.Id, members []*private.AddMember) error <span class="cov8" title="1">{
        _, e := addMembers.DoRequest(nil, c.getHost(region), &amp;addMembersArgs{
                Shard:   shard,
                Account: account,
                Me:      me,
                Members: members,
        }, nil, nil)
        return e
}</span>

func (c *client) RemoveMembers(region string, shard int, account, me id.Id, members []id.Id) error <span class="cov8" title="1">{
        _, err := removeMembers.DoRequest(nil, c.getHost(region), &amp;removeMembersArgs{
                Shard:   shard,
                Account: account,
                Me:      me,
                Members: members,
        }, nil, nil)
        return err
}</span>

func (c *client) MemberIsOnlyAccountOwner(region string, shard int, account, me id.Id) (bool, error) <span class="cov8" title="1">{
        respVal := false
        val, e := memberIsOnlyAccountOwner.DoRequest(nil, c.getHost(region), &amp;memberIsOnlyAccountOwnerArgs{
                Shard:   shard,
                Account: account,
                Me:      me,
        }, nil, &amp;respVal)
        if val != nil </span><span class="cov8" title="1">{
                return *val.(*bool), e
        }</span>
        <span class="cov0" title="0">return false, e</span>
}

func (c *client) SetMemberName(region string, shard int, account, me id.Id, newName string) error <span class="cov8" title="1">{
        _, e := setMemberName.DoRequest(nil, c.getHost(region), &amp;setMemberNameArgs{
                Shard:   shard,
                Account: account,
                Me:      me,
                NewName: newName,
        }, nil, nil)
        return e
}</span>

func (c *client) SetMemberDisplayName(region string, shard int, account, me id.Id, newDisplayName *string) error <span class="cov0" title="0">{
        _, e := setMemberDisplayName.DoRequest(nil, c.getHost(region), &amp;setMemberDisplayNameArgs{
                Shard:          shard,
                Account:        account,
                Me:             me,
                NewDisplayName: newDisplayName,
        }, nil, nil)
        return e
}</span>

func (c *client) SetMemberHasAvatar(region string, shard int, account, me id.Id, hasAvatar bool) error <span class="cov8" title="1">{
        _, e := setMemberHasAvatar.DoRequest(nil, c.getHost(region), &amp;setMemberHasAvatarArgs{
                Shard:     shard,
                Account:   account,
                Me:        me,
                HasAvatar: hasAvatar,
        }, nil, nil)
        return e
}</span>

func (c *client) MemberIsAccountOwner(region string, shard int, account, me id.Id) (bool, error) <span class="cov8" title="1">{
        respVal := false
        val, e := memberIsAccountOwner.DoRequest(nil, c.getHost(region), &amp;memberIsAccountOwnerArgs{
                Shard:   shard,
                Account: account,
                Me:      me,
        }, nil, &amp;respVal)
        if val != nil </span><span class="cov8" title="1">{
                return *val.(*bool), e
        }</span>
        <span class="cov0" title="0">return false, e</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package private

import (
        "bitbucket.org/0xor1/task/server/util/cachekey"
        "bitbucket.org/0xor1/task/server/util/ctx"
        "bitbucket.org/0xor1/task/server/util/err"
        "bitbucket.org/0xor1/task/server/util/id"
        "bitbucket.org/0xor1/task/server/util/private"
        "bitbucket.org/0xor1/task/server/util/time"
        "bytes"
        "github.com/0xor1/panic"
        "math/rand"
)

func dbCreateAccount(ctx ctx.Ctx, account, me id.Id, myName string, myDisplayName *string, hasAvatar bool) int <span class="cov8" title="1">{
        shard := rand.Intn(ctx.TreeShardCount())
        _, e := ctx.TreeExec(shard, `CALL registerAccount(?, ?, ?, ?, ?)`, account, me, myName, myDisplayName, hasAvatar)
        panic.If(e)
        return shard
}</span>

func dbDeleteAccount(ctx ctx.Ctx, shard int, account id.Id) <span class="cov8" title="1">{
        _, e := ctx.TreeExec(shard, `CALL deleteAccount(?)`, account)
        panic.If(e)
        ctx.TouchDlms(cachekey.NewSetDlms().AccountMaster(account))
}</span>

func dbGetAllInactiveMembersFromInputSet(ctx ctx.Ctx, shard int, account id.Id, members []id.Id) []id.Id <span class="cov8" title="1">{
        res := make([]id.Id, 0, len(members))
        cacheKey := cachekey.NewGet("private.dbGetAllInactiveMembersFromInputSet", shard, account, members).AccountMembers(account, members)
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return res
        }</span>
        <span class="cov8" title="1">queryArgs := make([]interface{}, 0, len(members)+1)
        queryArgs = append(queryArgs, account, members[0])
        query := bytes.NewBufferString(`SELECT id FROM accountMembers WHERE account=? AND isActive=false AND id IN (?`)
        for _, mem := range members[1:] </span><span class="cov8" title="1">{
                query.WriteString(`,?`)
                queryArgs = append(queryArgs, mem)
        }</span>
        <span class="cov8" title="1">query.WriteString(`)`)
        rows, e := ctx.TreeQuery(shard, query.String(), queryArgs...)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.If(e)
        for rows.Next() </span><span class="cov0" title="0">{
                i := make([]byte, 0, 16)
                rows.Scan(&amp;i)
                res = append(res, id.Id(i))
        }</span>
        <span class="cov8" title="1">ctx.SetCacheValue(res, cacheKey)
        return res</span>
}

func dbAddMembers(ctx ctx.Ctx, shard int, account id.Id, members []*private.AddMember) <span class="cov8" title="1">{
        queryArgs := make([]interface{}, 0, 3*len(members))
        queryArgs = append(queryArgs, account, members[0].Id, members[0].Name, members[0].DisplayName, members[0].HasAvatar, members[0].Role)
        query := bytes.NewBufferString(`INSERT INTO accountMembers (account, id, name, displayName, hasAvatar, role) VALUES (?,?,?,?,?,?)`)
        for _, mem := range members[1:] </span><span class="cov8" title="1">{
                query.WriteString(`,(?,?,?,?,?,?)`)
                queryArgs = append(queryArgs, account, mem.Id, mem.Name, mem.DisplayName, mem.HasAvatar, mem.Role)
        }</span>
        <span class="cov8" title="1">_, e := ctx.TreeExec(shard, query.String(), queryArgs...)
        panic.If(e)
        ctx.TouchDlms(cachekey.NewSetDlms().AccountMembersSet(account))</span>
}

func dbUpdateMembersAndSetActive(ctx ctx.Ctx, shard int, account id.Id, members []*private.AddMember) <span class="cov0" title="0">{
        memberIds := make([]id.Id, 0, len(members))
        for _, mem := range members </span><span class="cov0" title="0">{
                memberIds = append(memberIds, mem.Id)
                _, e := ctx.TreeExec(shard, `CALL updateMembersAndSetActive(?, ?, ?, ?, ?, ?)`, account, mem.Id, mem.Name, mem.DisplayName, mem.HasAvatar, mem.Role)
                panic.If(e)
        }</span>
        <span class="cov0" title="0">ctx.TouchDlms(cachekey.NewSetDlms().AccountMembers(account, memberIds))</span>
}

func dbGetTotalOwnerCount(ctx ctx.Ctx, shard int, account id.Id) int <span class="cov8" title="1">{
        count := 0
        cacheKey := cachekey.NewGet("private.dbGetTotalOwnerCount", shard, account).AccountMembersSet(account)
        if ctx.GetCacheValue(&amp;count, cacheKey) </span><span class="cov0" title="0">{
                return count
        }</span>
        <span class="cov8" title="1">err.IsSqlErrNoRowsElsePanicIf(ctx.TreeQueryRow(shard, `SELECT COUNT(*) FROM accountMembers WHERE account=? AND isActive=true AND role=0`, account).Scan(&amp;count))
        ctx.SetCacheValue(count, cacheKey)
        return count</span>
}

func dbGetOwnerCountInSet(ctx ctx.Ctx, shard int, account id.Id, members []id.Id) int <span class="cov8" title="1">{
        count := 0
        cacheKey := cachekey.NewGet("private.dbGetOwnerCountInSet", shard, account, members).AccountMembers(account, members)
        if ctx.GetCacheValue(&amp;count, cacheKey) </span><span class="cov0" title="0">{
                return count
        }</span>
        <span class="cov8" title="1">queryArgs := make([]interface{}, 0, len(members)+1)
        queryArgs = append(queryArgs, account, members[0])
        query := bytes.NewBufferString(`SELECT COUNT(*) FROM accountMembers WHERE account=? AND isActive=true AND role=0 AND id IN (?`)
        for _, mem := range members[1:] </span><span class="cov0" title="0">{
                query.WriteString(`,?`)
                queryArgs = append(queryArgs, mem)
        }</span>
        <span class="cov8" title="1">query.WriteString(`)`)
        err.IsSqlErrNoRowsElsePanicIf(ctx.TreeQueryRow(shard, query.String(), queryArgs...).Scan(&amp;count))
        ctx.SetCacheValue(count, cacheKey)
        return count</span>
}

func dbSetMembersInactive(ctx ctx.Ctx, shard int, account id.Id, members []id.Id) <span class="cov8" title="1">{
        cacheKey := cachekey.NewSetDlms().AccountMembers(account, members)
        for _, mem := range members </span><span class="cov8" title="1">{
                rows, e := ctx.TreeQuery(shard, `CALL setAccountMemberInactive(?, ?)`, account, mem)
                panic.If(e)
                for rows.Next() </span><span class="cov0" title="0">{
                        var project id.Id
                        var task id.Id
                        panic.If(rows.Scan(&amp;project, task))
                        cacheKey.Task(account, project, task).ProjectMembersSet(account, project).ProjectMember(account, project, mem)
                }</span>
        }
        <span class="cov8" title="1">ctx.TouchDlms(cacheKey)</span>
}

func dbSetMemberName(ctx ctx.Ctx, shard int, account id.Id, member id.Id, newName string) <span class="cov8" title="1">{
        _, e := ctx.TreeExec(shard, `CALL setMemberName(?, ?, ?)`, account, member, newName)
        panic.If(e)
        ctx.TouchDlms(cachekey.NewSetDlms().AccountMember(account, member))
}</span>

func dbSetMemberDisplayName(ctx ctx.Ctx, shard int, account, member id.Id, newDisplayName *string) <span class="cov0" title="0">{
        _, e := ctx.TreeExec(shard, `CALL setMemberDisplayName(?, ?, ?)`, account, member, newDisplayName)
        panic.If(e)
        ctx.TouchDlms(cachekey.NewSetDlms().AccountMember(account, member))
}</span>

func dbSetMemberHasAvatar(ctx ctx.Ctx, shard int, account, member id.Id, hasAvatar bool) <span class="cov8" title="1">{
        _, e := ctx.TreeExec(shard, `UPDATE accountMembers SET hasAvatar=? WHERE account=? AND id=?`, hasAvatar, account, member)
        panic.If(e)
        ctx.TouchDlms(cachekey.NewSetDlms().AccountMember(account, member))
}</span>

func dbLogAccountBatchAddOrRemoveMembersActivity(ctx ctx.Ctx, shard int, account, member id.Id, members []id.Id, action string) <span class="cov8" title="1">{
        query := bytes.NewBufferString(`INSERT INTO accountActivities (account, occurredOn, member, item, itemType, action, itemName, extraInfo) VALUES (?,?,?,?,?,?,?,?)`)
        args := make([]interface{}, 0, len(members)*8)
        now := time.Now()
        args = append(args, account, now, member, members[0], "member", action, nil, nil)
        for _, mem := range members[1:] </span><span class="cov8" title="1">{
                query.WriteString(`,(?,?,?,?,?,?,?,?)`)
                args = append(args, account, now, member, mem, "member", action, nil, nil)
        }</span>
        <span class="cov8" title="1">_, e := ctx.TreeExec(shard, query.String(), args...)
        panic.If(e)
        ctx.TouchDlms(cachekey.NewSetDlms().AccountActivities(account))</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package private

import (
        "bitbucket.org/0xor1/task/server/util/cnst"
        "bitbucket.org/0xor1/task/server/util/ctx"
        "bitbucket.org/0xor1/task/server/util/db"
        "bitbucket.org/0xor1/task/server/util/endpoint"
        "bitbucket.org/0xor1/task/server/util/err"
        "bitbucket.org/0xor1/task/server/util/id"
        "bitbucket.org/0xor1/task/server/util/private"
        "bitbucket.org/0xor1/task/server/util/validate"
        "github.com/0xor1/panic"
        "net/http"
)

var (
        zeroOwnerCountErr = &amp;err.Err{Code: "r_v1_pr_zoc", Message: "zero owner count"}
)

type createAccountArgs struct {
        Account       id.Id   `json:"account"`
        Me            id.Id   `json:"me"`
        MyName        string  `json:"myName"`
        MyDisplayName *string `json:"myDisplayName"`
        HasAvatar     bool    `json:"hasAvatar"`
}

var createAccount = &amp;endpoint.Endpoint{
        Method:    http.MethodPost,
        Path:      "/api/v1/private/createAccount",
        IsPrivate: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;createAccountArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*createAccountArgs)
                return dbCreateAccount(ctx, args.Account, args.Me, args.MyName, args.MyDisplayName, args.HasAvatar)
        }</span>,
}

type deleteAccountArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
        Me      id.Id `json:"me"`
}

var deleteAccount = &amp;endpoint.Endpoint{
        Method:    http.MethodPost,
        Path:      "/api/v1/private/deleteAccount",
        IsPrivate: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;deleteAccountArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*deleteAccountArgs)
                if !args.Me.Equal(args.Account) </span><span class="cov8" title="1">{
                        validate.MemberHasAccountOwnerAccess(db.GetAccountRole(ctx, args.Shard, args.Account, args.Me))
                }</span>
                <span class="cov8" title="1">dbDeleteAccount(ctx, args.Shard, args.Account)
                //TODO delete s3 data, uploaded files etc
                return nil</span>
        },
}

type addMembersArgs struct {
        Shard   int                  `json:"shard"`
        Account id.Id                `json:"account"`
        Me      id.Id                `json:"me"`
        Members []*private.AddMember `json:"members"`
}

var addMembers = &amp;endpoint.Endpoint{
        Method:    http.MethodPost,
        Path:      "/api/v1/private/addMembers",
        IsPrivate: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;addMembersArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*addMembersArgs)
                validate.EntityCount(len(args.Members), ctx.MaxProcessEntityCount())
                panic.IfTrueWith(args.Account.Equal(args.Me), err.InvalidOperation)
                accountRole := db.GetAccountRole(ctx, args.Shard, args.Account, args.Me)
                validate.MemberHasAccountAdminAccess(accountRole)

                allIds := make([]id.Id, 0, len(args.Members))
                newMembersMap := map[string]*private.AddMember{}
                for _, mem := range args.Members </span><span class="cov8" title="1">{ //loop over all the new entries and check permissions and build up useful id map and allIds slice
                        mem.Role.Validate()
                        if mem.Role == cnst.AccountOwner </span><span class="cov0" title="0">{
                                validate.MemberHasAccountOwnerAccess(accountRole)
                        }</span>
                        <span class="cov8" title="1">newMembersMap[mem.Id.String()] = mem
                        allIds = append(allIds, mem.Id)</span>
                }

                <span class="cov8" title="1">inactiveMemberIds := dbGetAllInactiveMembersFromInputSet(ctx, args.Shard, args.Account, allIds)
                inactiveMembers := make([]*private.AddMember, 0, len(inactiveMemberIds))
                for _, inactiveMember := range inactiveMemberIds </span><span class="cov0" title="0">{
                        idStr := inactiveMember.String()
                        inactiveMembers = append(inactiveMembers, newMembersMap[idStr])
                        delete(newMembersMap, idStr)
                }</span>

                <span class="cov8" title="1">newMembers := make([]*private.AddMember, 0, len(newMembersMap))
                for _, newMem := range newMembersMap </span><span class="cov8" title="1">{
                        newMembers = append(newMembers, newMem)
                }</span>

                <span class="cov8" title="1">if len(newMembers) &gt; 0 </span><span class="cov8" title="1">{
                        dbAddMembers(ctx, args.Shard, args.Account, newMembers)
                }</span>
                <span class="cov8" title="1">if len(inactiveMembers) &gt; 0 </span><span class="cov0" title="0">{
                        dbUpdateMembersAndSetActive(ctx, args.Shard, args.Account, inactiveMembers) //has to be private.AddMember in case the member changed their name whilst they were inactive on the account
                }</span>
                <span class="cov8" title="1">dbLogAccountBatchAddOrRemoveMembersActivity(ctx, args.Shard, args.Account, args.Me, allIds, "added")
                return nil</span>
        },
}

type removeMembersArgs struct {
        Shard   int     `json:"shard"`
        Account id.Id   `json:"account"`
        Me      id.Id   `json:"me"`
        Members []id.Id `json:"members"`
}

var removeMembers = &amp;endpoint.Endpoint{
        Method:    http.MethodPost,
        Path:      "/api/v1/private/removeMembers",
        IsPrivate: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;removeMembersArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*removeMembersArgs)
                validate.EntityCount(len(args.Members), ctx.MaxProcessEntityCount())
                panic.IfTrueWith(args.Account.Equal(args.Me), err.InvalidOperation)

                accountRole := db.GetAccountRole(ctx, args.Shard, args.Account, args.Me)
                panic.IfTrueWith(accountRole == nil, err.InsufficientPermission)

                switch *accountRole </span>{
                case cnst.AccountOwner:<span class="cov8" title="1">
                        totalOwnerCount := dbGetTotalOwnerCount(ctx, args.Shard, args.Account)
                        ownerCountInRemoveSet := dbGetOwnerCountInSet(ctx, args.Shard, args.Account, args.Members)
                        panic.IfTrueWith(totalOwnerCount == ownerCountInRemoveSet, zeroOwnerCountErr)</span>
                case cnst.AccountAdmin:<span class="cov0" title="0">
                        ownerCountInRemoveSet := dbGetOwnerCountInSet(ctx, args.Shard, args.Account, args.Members)
                        panic.IfTrueWith(ownerCountInRemoveSet &gt; 0, err.InsufficientPermission)</span>
                default:<span class="cov0" title="0">
                        panic.IfTrueWith(len(args.Members) != 1 || !args.Members[0].Equal(args.Me), err.InsufficientPermission)</span>
                }

                <span class="cov8" title="1">dbSetMembersInactive(ctx, args.Shard, args.Account, args.Members)
                dbLogAccountBatchAddOrRemoveMembersActivity(ctx, args.Shard, args.Account, args.Me, args.Members, "removed")
                return nil</span>
        },
}

type memberIsOnlyAccountOwnerArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
        Me      id.Id `json:"me"`
}

var memberIsOnlyAccountOwner = &amp;endpoint.Endpoint{
        Method:    http.MethodGet,
        Path:      "/api/v1/private/memberIsOnlyAccountOwner",
        IsPrivate: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;memberIsOnlyAccountOwnerArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*memberIsOnlyAccountOwnerArgs)
                if args.Account.Equal(args.Me) </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov8" title="1">totalOwnerCount := dbGetTotalOwnerCount(ctx, args.Shard, args.Account)
                ownerCount := dbGetOwnerCountInSet(ctx, args.Shard, args.Account, []id.Id{args.Me})
                return totalOwnerCount == 1 &amp;&amp; ownerCount == 1</span>
        },
}

type setMemberNameArgs struct {
        Shard   int    `json:"shard"`
        Account id.Id  `json:"account"`
        Me      id.Id  `json:"me"`
        NewName string `json:"newName"`
}

var setMemberName = &amp;endpoint.Endpoint{
        Method:    http.MethodPost,
        Path:      "/api/v1/private/setMemberName",
        IsPrivate: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setMemberNameArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setMemberNameArgs)
                dbSetMemberName(ctx, args.Shard, args.Account, args.Me, args.NewName)
                return nil
        }</span>,
}

type setMemberDisplayNameArgs struct {
        Shard          int     `json:"shard"`
        Account        id.Id   `json:"account"`
        Me             id.Id   `json:"me"`
        NewDisplayName *string `json:"newDisplayName"`
}

var setMemberDisplayName = &amp;endpoint.Endpoint{
        Method:    http.MethodPost,
        Path:      "/api/v1/private/setMemberDisplayName",
        IsPrivate: true,
        GetArgsStruct: func() interface{} <span class="cov0" title="0">{
                return &amp;setMemberDisplayNameArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov0" title="0">{
                args := a.(*setMemberDisplayNameArgs)
                dbSetMemberDisplayName(ctx, args.Shard, args.Account, args.Me, args.NewDisplayName)
                return nil
        }</span>,
}

type setMemberHasAvatarArgs struct {
        Shard     int   `json:"shard"`
        Account   id.Id `json:"account"`
        Me        id.Id `json:"me"`
        HasAvatar bool  `json:"hasAvatar"`
}

var setMemberHasAvatar = &amp;endpoint.Endpoint{
        Method:    http.MethodPost,
        Path:      "/api/v1/private/setMemberHasAvatar",
        IsPrivate: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setMemberHasAvatarArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setMemberHasAvatarArgs)
                dbSetMemberHasAvatar(ctx, args.Shard, args.Account, args.Me, args.HasAvatar)
                return nil
        }</span>,
}

type memberIsAccountOwnerArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
        Me      id.Id `json:"me"`
}

var memberIsAccountOwner = &amp;endpoint.Endpoint{
        Method:    http.MethodGet,
        Path:      "/api/v1/private/memberIsAccountOwner",
        IsPrivate: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;memberIsAccountOwnerArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*memberIsAccountOwnerArgs)
                if !args.Me.Equal(args.Account) </span><span class="cov8" title="1">{
                        accountRole := db.GetAccountRole(ctx, args.Shard, args.Account, args.Me)
                        if accountRole != nil &amp;&amp; *accountRole == cnst.AccountOwner </span><span class="cov8" title="1">{
                                return true
                        }</span><span class="cov0" title="0"> else {
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        },
}

var Endpoints = []*endpoint.Endpoint{
        createAccount,
        deleteAccount,
        addMembers,
        removeMembers,
        memberIsOnlyAccountOwner,
        setMemberName,
        setMemberDisplayName,
        setMemberHasAvatar,
        memberIsAccountOwner,
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package project

import (
        "bitbucket.org/0xor1/task/server/util/activity"
        "bitbucket.org/0xor1/task/server/util/clientsession"
        "bitbucket.org/0xor1/task/server/util/cnst"
        "bitbucket.org/0xor1/task/server/util/id"
        "time"
)

type Client interface {
        //must be account owner/admin
        Create(css *clientsession.Store, shard int, account id.Id, name string, description *string, startOn, dueOn *time.Time, isParallel, isPublic bool, members []*AddProjectMember) (*Project, error)
        //must be account owner/admin and account.publicProjectsEnabled must be true
        SetIsPublic(css *clientsession.Store, shard int, account, project id.Id, isPublic bool) error
        //must be account owner/admin
        SetIsArchived(css *clientsession.Store, shard int, account, project id.Id, isArchived bool) error
        //check project access permission per user
        Get(css *clientsession.Store, shard int, account, project id.Id) (*Project, error)
        //check project access permission per user
        GetSet(css *clientsession.Store, shard int, account id.Id, nameContains *string, createdOnAfter, createdOnBefore, startOnAfter, startOnBefore, dueOnAfter, dueOnBefore *time.Time, isArchived bool, sortBy cnst.SortBy, sortDir cnst.SortDir, after *id.Id, limit int) (*GetSetResult, error)
        //must be account owner/admin
        Delete(css *clientsession.Store, shard int, account, project id.Id) error
        //must be account owner/admin or project admin
        AddMembers(css *clientsession.Store, shard int, account, project id.Id, members []*AddProjectMember) error
        //must be account owner/admin or project admin
        SetMemberRole(css *clientsession.Store, shard int, account, project id.Id, member id.Id, role cnst.ProjectRole) error
        //must be account owner/admin or project admin
        RemoveMembers(css *clientsession.Store, shard int, account, project id.Id, members []id.Id) error
        //pointers are optional filters, anyone who can see a project can see all the member info for that project
        GetMembers(css *clientsession.Store, shard int, account, project id.Id, role *cnst.ProjectRole, nameOrDisplayNameContains *string, after *id.Id, limit int) (*GetMembersResult, error)
        //for anyone
        GetMe(css *clientsession.Store, shard int, account, project id.Id) (*member, error)
        //either one or both of OccurredAfter/Before must be nil
        GetActivities(css *clientsession.Store, shard int, account, project id.Id, item, member *id.Id, occurredAfter, occurredBefore *time.Time, limit int) ([]*activity.Activity, error)
}

func NewClient(host string) Client <span class="cov8" title="1">{
        return &amp;client{
                host: host,
        }
}</span>

type client struct {
        host string
}

func (c *client) Create(css *clientsession.Store, shard int, account id.Id, name string, description *string, startOn, dueOn *time.Time, isParallel, isPublic bool, members []*AddProjectMember) (*Project, error) <span class="cov8" title="1">{
        val, e := create.DoRequest(css, c.host, &amp;createArgs{
                Shard:       shard,
                Account:     account,
                Name:        name,
                Description: description,
                StartOn:     startOn,
                DueOn:       dueOn,
                IsParallel:  isParallel,
                IsPublic:    isPublic,
                Members:     members,
        }, nil, &amp;Project{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*Project), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) SetIsPublic(css *clientsession.Store, shard int, account, project id.Id, isPublic bool) error <span class="cov8" title="1">{
        _, e := setIsPublic.DoRequest(css, c.host, &amp;setIsPublicArgs{
                Shard:    shard,
                Account:  account,
                Project:  project,
                IsPublic: isPublic,
        }, nil, nil)
        return e
}</span>

func (c *client) SetIsArchived(css *clientsession.Store, shard int, account, project id.Id, isArchived bool) error <span class="cov8" title="1">{
        _, e := setIsArchived.DoRequest(css, c.host, &amp;setIsArchivedArgs{
                Shard:      shard,
                Account:    account,
                Project:    project,
                IsArchived: isArchived,
        }, nil, nil)
        return e
}</span>

func (c *client) Get(css *clientsession.Store, shard int, account, proj id.Id) (*Project, error) <span class="cov8" title="1">{
        val, e := get.DoRequest(css, c.host, &amp;getArgs{
                Shard:   shard,
                Account: account,
                Project: proj,
        }, nil, &amp;Project{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*Project), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) GetSet(css *clientsession.Store, shard int, account id.Id, nameContains *string, createdOnAfter, createdOnBefore, startOnAfter, startOnBefore, dueOnAfter, dueOnBefore *time.Time, isArchived bool, sortBy cnst.SortBy, sortDir cnst.SortDir, after *id.Id, limit int) (*GetSetResult, error) <span class="cov8" title="1">{
        val, e := getSet.DoRequest(css, c.host, &amp;getSetArgs{
                Shard:           shard,
                Account:         account,
                NameContains:    nameContains,
                CreatedOnAfter:  createdOnAfter,
                CreatedOnBefore: createdOnBefore,
                StartOnAfter:    startOnAfter,
                StartOnBefore:   startOnBefore,
                DueOnAfter:      dueOnAfter,
                DueOnBefore:     dueOnBefore,
                IsArchived:      isArchived,
                SortBy:          sortBy,
                SortDir:         sortDir,
                After:           after,
                Limit:           limit,
        }, nil, &amp;GetSetResult{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*GetSetResult), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) Delete(css *clientsession.Store, shard int, account, project id.Id) error <span class="cov8" title="1">{
        _, e := delete.DoRequest(css, c.host, &amp;deleteArgs{
                Shard:   shard,
                Account: account,
                Project: project,
        }, nil, nil)
        return e
}</span>

func (c *client) AddMembers(css *clientsession.Store, shard int, account, project id.Id, members []*AddProjectMember) error <span class="cov8" title="1">{
        _, e := addMembers.DoRequest(css, c.host, &amp;addMembersArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                Members: members,
        }, nil, nil)
        return e
}</span>

func (c *client) SetMemberRole(css *clientsession.Store, shard int, account, project, member id.Id, role cnst.ProjectRole) error <span class="cov8" title="1">{
        _, e := setMemberRole.DoRequest(css, c.host, &amp;setMemberRoleArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                Member:  member,
                Role:    role,
        }, nil, nil)
        return e
}</span>

func (c *client) RemoveMembers(css *clientsession.Store, shard int, account, project id.Id, members []id.Id) error <span class="cov8" title="1">{
        _, e := removeMembers.DoRequest(css, c.host, &amp;removeMembersArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                Members: members,
        }, nil, nil)
        return e
}</span>

func (c *client) GetMembers(css *clientsession.Store, shard int, account, project id.Id, role *cnst.ProjectRole, nameOrDisplayNameContains *string, after *id.Id, limit int) (*GetMembersResult, error) <span class="cov8" title="1">{
        val, e := getMembers.DoRequest(css, c.host, &amp;getMembersArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                Role:    role,
                NameOrDisplayNameContains: nameOrDisplayNameContains,
                After: after,
                Limit: limit,
        }, nil, &amp;GetMembersResult{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*GetMembersResult), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) GetMe(css *clientsession.Store, shard int, account, project id.Id) (*member, error) <span class="cov8" title="1">{
        val, e := getMe.DoRequest(css, c.host, &amp;getMeArgs{
                Shard:   shard,
                Account: account,
                Project: project,
        }, nil, &amp;member{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*member), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) GetActivities(css *clientsession.Store, shard int, account, project id.Id, item, member *id.Id, occurredAfter, occurredBefore *time.Time, limit int) ([]*activity.Activity, error) <span class="cov8" title="1">{
        val, e := getActivities.DoRequest(css, c.host, &amp;getActivitiesArgs{
                Shard:          shard,
                Account:        account,
                Project:        project,
                Item:           item,
                Member:         member,
                OccurredAfter:  occurredAfter,
                OccurredBefore: occurredBefore,
                Limit:          limit,
        }, nil, &amp;[]*activity.Activity{})
        if val != nil </span><span class="cov8" title="1">{
                return *val.(*[]*activity.Activity), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package project

import (
        "bitbucket.org/0xor1/task/server/util/activity"
        "bitbucket.org/0xor1/task/server/util/cachekey"
        "bitbucket.org/0xor1/task/server/util/cnst"
        "bitbucket.org/0xor1/task/server/util/ctx"
        "bitbucket.org/0xor1/task/server/util/db"
        "bitbucket.org/0xor1/task/server/util/err"
        "bitbucket.org/0xor1/task/server/util/id"
        "bytes"
        "fmt"
        "github.com/0xor1/panic"
        "strings"
        "time"
)

func dbGetProjectExists(ctx ctx.Ctx, shard int, account, project id.Id) bool <span class="cov8" title="1">{
        var exists bool
        cacheKey := cachekey.NewGet("db.GetProjectExists", shard, account, project).Project(account, project)
        if ctx.GetCacheValue(&amp;exists, cacheKey) </span><span class="cov0" title="0">{
                return exists
        }</span>
        <span class="cov8" title="1">row := ctx.TreeQueryRow(shard, `SELECT COUNT(*) = 1 FROM projects WHERE account=? AND id=?`, account, project)
        panic.If(row.Scan(&amp;exists))
        ctx.SetCacheValue(exists, cacheKey)
        return exists</span>
}

func dbCreateProject(ctx ctx.Ctx, shard int, account id.Id, project *Project) <span class="cov8" title="1">{
        _, e := ctx.TreeExec(shard, `CALL createProject(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`, account, project.Id, ctx.Me(), project.Name, project.Description, project.CreatedOn, project.StartOn, project.DueOn, project.IsParallel, project.IsPublic)
        panic.If(e)
        ctx.TouchDlms(cachekey.NewSetDlms().AccountActivities(account).AccountProjectsSet(account))
}</span>

func dbSetIsPublic(ctx ctx.Ctx, shard int, account, project id.Id, isPublic bool) <span class="cov8" title="1">{
        _, e := ctx.TreeExec(shard, `CALL setProjectIsPublic(?, ?, ?, ?)`, account, project, ctx.Me(), isPublic)
        panic.If(e)
        ctx.TouchDlms(cachekey.NewSetDlms().AccountActivities(account).Project(account, project).ProjectActivities(account, project))
}</span>

func dbGetProject(ctx ctx.Ctx, shard int, account, proj id.Id) *Project <span class="cov8" title="1">{
        res := Project{}
        cacheKey := cachekey.NewGet("project.dbGetProject", shard, account, proj).Project(account, proj)
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return &amp;res
        }</span>
        <span class="cov8" title="1">row := ctx.TreeQueryRow(shard, `SELECT p.id, p.isArchived, p.name, p.createdOn, p.startOn, p.dueOn, p.fileCount, p.fileSize, p.isPublic, t.description, t.totalRemainingTime, t.totalLoggedTime, t.minimumRemainingTime, t.linkedFileCount, t.chatCount, t.childCount, t.descendantCount, t.isParallel FROM projects p, tasks t WHERE p.account=? AND p.id=? AND t.account=? AND t.project=? AND t.id=?`, account, proj, account, proj, proj)
        if err.IsSqlErrNoRowsElsePanicIf(row.Scan(&amp;res.Id, &amp;res.IsArchived, &amp;res.Name, &amp;res.CreatedOn, &amp;res.StartOn, &amp;res.DueOn, &amp;res.FileCount, &amp;res.FileSize, &amp;res.IsPublic, &amp;res.Description, &amp;res.TotalRemainingTime, &amp;res.TotalLoggedTime, &amp;res.MinimumRemainingTime, &amp;res.LinkedFileCount, &amp;res.ChatCount, &amp;res.ChildCount, &amp;res.DescendantCount, &amp;res.IsParallel)) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">ctx.SetCacheValue(res, cacheKey)
        return &amp;res</span>
}

func dbGetPublicProjects(ctx ctx.Ctx, shard int, account id.Id, nameContains *string, createdOnAfter, createdOnBefore, startOnAfter, startOnBefore, dueOnAfter, dueOnBefore *time.Time, isArchived bool, sortBy cnst.SortBy, sortDir cnst.SortDir, after *id.Id, limit int) *GetSetResult <span class="cov0" title="0">{
        return dbGetProjects(ctx, shard, `AND isPublic=true`, account, nil, nameContains, createdOnAfter, createdOnBefore, startOnAfter, startOnBefore, dueOnAfter, dueOnBefore, isArchived, sortBy, sortDir, after, limit)
}</span>

func dbGetPublicAndSpecificAccessProjects(ctx ctx.Ctx, shard int, account, me id.Id, nameContains *string, createdOnAfter, createdOnBefore, startOnAfter, startOnBefore, dueOnAfter, dueOnBefore *time.Time, isArchived bool, sortBy cnst.SortBy, sortDir cnst.SortDir, after *id.Id, limit int) *GetSetResult <span class="cov0" title="0">{
        return dbGetProjects(ctx, shard, `AND (isPublic=true OR id IN (SELECT project FROM projectMembers WHERE account=? AND isActive=true AND id=?))`, account, &amp;me, nameContains, createdOnAfter, createdOnBefore, startOnAfter, startOnBefore, dueOnAfter, dueOnBefore, isArchived, sortBy, sortDir, after, limit)
}</span>

func dbGetAllProjects(ctx ctx.Ctx, shard int, account id.Id, nameContains *string, createdOnAfter, createdOnBefore, startOnAfter, startOnBefore, dueOnAfter, dueOnBefore *time.Time, isArchived bool, sortBy cnst.SortBy, sortDir cnst.SortDir, after *id.Id, limit int) *GetSetResult <span class="cov8" title="1">{
        return dbGetProjects(ctx, shard, ``, account, nil, nameContains, createdOnAfter, createdOnBefore, startOnAfter, startOnBefore, dueOnAfter, dueOnBefore, isArchived, sortBy, sortDir, after, limit)
}</span>

func dbSetProjectIsArchived(ctx ctx.Ctx, shard int, account, project id.Id, isArchived bool) <span class="cov8" title="1">{
        _, e := ctx.TreeExec(shard, `CALL setProjectIsArchived(?, ?, ?, ?)`, account, project, ctx.Me(), isArchived)
        panic.If(e)
        ctx.TouchDlms(cachekey.NewSetDlms().Project(account, project).ProjectActivities(account, project))
}</span>

func dbDeleteProject(ctx ctx.Ctx, shard int, account, project id.Id) <span class="cov8" title="1">{
        _, e := ctx.TreeExec(shard, `CALL deleteProject(?, ?, ?)`, account, project, ctx.Me())
        panic.If(e)
        ctx.TouchDlms(cachekey.NewSetDlms().AccountProjectsSet(account).ProjectMaster(account, project))
}</span>

func dbAddMemberOrSetActive(ctx ctx.Ctx, shard int, account, project id.Id, member *AddProjectMember) <span class="cov8" title="1">{
        db.MakeChangeHelper(ctx, shard, `CALL addProjectMemberOrSetActive(?, ?, ?, ?, ?)`, account, project, ctx.Me(), member.Id, member.Role)
        ctx.TouchDlms(cachekey.NewSetDlms().ProjectMember(account, project, member.Id).ProjectActivities(account, project))
}</span>

func dbSetMemberRole(ctx ctx.Ctx, shard int, account, project, member id.Id, role cnst.ProjectRole) <span class="cov8" title="1">{
        db.MakeChangeHelper(ctx, shard, `CALL setProjectMemberRole(?, ?, ?, ?, ?)`, account, project, ctx.Me(), member, role)
        ctx.TouchDlms(cachekey.NewSetDlms().ProjectMember(account, project, member).ProjectActivities(account, project))
}</span>

func dbSetMemberInactive(ctx ctx.Ctx, shard int, account, project id.Id, member id.Id) <span class="cov8" title="1">{
        db.MakeChangeHelper(ctx, shard, `CALL setProjectMemberInactive(?, ?, ?, ?)`, account, project, ctx.Me(), member)
        ctx.TouchDlms(cachekey.NewSetDlms().ProjectMember(account, project, member).ProjectActivities(account, project))
}</span>

func dbGetMembers(ctx ctx.Ctx, shard int, account, project id.Id, role *cnst.ProjectRole, nameOrDisplayNameContains *string, after *id.Id, limit int) *GetMembersResult <span class="cov8" title="1">{
        res := GetMembersResult{}
        cacheKey := cachekey.NewGet("project.dbGetMembers", shard, account, project, role, nameOrDisplayNameContains, after, limit).ProjectMembersSet(account, project)
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return &amp;res
        }</span>
        <span class="cov8" title="1">query := bytes.NewBufferString(`SELECT p1.id, p1.isActive, p1.totalRemainingTime, p1.totalLoggedTime, p1.role FROM projectMembers p1`)
        args := make([]interface{}, 0, 9)
        if after != nil </span><span class="cov0" title="0">{
                query.WriteString(`, projectMembers p2`)
        }</span>
        <span class="cov8" title="1">query.WriteString(` WHERE p1.account=? AND p1.project=? AND p1.isActive=true`)
        args = append(args, account, project)
        if after != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND p2.account=? AND p2.project=? p2.id=? AND ((p1.name&gt;p2.name AND p1.role=p2.role) OR p1.role&gt;p2.role)`)
                args = append(args, account, project, *after)
        }</span>
        <span class="cov8" title="1">if role != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND p1.role=?`)
                args = append(args, role)
        }</span>
        <span class="cov8" title="1">if nameOrDisplayNameContains != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND (p1.name LIKE ? OR p1.displayName LIKE ?)`)
                strVal := strings.Trim(*nameOrDisplayNameContains, " ")
                strVal = fmt.Sprintf("%%%s%%", strVal)
                args = append(args, strVal, strVal)
        }</span>
        <span class="cov8" title="1">query.WriteString(` ORDER BY p1.role ASC, p1.name ASC LIMIT ?`)
        args = append(args, limit+1)
        rows, e := ctx.TreeQuery(shard, query.String(), args...)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.If(e)
        memSet := make([]*member, 0, limit+1)
        for rows.Next() </span><span class="cov8" title="1">{
                mem := member{}
                panic.If(rows.Scan(&amp;mem.Id, &amp;mem.IsActive, &amp;mem.TotalRemainingTime, &amp;mem.TotalLoggedTime, &amp;mem.Role))
                memSet = append(memSet, &amp;mem)
        }</span>
        <span class="cov8" title="1">if len(memSet) == limit+1 </span><span class="cov0" title="0">{
                res.Members = memSet[:limit]
                res.More = true
        }</span><span class="cov8" title="1"> else {
                res.Members = memSet
                res.More = false
        }</span>
        <span class="cov8" title="1">ctx.SetCacheValue(&amp;res, cacheKey)
        return &amp;res</span>
}

func dbGetMember(ctx ctx.Ctx, shard int, account, project, mem id.Id) *member <span class="cov8" title="1">{
        res := member{}
        cacheKey := cachekey.NewGet("project.dbGetMember", shard, account, project, mem).ProjectMember(account, project, mem)
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return &amp;res
        }</span>
        <span class="cov8" title="1">row := ctx.TreeQueryRow(shard, `SELECT id, isActive, role FROM projectMembers WHERE account=? AND project=? AND id=?`, account, project, mem)
        panic.If(row.Scan(&amp;res.Id, &amp;res.IsActive, &amp;res.Role))
        ctx.SetCacheValue(&amp;res, cacheKey)
        return &amp;res</span>
}

func dbGetActivities(ctx ctx.Ctx, shard int, account, project id.Id, item, member *id.Id, occurredAfter, occurredBefore *time.Time, limit int) []*activity.Activity <span class="cov8" title="1">{
        panic.IfTrueWith(occurredAfter != nil &amp;&amp; occurredBefore != nil, err.InvalidArguments)
        res := make([]*activity.Activity, 0, limit)
        cacheKey := cachekey.NewGet("project.dbGetActivities", shard, account, project, item, member, occurredAfter, occurredBefore, limit).ProjectActivities(account, project)
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return res
        }</span>
        <span class="cov8" title="1">query := bytes.NewBufferString(`SELECT occurredOn, item, member, itemType, itemHasBeenDeleted, action, itemName, extraInfo FROM projectActivities WHERE account=? AND project=?`)
        args := make([]interface{}, 0, limit)
        args = append(args, account, project)
        if item != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND item=?`)
                args = append(args, *item)
        }</span>
        <span class="cov8" title="1">if member != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND member=?`)
                args = append(args, *member)
        }</span>
        <span class="cov8" title="1">if occurredAfter != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND occurredOn&gt;? ORDER BY occurredOn ASC`)
                args = append(args, occurredAfter)
        }</span>
        <span class="cov8" title="1">if occurredBefore != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND occurredOn&lt;? ORDER BY occurredOn DESC`)
                args = append(args, occurredBefore)
        }</span>
        <span class="cov8" title="1">if occurredAfter == nil &amp;&amp; occurredBefore == nil </span><span class="cov8" title="1">{
                query.WriteString(` ORDER BY occurredOn DESC`)
        }</span>
        <span class="cov8" title="1">query.WriteString(` LIMIT ?`)
        args = append(args, limit)
        rows, e := ctx.TreeQuery(shard, query.String(), args...)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.If(e)
        for rows.Next() </span><span class="cov8" title="1">{
                act := activity.Activity{}
                panic.If(rows.Scan(&amp;act.OccurredOn, &amp;act.Item, &amp;act.Member, &amp;act.ItemType, &amp;act.ItemHasBeenDeleted, &amp;act.Action, &amp;act.ItemName, &amp;act.ExtraInfo))
                res = append(res, &amp;act)
        }</span>
        <span class="cov8" title="1">ctx.SetCacheValue(res, cacheKey)
        return res</span>
}

func dbGetProjects(ctx ctx.Ctx, shard int, specificSqlFilterTxt string, account id.Id, me *id.Id, nameContains *string, createdOnAfter, createdOnBefore, startOnAfter, startOnBefore, dueOnAfter, dueOnBefore *time.Time, isArchived bool, sortBy cnst.SortBy, sortDir cnst.SortDir, after *id.Id, limit int) *GetSetResult <span class="cov8" title="1">{
        res := GetSetResult{}
        cacheKey := cachekey.NewGet("project.dbGetProjectsSet", shard, specificSqlFilterTxt, account, me, nameContains, createdOnAfter, createdOnBefore, startOnAfter, startOnBefore, dueOnAfter, dueOnBefore, isArchived, sortBy, sortDir, after, limit).AccountProjectsSet(account)
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return &amp;res
        }</span>
        <span class="cov8" title="1">query := bytes.NewBufferString(`SELECT id, isArchived, name, createdOn, startOn, dueOn, fileCount, fileSize, isPublic FROM projects WHERE account=? AND isArchived=? %s`)
        args := make([]interface{}, 0, 14)
        args = append(args, account, isArchived)
        if me != nil </span><span class="cov0" title="0">{
                args = append(args, account, *me)
        }</span>
        <span class="cov8" title="1">if nameContains != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND name LIKE ?`)
                args = append(args, fmt.Sprintf(`%%%s%%`, strings.Trim(*nameContains, " ")))
        }</span>
        <span class="cov8" title="1">if createdOnAfter != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND createdOn&gt;?`)
                args = append(args, createdOnAfter)
        }</span>
        <span class="cov8" title="1">if createdOnBefore != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND createdOn&lt;?`)
                args = append(args, createdOnBefore)
        }</span>
        <span class="cov8" title="1">if startOnAfter != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND startOn&gt;?`)
                args = append(args, startOnAfter)
        }</span>
        <span class="cov8" title="1">if startOnBefore != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND startOn&lt;?`)
                args = append(args, startOnBefore)
        }</span>
        <span class="cov8" title="1">if dueOnAfter != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND dueOn&gt;?`)
                args = append(args, dueOnAfter)
        }</span>
        <span class="cov8" title="1">if dueOnBefore != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND dueOn&lt;?`)
                args = append(args, dueOnBefore)
        }</span>
        <span class="cov8" title="1">if after != nil </span><span class="cov8" title="1">{
                query.WriteString(fmt.Sprintf(` AND %s %s= (SELECT %s FROM projects WHERE account=? AND id=?) AND id &gt; ?`, sortBy, sortDir.GtLtSymbol(), sortBy))
                args = append(args, account, *after, *after)
        }</span>
        <span class="cov8" title="1">query.WriteString(fmt.Sprintf(` ORDER BY %s %s, id LIMIT ?`, sortBy, sortDir))
        args = append(args, limit+1)
        rows, e := ctx.TreeQuery(shard, fmt.Sprintf(query.String(), specificSqlFilterTxt), args...)
        panic.If(e)
        projSet := make([]*Project, 0, limit+1)
        idx := 0
        resIdx := map[string]int{}
        for rows.Next() </span><span class="cov8" title="1">{
                proj := Project{}
                panic.If(rows.Scan(&amp;proj.Id, &amp;proj.IsArchived, &amp;proj.Name, &amp;proj.CreatedOn, &amp;proj.StartOn, &amp;proj.DueOn, &amp;proj.FileCount, &amp;proj.FileSize, &amp;proj.IsPublic))
                projSet = append(projSet, &amp;proj)
                resIdx[proj.Id.String()] = idx
                idx++
        }</span>
        <span class="cov8" title="1">if len(projSet) &gt; 0 </span><span class="cov8" title="1">{ //populate task properties
                var i id.Id
                var description *string
                var totalRemainingTime, totalLoggedTime, minimumRemainingTime, linkedFileCount, chatCount, childCount, descendantCount uint64
                var isParallel bool
                query.Reset()
                args = make([]interface{}, 0, len(projSet)+1)
                args = append(args, account, projSet[0].Id)
                query.WriteString(`SELECT id, description, totalRemainingTime, totalLoggedTime, minimumRemainingTime, linkedFileCount, chatCount, childCount, descendantCount, isParallel FROM tasks WHERE account=? AND project=id AND project IN (?`)
                for _, proj := range projSet[1:] </span><span class="cov8" title="1">{
                        query.WriteString(`,?`)
                        args = append(args, proj.Id)
                }</span>
                <span class="cov8" title="1">query.WriteString(fmt.Sprintf(`) LIMIT %d`, len(projSet)))
                rows, e := ctx.TreeQuery(shard, query.String(), args...)
                panic.If(e)
                for rows.Next() </span><span class="cov8" title="1">{
                        rows.Scan(&amp;i, &amp;description, &amp;totalRemainingTime, &amp;totalLoggedTime, &amp;minimumRemainingTime, &amp;linkedFileCount, &amp;chatCount, &amp;childCount, &amp;descendantCount, &amp;isParallel)
                        proj := projSet[resIdx[i.String()]]
                        proj.Description = description
                        proj.TotalRemainingTime = totalRemainingTime
                        proj.TotalLoggedTime = totalLoggedTime
                        proj.MinimumRemainingTime = minimumRemainingTime
                        proj.LinkedFileCount = linkedFileCount
                        proj.ChatCount = chatCount
                        proj.ChildCount = childCount
                        proj.DescendantCount = descendantCount
                        proj.IsParallel = isParallel
                }</span>
        }
        <span class="cov8" title="1">if len(projSet) == limit+1 </span><span class="cov8" title="1">{
                res.Projects = projSet[:limit]
                res.More = true
        }</span><span class="cov8" title="1"> else {
                res.Projects = projSet
                res.More = false
        }</span>
        <span class="cov8" title="1">ctx.SetCacheValue(&amp;res, cacheKey)
        return &amp;res</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package project

import (
        "bitbucket.org/0xor1/task/server/util/activity"
        "bitbucket.org/0xor1/task/server/util/cnst"
        "bitbucket.org/0xor1/task/server/util/ctx"
        "bitbucket.org/0xor1/task/server/util/db"
        "bitbucket.org/0xor1/task/server/util/endpoint"
        "bitbucket.org/0xor1/task/server/util/err"
        "bitbucket.org/0xor1/task/server/util/id"
        t "bitbucket.org/0xor1/task/server/util/time"
        "bitbucket.org/0xor1/task/server/util/validate"
        "github.com/0xor1/panic"
        "time"
        "net/http"
)

var (
        publicProjectsDisabledErr = &amp;err.Err{Code: "r_v1_p_ppd", Message: "public projects disabled"}
)

type createArgs struct {
        Shard       int                 `json:"shard"`
        Account     id.Id               `json:"account"`
        Name        string              `json:"name"`
        Description *string             `json:"description"`
        StartOn     *time.Time          `json:"startOn"`
        DueOn       *time.Time          `json:"dueOn"`
        IsParallel  bool                `json:"isParallel"`
        IsPublic    bool                `json:"isPublic"`
        Members     []*AddProjectMember `json:"members"`
}

var create = &amp;endpoint.Endpoint{
        Method:                   http.MethodPost,
        Path:                     "/api/v1/project/create",
        RequiresSession:          true,
        ExampleResponseStructure: &amp;Project{},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;createArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*createArgs)
                validate.MemberHasAccountAdminAccess(db.GetAccountRole(ctx, args.Shard, args.Account, ctx.Me()))
                panic.IfTrueWith(args.IsPublic &amp;&amp; !db.GetPublicProjectsEnabled(ctx, args.Shard, args.Account), publicProjectsDisabledErr)

                project := &amp;Project{}
                project.Id = id.New()
                project.Name = args.Name
                project.Description = args.Description
                project.CreatedOn = t.Now()
                project.StartOn = args.StartOn
                project.DueOn = args.DueOn
                project.IsParallel = args.IsParallel
                project.IsPublic = args.IsPublic
                dbCreateProject(ctx, args.Shard, args.Account, project)
                if args.Account.Equal(ctx.Me()) </span><span class="cov0" title="0">{
                        addMem := &amp;AddProjectMember{}
                        addMem.Id = ctx.Me()
                        addMem.Role = cnst.ProjectAdmin
                        dbAddMemberOrSetActive(ctx, args.Shard, args.Account, project.Id, addMem)
                }</span>

                <span class="cov8" title="1">if len(args.Members) &gt; 0 </span><span class="cov0" title="0">{
                        addMembers.CtxHandler(ctx, &amp;addMembersArgs{
                                Shard:   args.Shard,
                                Account: args.Account,
                                Project: project.Id,
                                Members: args.Members,
                        })
                }</span>

                <span class="cov8" title="1">return project</span>
        },
}

type setIsPublicArgs struct {
        Shard    int   `json:"shard"`
        Account  id.Id `json:"account"`
        Project  id.Id `json:"project"`
        IsPublic bool  `json:"isPublic"`
}

var setIsPublic = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/project/setIsPublic",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setIsPublicArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setIsPublicArgs)
                validate.MemberHasAccountAdminAccess(db.GetAccountRole(ctx, args.Shard, args.Account, ctx.Me()))
                panic.IfTrueWith(args.IsPublic &amp;&amp; !db.GetPublicProjectsEnabled(ctx, args.Shard, args.Account), publicProjectsDisabledErr)
                dbSetIsPublic(ctx, args.Shard, args.Account, args.Project, args.IsPublic)
                return nil
        }</span>,
}

type setIsArchivedArgs struct {
        Shard      int   `json:"shard"`
        Account    id.Id `json:"account"`
        Project    id.Id `json:"project"`
        IsArchived bool  `json:"isArchived"`
}

var setIsArchived = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/project/setIsArchived",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setIsArchivedArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setIsArchivedArgs)
                validate.MemberHasAccountAdminAccess(db.GetAccountRole(ctx, args.Shard, args.Account, ctx.Me()))
                dbSetProjectIsArchived(ctx, args.Shard, args.Account, args.Project, args.IsArchived)
                return nil
        }</span>,
}

type getArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
        Project id.Id `json:"project"`
}

var get = &amp;endpoint.Endpoint{
        Method:                   http.MethodGet,
        Path:                     "/api/v1/project/get",
        RequiresSession:          false,
        ExampleResponseStructure: &amp;Project{},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getArgs)
                validate.MemberHasProjectReadAccess(db.GetAccountAndProjectRolesAndProjectIsPublic(ctx, args.Shard, args.Account, args.Project, ctx.TryMe()))

                return dbGetProject(ctx, args.Shard, args.Account, args.Project)
        }</span>,
}

type getSetArgs struct {
        Shard           int          `json:"shard"`
        Account         id.Id        `json:"account"`
        NameContains    *string      `json:"nameContains"`
        CreatedOnAfter  *time.Time   `json:"createdOnAfter"`
        CreatedOnBefore *time.Time   `json:"createdOnBefore"`
        StartOnAfter    *time.Time   `json:"startOnAfter"`
        StartOnBefore   *time.Time   `json:"startOnBefore"`
        DueOnAfter      *time.Time   `json:"dueOnAfter"`
        DueOnBefore     *time.Time   `json:"dueOnBefore"`
        IsArchived      bool         `json:"isArchived"`
        SortBy          cnst.SortBy  `json:"sortBy"`
        SortDir         cnst.SortDir `json:"sortDir"`
        After           *id.Id       `json:"after"`
        Limit           int          `json:"limit"`
}

type GetSetResult struct {
        Projects []*Project `json:"projects"`
        More     bool       `json:"more"`
}

var getSet = &amp;endpoint.Endpoint{
        Method:                   http.MethodGet,
        Path:                     "/api/v1/project/getSet",
        RequiresSession:          false,
        ExampleResponseStructure: &amp;GetSetResult{Projects: []*Project{{}}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getSetArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getSetArgs)
                var myAccountRole *cnst.AccountRole
                if ctx.TryMe() != nil </span><span class="cov8" title="1">{
                        myAccountRole = db.GetAccountRole(ctx, args.Shard, args.Account, ctx.Me())
                }</span>
                <span class="cov8" title="1">args.Limit = validate.Limit(args.Limit, ctx.MaxProcessEntityCount())
                if myAccountRole == nil </span><span class="cov0" title="0">{
                        return dbGetPublicProjects(ctx, args.Shard, args.Account, args.NameContains, args.CreatedOnAfter, args.CreatedOnBefore, args.StartOnAfter, args.StartOnBefore, args.DueOnAfter, args.DueOnBefore, args.IsArchived, args.SortBy, args.SortDir, args.After, args.Limit)
                }</span>
                <span class="cov8" title="1">if *myAccountRole != cnst.AccountOwner &amp;&amp; *myAccountRole != cnst.AccountAdmin </span><span class="cov0" title="0">{
                        return dbGetPublicAndSpecificAccessProjects(ctx, args.Shard, args.Account, ctx.Me(), args.NameContains, args.CreatedOnAfter, args.CreatedOnBefore, args.StartOnAfter, args.StartOnBefore, args.DueOnAfter, args.DueOnBefore, args.IsArchived, args.SortBy, args.SortDir, args.After, args.Limit)
                }</span>
                <span class="cov8" title="1">return dbGetAllProjects(ctx, args.Shard, args.Account, args.NameContains, args.CreatedOnAfter, args.CreatedOnBefore, args.StartOnAfter, args.StartOnBefore, args.DueOnAfter, args.DueOnBefore, args.IsArchived, args.SortBy, args.SortDir, args.After, args.Limit)</span>
        },
}

type deleteArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
        Project id.Id `json:"project"`
}

var delete = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/project/delete",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;deleteArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*deleteArgs)
                validate.MemberHasAccountAdminAccess(db.GetAccountRole(ctx, args.Shard, args.Account, ctx.Me()))
                dbDeleteProject(ctx, args.Shard, args.Account, args.Project)
                //TODO delete s3 data, uploaded files etc
                return nil
        }</span>,
}

type addMembersArgs struct {
        Shard   int                 `json:"shard"`
        Account id.Id               `json:"account"`
        Project id.Id               `json:"project"`
        Members []*AddProjectMember `json:"members"`
}

var addMembers = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/project/addMembers",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;addMembersArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*addMembersArgs)
                validate.EntityCount(len(args.Members), ctx.MaxProcessEntityCount())
                panic.IfTrueWith(args.Account.Equal(ctx.Me()), err.InvalidOperation)

                validate.MemberHasProjectAdminAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))
                validate.Exists(dbGetProjectExists(ctx, args.Shard, args.Account, args.Project))

                for _, mem := range args.Members </span><span class="cov8" title="1">{
                        mem.Role.Validate()
                        accRole := db.GetAccountRole(ctx, args.Shard, args.Account, mem.Id)
                        panic.IfTrueWith(accRole == nil, err.InvalidArguments)
                        if *accRole == cnst.AccountOwner || *accRole == cnst.AccountAdmin </span><span class="cov8" title="1">{
                                mem.Role = cnst.ProjectAdmin // account owners and admins cant be added to projects with privelages less than project admin
                        }</span>
                        <span class="cov8" title="1">dbAddMemberOrSetActive(ctx, args.Shard, args.Account, args.Project, mem)</span>
                }
                <span class="cov8" title="1">return nil</span>
        },
}

type setMemberRoleArgs struct {
        Shard   int              `json:"shard"`
        Account id.Id            `json:"account"`
        Project id.Id            `json:"project"`
        Member  id.Id            `json:"member"`
        Role    cnst.ProjectRole `json:"role"`
}

var setMemberRole = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/project/setMemberRole",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setMemberRoleArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setMemberRoleArgs)
                panic.IfTrueWith(args.Account.Equal(ctx.Me()), err.InvalidOperation)
                args.Role.Validate()

                validate.MemberHasProjectAdminAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))

                accRole, projectRole := db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, args.Member)
                panic.IfTrueWith(projectRole == nil, err.InvalidOperation)
                if *projectRole != args.Role </span><span class="cov8" title="1">{
                        panic.IfTrueWith(args.Role != cnst.ProjectAdmin &amp;&amp; (*accRole == cnst.AccountOwner || *accRole == cnst.AccountAdmin), err.InvalidArguments) // account owners and admins can only be project admins
                        dbSetMemberRole(ctx, args.Shard, args.Account, args.Project, args.Member, args.Role)
                }</span>
                <span class="cov8" title="1">return nil</span>
        },
}

type removeMembersArgs struct {
        Shard   int     `json:"shard"`
        Account id.Id   `json:"account"`
        Project id.Id   `json:"project"`
        Members []id.Id `json:"members"`
}

var removeMembers = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/project/removeMembers",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;removeMembersArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*removeMembersArgs)
                validate.EntityCount(len(args.Members), ctx.MaxProcessEntityCount())
                panic.IfTrueWith(args.Account.Equal(ctx.Me()), err.InvalidOperation)
                validate.MemberHasProjectAdminAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))

                for _, mem := range args.Members </span><span class="cov8" title="1">{
                        dbSetMemberInactive(ctx, args.Shard, args.Account, args.Project, mem)
                }</span>
                <span class="cov8" title="1">return nil</span>
        },
}

type getMembersArgs struct {
        Shard                     int               `json:"shard"`
        Account                   id.Id             `json:"account"`
        Project                   id.Id             `json:"project"`
        Role                      *cnst.ProjectRole `json:"role,omitempty"`
        NameOrDisplayNameContains *string           `json:"nameorDisplayNameContains,omitempty"`
        After                     *id.Id            `json:"after,omitempty"`
        Limit                     int               `json:"limit"`
}

type GetMembersResult struct {
        Members []*member `json:"members"`
        More    bool      `json:"more"`
}

var getMembers = &amp;endpoint.Endpoint{
        Method:                   http.MethodGet,
        Path:                     "/api/v1/project/getMembers",
        RequiresSession:          false,
        ExampleResponseStructure: &amp;GetMembersResult{Members: []*member{{}}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getMembersArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getMembersArgs)
                validate.MemberHasProjectReadAccess(db.GetAccountAndProjectRolesAndProjectIsPublic(ctx, args.Shard, args.Account, args.Project, ctx.TryMe()))
                return dbGetMembers(ctx, args.Shard, args.Account, args.Project, args.Role, args.NameOrDisplayNameContains, args.After, validate.Limit(args.Limit, ctx.MaxProcessEntityCount()))
        }</span>,
}

type getMeArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
        Project id.Id `json:"project"`
}

var getMe = &amp;endpoint.Endpoint{
        Method:                   http.MethodGet,
        Path:                     "/api/v1/project/getMe",
        RequiresSession:          true,
        ExampleResponseStructure: &amp;member{},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getMeArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getMeArgs)
                return dbGetMember(ctx, args.Shard, args.Account, args.Project, ctx.Me())
        }</span>,
}

type getActivitiesArgs struct {
        Shard          int        `json:"shard"`
        Account        id.Id      `json:"account"`
        Project        id.Id      `json:"project"`
        Item           *id.Id     `json:"item,omitempty"`
        Member         *id.Id     `json:"member,omitempty"`
        OccurredAfter  *time.Time `json:"occurredAfter,omitempty"`
        OccurredBefore *time.Time `json:"occurredBefore,omitempty"`
        Limit          int        `json:"limit"`
}

var getActivities = &amp;endpoint.Endpoint{
        Method:                   http.MethodGet,
        Path:                     "/api/v1/project/getActivities",
        RequiresSession:          false,
        ExampleResponseStructure: []*activity.Activity{{}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getActivitiesArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getActivitiesArgs)
                panic.IfTrueWith(args.OccurredAfter != nil &amp;&amp; args.OccurredBefore != nil, err.InvalidArguments)
                validate.MemberHasProjectReadAccess(db.GetAccountAndProjectRolesAndProjectIsPublic(ctx, args.Shard, args.Account, args.Project, ctx.TryMe()))
                return dbGetActivities(ctx, args.Shard, args.Account, args.Project, args.Item, args.Member, args.OccurredAfter, args.OccurredBefore, validate.Limit(args.Limit, ctx.MaxProcessEntityCount()))
        }</span>,
}

var Endpoints = []*endpoint.Endpoint{
        create,
        setIsPublic,
        setIsArchived,
        get,
        getSet,
        delete,
        addMembers,
        setMemberRole,
        removeMembers,
        getMembers,
        getMe,
        getActivities,
}

type member struct {
        Id                 id.Id            `json:"id"`
        TotalRemainingTime uint64           `json:"totalRemainingTime"`
        TotalLoggedTime    uint64           `json:"totalLoggedTime"`
        IsActive           bool             `json:"isActive"`
        Role               cnst.ProjectRole `json:"role"`
}

type Project struct {
        Id                   id.Id      `json:"id"`
        IsArchived           bool       `json:"isArchived"`
        Name                 string     `json:"name"`
        Description          *string    `json:"description"`
        CreatedOn            time.Time  `json:"createdOn"`
        StartOn              *time.Time `json:"startOn,omitempty"`
        DueOn                *time.Time `json:"dueOn,omitempty"`
        TotalRemainingTime   uint64     `json:"totalRemainingTime"`
        TotalLoggedTime      uint64     `json:"totalLoggedTime"`
        MinimumRemainingTime uint64     `json:"minimumRemainingTime"`
        FileCount            uint64     `json:"fileCount"`
        FileSize             uint64     `json:"fileSize"`
        LinkedFileCount      uint64     `json:"linkedFileCount"`
        ChatCount            uint64     `json:"chatCount"`
        ChildCount           uint64     `json:"childCount"`
        DescendantCount      uint64     `json:"descendantCount"`
        IsParallel           bool       `json:"isParallel,omitempty"`
        IsPublic             bool       `json:"isPublic"`
}

type AddProjectMember struct {
        Id   id.Id            `json:"id"`
        Role cnst.ProjectRole `json:"role"`
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package task

import (
        "bitbucket.org/0xor1/task/server/util/clientsession"
        "bitbucket.org/0xor1/task/server/util/id"
)

type Client interface {
        Create(css *clientsession.Store, shard int, account, project, parent id.Id, previousSibling *id.Id, name string, description *string, isAbstract bool, isParallel *bool, member *id.Id, remainingTime *uint64) (*Task, error)
        SetName(css *clientsession.Store, shard int, account, project, task id.Id, name string) error
        SetDescription(css *clientsession.Store, shard int, account, project, task id.Id, description *string) error
        SetIsParallel(css *clientsession.Store, shard int, account, project, task id.Id, isParallel bool) error         //only applies to abstract tasks
        SetMember(css *clientsession.Store, shard int, account, project, task id.Id, member *id.Id) error               //only applies to tasks
        SetRemainingTime(css *clientsession.Store, shard int, account, project, task id.Id, remainingTime uint64) error //only applies to tasks
        Move(css *clientsession.Store, shard int, account, project, task, parent id.Id, nextSibling *id.Id) error
        Delete(css *clientsession.Store, shard int, account, project, task id.Id) error
        Get(css *clientsession.Store, shard int, account, project id.Id, tasks []id.Id) ([]*Task, error)
        GetChildren(css *clientsession.Store, shard int, account, project, parent id.Id, fromSibling *id.Id, limit int) ([]*Task, error)
        GetAncestors(css *clientsession.Store, shard int, account, project, child id.Id, limit int) ([]*Ancestor, error)
}

func NewClient(host string) Client <span class="cov8" title="1">{
        return &amp;client{
                host: host,
        }
}</span>

type client struct {
        host string
}

func (c *client) Create(css *clientsession.Store, shard int, account, project, parent id.Id, previousSibling *id.Id, name string, description *string, isAbstract bool, isParallel *bool, member *id.Id, totalRemainingTime *uint64) (*Task, error) <span class="cov8" title="1">{
        val, e := create.DoRequest(css, c.host, &amp;createArgs{
                Shard:              shard,
                Account:            account,
                Project:            project,
                Parent:             parent,
                PreviousSibling:    previousSibling,
                Name:               name,
                Description:        description,
                IsAbstract:         isAbstract,
                IsParallel:         isParallel,
                Member:             member,
                TotalRemainingTime: totalRemainingTime,
        }, nil, &amp;Task{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*Task), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) SetName(css *clientsession.Store, shard int, account, project, task id.Id, name string) error <span class="cov8" title="1">{
        _, e := setName.DoRequest(css, c.host, &amp;setNameArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                Task:    task,
                Name:    name,
        }, nil, nil)
        return e
}</span>

func (c *client) SetDescription(css *clientsession.Store, shard int, account, project, task id.Id, description *string) error <span class="cov8" title="1">{
        _, e := setDescription.DoRequest(css, c.host, &amp;setDescriptionArgs{
                Shard:       shard,
                Account:     account,
                Project:     project,
                Task:        task,
                Description: description,
        }, nil, nil)
        return e
}</span>

func (c *client) SetIsParallel(css *clientsession.Store, shard int, account, project, task id.Id, isParallel bool) error <span class="cov8" title="1">{
        _, e := setIsParallel.DoRequest(css, c.host, &amp;setIsParallelArgs{
                Shard:      shard,
                Account:    account,
                Project:    project,
                Task:       task,
                IsParallel: isParallel,
        }, nil, nil)
        return e
}</span>

func (c *client) SetMember(css *clientsession.Store, shard int, account, project, task id.Id, member *id.Id) error <span class="cov8" title="1">{
        _, e := setMember.DoRequest(css, c.host, &amp;setMemberArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                Task:    task,
                Member:  member,
        }, nil, nil)
        return e
}</span>

func (c *client) SetRemainingTime(css *clientsession.Store, shard int, account, project, task id.Id, remainingTime uint64) error <span class="cov8" title="1">{
        _, e := setRemainingTime.DoRequest(css, c.host, &amp;setRemainingTimeArgs{
                Shard:         shard,
                Account:       account,
                Project:       project,
                Task:          task,
                RemainingTime: remainingTime,
        }, nil, nil)
        return e
}</span>

func (c *client) Move(css *clientsession.Store, shard int, account, project, task, newParent id.Id, newPreviousSibling *id.Id) error <span class="cov8" title="1">{
        _, e := move.DoRequest(css, c.host, &amp;moveArgs{
                Shard:              shard,
                Account:            account,
                Project:            project,
                Task:               task,
                NewParent:          newParent,
                NewPreviousSibling: newPreviousSibling,
        }, nil, nil)
        return e
}</span>

func (c *client) Delete(css *clientsession.Store, shard int, account, project, task id.Id) error <span class="cov8" title="1">{
        _, e := deleteTask.DoRequest(css, c.host, &amp;deleteArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                Task:    task,
        }, nil, nil)
        return e
}</span>

func (c *client) Get(css *clientsession.Store, shard int, account, project id.Id, tasks []id.Id) ([]*Task, error) <span class="cov8" title="1">{
        val, e := get.DoRequest(css, c.host, &amp;getArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                Tasks:   tasks,
        }, nil, &amp;[]*Task{})
        if val != nil </span><span class="cov8" title="1">{
                return *val.(*[]*Task), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) GetChildren(css *clientsession.Store, shard int, account, project, parent id.Id, fromSibling *id.Id, limit int) ([]*Task, error) <span class="cov8" title="1">{
        val, e := getChildren.DoRequest(css, c.host, &amp;getChildrenArgs{
                Shard:       shard,
                Account:     account,
                Project:     project,
                Parent:      parent,
                FromSibling: fromSibling,
                Limit:       limit,
        }, nil, &amp;[]*Task{})
        if val != nil </span><span class="cov8" title="1">{
                return *val.(*[]*Task), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) GetAncestors(css *clientsession.Store, shard int, account, project, child id.Id, limit int) ([]*Ancestor, error) <span class="cov8" title="1">{
        val, e := getAncestorTasks.DoRequest(css, c.host, &amp;getAncestorTasksArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                Task:    child,
                Limit:   limit,
        }, nil, &amp;[]*Ancestor{})
        if val != nil </span><span class="cov8" title="1">{
                return *val.(*[]*Ancestor), e
        }</span>
        <span class="cov8" title="1">return nil, e</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package task

import (
        "bitbucket.org/0xor1/task/server/util/cachekey"
        "bitbucket.org/0xor1/task/server/util/ctx"
        "bitbucket.org/0xor1/task/server/util/db"
        "bitbucket.org/0xor1/task/server/util/err"
        "bitbucket.org/0xor1/task/server/util/id"
        "bytes"
        "github.com/0xor1/panic"
)

func dbCreateTask(ctx ctx.Ctx, shard int, account, project, parent id.Id, nextSibling *id.Id, newTask *Task) <span class="cov8" title="1">{
        args := make([]interface{}, 0, 18)
        args = append(args, account, project, parent, ctx.Me())
        if nextSibling != nil </span><span class="cov8" title="1">{
                args = append(args, *nextSibling)
        }</span><span class="cov8" title="1"> else {
                args = append(args, nil)
        }</span>
        <span class="cov8" title="1">args = append(args, newTask.Id)
        args = append(args, newTask.IsAbstract)
        args = append(args, newTask.Name)
        args = append(args, newTask.Description)
        args = append(args, newTask.CreatedOn)
        args = append(args, newTask.TotalRemainingTime)
        args = append(args, newTask.IsParallel)
        if newTask.Member != nil </span><span class="cov8" title="1">{
                args = append(args, *newTask.Member)
        }</span><span class="cov8" title="1"> else {
                args = append(args, nil)
        }</span>
        <span class="cov8" title="1">ctx.TouchDlms(cachekey.NewSetDlms().ProjectActivities(account, project).TaskChildrenSet(account, project, parent).CombinedTaskAndTaskChildrenSets(account, project, db.TreeChangeHelper(ctx, shard, `CALL createTask(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`, args...)))</span>
}

func dbSetName(ctx ctx.Ctx, shard int, account, project, task id.Id, name string) <span class="cov8" title="1">{
        rows, e := ctx.TreeQuery(shard, `CALL setTaskName(?, ?, ?, ?, ?)`, account, project, task, ctx.Me(), name)
        panic.If(e)
        var timeLog *id.Id //on the first pass this is the parent (if any)
        var member *id.Id
        firstRow := true
        cacheKey := cachekey.NewSetDlms().ProjectActivities(account, project).Task(account, project, task)
        for rows.Next() </span><span class="cov8" title="1">{
                rows.Scan(&amp;timeLog, &amp;member)
                if firstRow &amp;&amp; timeLog != nil </span><span class="cov8" title="1">{ //timeLog is the parent id on the first row
                        cacheKey.TaskChildrenSet(account, project, *timeLog)
                }</span><span class="cov8" title="1"> else if timeLog != nil &amp;&amp; member != nil </span><span class="cov0" title="0">{
                        cacheKey.TimeLog(account, project, *timeLog, &amp;task, member)
                }</span>
                <span class="cov8" title="1">firstRow = false</span>
        }
        <span class="cov8" title="1">ctx.TouchDlms(cacheKey)</span>
}

func dbSetDescription(ctx ctx.Ctx, shard int, account, project, task id.Id, description *string) <span class="cov8" title="1">{
        row := ctx.TreeQueryRow(shard, `CALL setTaskDescription(?, ?, ?, ?, ?)`, account, project, task, ctx.Me(), description)
        var parent *id.Id
        panic.If(row.Scan(&amp;parent))
        cacheKey := cachekey.NewSetDlms().ProjectActivities(account, project).Task(account, project, task)
        if parent != nil </span><span class="cov8" title="1">{
                cacheKey.TaskChildrenSet(account, project, *parent)
        }</span>
        <span class="cov8" title="1">ctx.TouchDlms(cacheKey)</span>
}

func dbSetIsParallel(ctx ctx.Ctx, shard int, account, project id.Id, task id.Id, isParallel bool) <span class="cov8" title="1">{
        cacheKey := cachekey.NewSetDlms().ProjectActivities(account, project)
        ctx.TouchDlms(cacheKey.CombinedTaskAndTaskChildrenSets(account, project, db.TreeChangeHelper(ctx, shard, `CALL setTaskIsParallel(?, ?, ?, ?, ?)`, account, project, task, ctx.Me(), isParallel)))
}</span>

func dbSetMember(ctx ctx.Ctx, shard int, account, project, task id.Id, member *id.Id) <span class="cov8" title="1">{
        var memArg []byte
        if member != nil </span><span class="cov8" title="1">{
                memArg = *member
        }</span>
        <span class="cov8" title="1">changeMade := false
        var parent id.Id
        var existingMember *id.Id
        panic.If(ctx.TreeQueryRow(shard, `CALL setTaskMember(?, ?, ?, ?, ?)`, account, project, task, ctx.Me(), memArg).Scan(&amp;changeMade, &amp;parent, &amp;existingMember))
        panic.IfTrueWith(!changeMade, db.ErrNoChangeMade)
        cacheKey := cachekey.NewSetDlms().ProjectActivities(account, project).TaskChildrenSet(account, project, parent).Task(account, project, task)
        if member != nil </span><span class="cov8" title="1">{
                cacheKey.ProjectMember(account, project, *member)
        }</span>
        <span class="cov8" title="1">if existingMember != nil </span><span class="cov8" title="1">{
                cacheKey.ProjectMember(account, project, *existingMember)
        }</span>
        <span class="cov8" title="1">ctx.TouchDlms(cacheKey)</span>
}

func dbMoveTask(ctx ctx.Ctx, shard int, account, project, task, newParent id.Id, newPreviousSibling *id.Id) <span class="cov8" title="1">{
        ctx.TouchDlms(cachekey.NewSetDlms().ProjectActivities(account, project).CombinedTaskAndTaskChildrenSets(account, project, db.TreeChangeHelper(ctx, shard, `CALL moveTask(?, ?, ?, ?, ?, ?)`, account, project, task, newParent, ctx.Me(), newPreviousSibling)))
}</span>

func dbDeleteTask(ctx ctx.Ctx, shard int, account, project, task id.Id) <span class="cov8" title="1">{
        rows, e := ctx.TreeQuery(shard, `CALL deleteTask(?, ?, ?, ?)`, account, project, task, ctx.Me())
        panic.If(e)
        affectedTasks := make([]id.Id, 0, 100)
        updatedProjectMembers := make([]id.Id, 0, 100)
        cacheKey := cachekey.NewSetDlms().ProjectActivities(account, project)
        for rows.Next() </span><span class="cov8" title="1">{
                var i id.Id
                var j id.Id
                var k id.Id
                key := ""
                rows.Scan(&amp;i, &amp;j, &amp;k, &amp;key)
                switch key </span>{
                case "t":<span class="cov8" title="1">
                        affectedTasks = append(affectedTasks, i)</span>
                case "m":<span class="cov8" title="1">
                        updatedProjectMembers = append(updatedProjectMembers, i)</span>
                case "tl":<span class="cov0" title="0">
                        cacheKey.TimeLog(account, project, i, &amp;j, &amp;k)</span>
                default:<span class="cov0" title="0">
                        panic.If(err.InvalidOperation)</span>
                }
        }
        <span class="cov8" title="1">ctx.TouchDlms(cacheKey.CombinedTaskAndTaskChildrenSets(account, project, affectedTasks).ProjectMembers(account, project, updatedProjectMembers))</span>
}

func dbGetTasks(ctx ctx.Ctx, shard int, account, project id.Id, tasks []id.Id) []*Task <span class="cov8" title="1">{
        cacheKey := cachekey.NewGet("project.dbGetTasks", shard, account, project, tasks)
        res := make([]*Task, 0, len(tasks))
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return res
        }</span>
        <span class="cov8" title="1">query := bytes.NewBufferString(`SELECT id, parent, firstChild, nextSibling, isAbstract, name, description, createdOn, totalRemainingTime, totalLoggedTime, minimumRemainingTime, linkedFileCount, chatCount, childCount, descendantCount, isParallel, member FROM tasks WHERE account = ? AND project = ? AND id IN (?`)
        queryArgs := make([]interface{}, 0, 2+len(tasks))
        queryArgs = append(queryArgs, account, project, tasks[0])
        for _, task := range tasks[1:] </span><span class="cov8" title="1">{
                query.WriteString(`,?`)
                queryArgs = append(queryArgs, task)
        }</span>
        <span class="cov8" title="1">query.WriteString(`)`)
        rows, e := ctx.TreeQuery(shard, query.String(), queryArgs...)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.If(e)
        for rows.Next() </span><span class="cov8" title="1">{
                ta := Task{}
                panic.If(rows.Scan(&amp;ta.Id, &amp;ta.Parent, &amp;ta.FirstChild, &amp;ta.NextSibling, &amp;ta.IsAbstract, &amp;ta.Name, &amp;ta.Description, &amp;ta.CreatedOn, &amp;ta.TotalRemainingTime, &amp;ta.TotalLoggedTime, &amp;ta.MinimumRemainingTime, &amp;ta.LinkedFileCount, &amp;ta.ChatCount, &amp;ta.ChildCount, &amp;ta.DescendantCount, &amp;ta.IsParallel, &amp;ta.Member))
                nilOutPropertiesThatAreNotNilInTheDb(&amp;ta)
                res = append(res, &amp;ta)
        }</span>
        <span class="cov8" title="1">ctx.SetCacheValue(res, cacheKey)
        return res</span>
}

func dbGetChildTasks(ctx ctx.Ctx, shard int, account, project, parent id.Id, fromSibling *id.Id, limit int) []*Task <span class="cov8" title="1">{
        res := make([]*Task, 0, limit)
        cacheKey := cachekey.NewGet("project.dbGetChildTasks", shard, account, project, parent, fromSibling, limit).TaskChildrenSet(account, project, parent)
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return res
        }</span>
        <span class="cov8" title="1">rows, e := ctx.TreeQuery(shard, `CALL getChildTasks(?, ?, ?, ?, ?)`, account, project, parent, fromSibling, limit)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.If(e)
        for rows.Next() </span><span class="cov8" title="1">{
                ta := Task{}
                panic.If(rows.Scan(&amp;ta.Id, &amp;ta.Parent, &amp;ta.FirstChild, &amp;ta.NextSibling, &amp;ta.IsAbstract, &amp;ta.Name, &amp;ta.Description, &amp;ta.CreatedOn, &amp;ta.TotalRemainingTime, &amp;ta.TotalLoggedTime, &amp;ta.MinimumRemainingTime, &amp;ta.LinkedFileCount, &amp;ta.ChatCount, &amp;ta.ChildCount, &amp;ta.DescendantCount, &amp;ta.IsParallel, &amp;ta.Member))
                nilOutPropertiesThatAreNotNilInTheDb(&amp;ta)
                res = append(res, &amp;ta)
        }</span>
        <span class="cov8" title="1">ctx.SetCacheValue(res, cacheKey)
        return res</span>
}

func dbGetAncestorTasks(ctx ctx.Ctx, shard int, account, project, child id.Id, limit int) []*Ancestor <span class="cov8" title="1">{
        // note to future dan:
        // I believe this is uncachable, the cache system is based on breaking dlms for entities higher up the entity tree,
        // so we can only cache moving down the entity tree, but this operation goes up the tree, and is therefore uncachable
        rows, e := ctx.TreeQuery(shard, `CALL getAncestorTasks(?, ?, ?, ?)`, account, project, child, limit)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.If(e)
        res := make([]*Ancestor, 0, limit)
        for rows.Next() </span><span class="cov8" title="1">{
                an := Ancestor{}
                panic.If(rows.Scan(&amp;an.Id, &amp;an.Name))
                res = append(res, &amp;an)
        }</span>
        <span class="cov8" title="1">return res</span>
}

func nilOutPropertiesThatAreNotNilInTheDb(ta *Task) <span class="cov8" title="1">{
        if !ta.IsAbstract </span><span class="cov8" title="1">{
                ta.MinimumRemainingTime = nil
                ta.ChildCount = nil
                ta.DescendantCount = nil
                ta.IsParallel = nil
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package task

import (
        "bitbucket.org/0xor1/task/server/util/ctx"
        "bitbucket.org/0xor1/task/server/util/db"
        "bitbucket.org/0xor1/task/server/util/endpoint"
        "bitbucket.org/0xor1/task/server/util/err"
        "bitbucket.org/0xor1/task/server/util/id"
        t "bitbucket.org/0xor1/task/server/util/time"
        "bitbucket.org/0xor1/task/server/util/validate"
        "github.com/0xor1/panic"
        "time"
        "net/http"
)

type createArgs struct {
        Shard              int     `json:"shard"`
        Account            id.Id   `json:"account"`
        Project            id.Id   `json:"project"`
        Parent             id.Id   `json:"parent"`
        PreviousSibling    *id.Id  `json:"previousSibling,omitempty"`
        Name               string  `json:"name"`
        Description        *string `json:"description,omitempty"`
        IsAbstract         bool    `json:"isAbstract"`
        IsParallel         *bool   `json:"isParallel,omitempty"`
        Member             *id.Id  `json:"member,omitempty"`
        TotalRemainingTime *uint64 `json:"totalRemainingTime,omitempty"`
}

var create = &amp;endpoint.Endpoint{
        Method:                   http.MethodPost,
        Path:                     "/api/v1/task/create",
        RequiresSession:          true,
        ExampleResponseStructure: &amp;Task{},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;createArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*createArgs)
                validate.MemberHasProjectWriteAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))
                panic.IfTrueWith((args.IsAbstract &amp;&amp; (args.IsParallel == nil || args.Member != nil || args.TotalRemainingTime != nil)) || (!args.IsAbstract &amp;&amp; (args.IsParallel != nil || args.TotalRemainingTime == nil)), err.InvalidArguments)
                zeroVal := uint64(0)
                zeroPtr := &amp;zeroVal
                if !args.IsAbstract </span><span class="cov8" title="1">{
                        zeroPtr = nil
                }</span><span class="cov8" title="1"> else {
                        args.TotalRemainingTime = zeroPtr
                }</span>
                <span class="cov8" title="1">if args.Member != nil </span><span class="cov8" title="1">{ //if a member is being assigned to the task then we need to check they have project write access
                        validate.MemberIsAProjectMemberWithWriteAccess(db.GetProjectRole(ctx, args.Shard, args.Account, args.Project, *args.Member))
                }</span>
                <span class="cov8" title="1">newTask := &amp;Task{
                        Id:                   id.New(),
                        IsAbstract:           args.IsAbstract,
                        Name:                 args.Name,
                        Description:          args.Description,
                        CreatedOn:            t.Now(),
                        TotalRemainingTime:   *args.TotalRemainingTime,
                        MinimumRemainingTime: zeroPtr,
                        ChildCount:           zeroPtr,
                        DescendantCount:      zeroPtr,
                        IsParallel:           args.IsParallel,
                        Member:               args.Member,
                }
                dbCreateTask(ctx, args.Shard, args.Account, args.Project, args.Parent, args.PreviousSibling, newTask)
                return newTask</span>
        },
}

type setNameArgs struct {
        Shard   int    `json:"shard"`
        Account id.Id  `json:"account"`
        Project id.Id  `json:"project"`
        Task    id.Id  `json:"task"`
        Name    string `json:"name"`
}

var setName = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/task/setName",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setNameArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setNameArgs)
                if args.Project.Equal(args.Task) </span><span class="cov8" title="1">{
                        validate.MemberHasAccountAdminAccess(db.GetAccountRole(ctx, args.Shard, args.Account, ctx.Me()))
                }</span><span class="cov8" title="1"> else {
                        validate.MemberHasProjectWriteAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))
                }</span>

                <span class="cov8" title="1">dbSetName(ctx, args.Shard, args.Account, args.Project, args.Task, args.Name)
                return nil</span>
        },
}

type setDescriptionArgs struct {
        Shard       int     `json:"shard"`
        Account     id.Id   `json:"account"`
        Project     id.Id   `json:"project"`
        Task        id.Id   `json:"task"`
        Description *string `json:"description,omitempty"`
}

var setDescription = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/task/setDescription",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setDescriptionArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setDescriptionArgs)
                validate.MemberHasProjectWriteAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))

                dbSetDescription(ctx, args.Shard, args.Account, args.Project, args.Task, args.Description)
                return nil
        }</span>,
}

type setIsParallelArgs struct {
        Shard      int   `json:"shard"`
        Account    id.Id `json:"account"`
        Project    id.Id `json:"project"`
        Task       id.Id `json:"task"`
        IsParallel bool  `json:"isParallel"`
}

var setIsParallel = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/task/setIsParallel",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setIsParallelArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setIsParallelArgs)
                validate.MemberHasProjectWriteAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))

                dbSetIsParallel(ctx, args.Shard, args.Account, args.Project, args.Task, args.IsParallel)
                return nil
        }</span>,
}

type setMemberArgs struct {
        Shard   int    `json:"shard"`
        Account id.Id  `json:"account"`
        Project id.Id  `json:"project"`
        Task    id.Id  `json:"task"`
        Member  *id.Id `json:"member,omitempty"`
}

var setMember = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/task/setMember",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setMemberArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setMemberArgs)
                validate.MemberHasProjectWriteAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))
                if args.Member != nil </span><span class="cov8" title="1">{
                        validate.MemberIsAProjectMemberWithWriteAccess(db.GetProjectRole(ctx, args.Shard, args.Account, args.Project, *args.Member))
                }</span>
                <span class="cov8" title="1">dbSetMember(ctx, args.Shard, args.Account, args.Project, args.Task, args.Member)
                return nil</span>
        },
}

type setRemainingTimeArgs struct {
        Shard         int    `json:"shard"`
        Account       id.Id  `json:"account"`
        Project       id.Id  `json:"project"`
        Task          id.Id  `json:"task"`
        RemainingTime uint64 `json:"remainingTime"`
}

var setRemainingTime = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/task/setRemainingTime",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setRemainingTimeArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setRemainingTimeArgs)
                return db.SetRemainingTimeAndOrLogTime(ctx, args.Shard, args.Account, args.Project, args.Task, &amp;args.RemainingTime, nil, nil)
        }</span>,
}

type moveArgs struct {
        Shard              int    `json:"shard"`
        Account            id.Id  `json:"account"`
        Project            id.Id  `json:"project"`
        Task               id.Id  `json:"task"`
        NewParent          id.Id  `json:"newParent"`
        NewPreviousSibling *id.Id `json:"newPreviousSibling"`
}

var move = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/task/move",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;moveArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*moveArgs)
                validate.MemberHasProjectWriteAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))

                dbMoveTask(ctx, args.Shard, args.Account, args.Project, args.Task, args.NewParent, args.NewPreviousSibling)
                return nil
        }</span>,
}

type deleteArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
        Project id.Id `json:"project"`
        Task    id.Id `json:"task"`
}

var deleteTask = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/task/delete",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;deleteArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*deleteArgs)
                panic.IfTrueWith(args.Project.Equal(args.Task), err.InvalidArguments)
                validate.MemberHasProjectWriteAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))

                dbDeleteTask(ctx, args.Shard, args.Account, args.Project, args.Task)
                return nil
        }</span>,
}

type getArgs struct {
        Shard   int     `json:"shard"`
        Account id.Id   `json:"account"`
        Project id.Id   `json:"project"`
        Tasks   []id.Id `json:"tasks"`
}

var get = &amp;endpoint.Endpoint{
        Method:                   http.MethodGet,
        Path:                     "/api/v1/task/get",
        RequiresSession:          false,
        ExampleResponseStructure: []*Task{{}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getArgs)
                validate.MemberHasProjectReadAccess(db.GetAccountAndProjectRolesAndProjectIsPublic(ctx, args.Shard, args.Account, args.Project, ctx.TryMe()))
                validate.EntityCount(len(args.Tasks), ctx.MaxProcessEntityCount())
                return dbGetTasks(ctx, args.Shard, args.Account, args.Project, args.Tasks)
        }</span>,
}

type getChildrenArgs struct {
        Shard       int    `json:"shard"`
        Account     id.Id  `json:"account"`
        Project     id.Id  `json:"project"`
        Parent      id.Id  `json:"parent"`
        FromSibling *id.Id `json:"fromSibling,omitempty"`
        Limit       int    `json:"limit"`
}

var getChildren = &amp;endpoint.Endpoint{
        Method:                   http.MethodGet,
        Path:                     "/api/v1/task/getChildren",
        RequiresSession:          false,
        ExampleResponseStructure: []*Task{{}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getChildrenArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getChildrenArgs)
                validate.MemberHasProjectReadAccess(db.GetAccountAndProjectRolesAndProjectIsPublic(ctx, args.Shard, args.Account, args.Project, ctx.TryMe()))
                validate.Limit(args.Limit, ctx.MaxProcessEntityCount())
                return dbGetChildTasks(ctx, args.Shard, args.Account, args.Project, args.Parent, args.FromSibling, args.Limit)
        }</span>,
}

type getAncestorTasksArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
        Project id.Id `json:"project"`
        Task    id.Id `json:"task"`
        Limit   int   `json:"limit"`
}

var getAncestorTasks = &amp;endpoint.Endpoint{
        Method:                   http.MethodGet,
        Path:                     "/api/v1/task/getAncestorTasks",
        RequiresSession:          false,
        ExampleResponseStructure: []*Ancestor{{}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getAncestorTasksArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getAncestorTasksArgs)
                validate.MemberHasProjectReadAccess(db.GetAccountAndProjectRolesAndProjectIsPublic(ctx, args.Shard, args.Account, args.Project, ctx.TryMe()))
                validate.Limit(args.Limit, ctx.MaxProcessEntityCount())
                return dbGetAncestorTasks(ctx, args.Shard, args.Account, args.Project, args.Task, args.Limit)
        }</span>,
}

var Endpoints = []*endpoint.Endpoint{
        create,
        setName,
        setDescription,
        setIsParallel,
        setMember,
        setRemainingTime,
        move,
        deleteTask,
        get,
        getChildren,
        getAncestorTasks,
}

type Task struct {
        Id                   id.Id     `json:"id"`
        Parent               *id.Id    `json:"parent,omitempty"`
        FirstChild           *id.Id    `json:"firstChild,omitempty"`
        NextSibling          *id.Id    `json:"nextSibling,omitempty"`
        IsAbstract           bool      `json:"isAbstract"`
        Name                 string    `json:"name"`
        Description          *string   `json:"description"`
        CreatedOn            time.Time `json:"createdOn"`
        TotalRemainingTime   uint64    `json:"totalRemainingTime"`
        TotalLoggedTime      uint64    `json:"totalLoggedTime"`
        MinimumRemainingTime *uint64   `json:"minimumRemainingTime,omitempty"` //only abstract tasks
        LinkedFileCount      uint64    `json:"linkedFileCount"`
        ChatCount            uint64    `json:"chatCount"`
        ChildCount           *uint64   `json:"childCount,omitempty"`      //only abstract tasks
        DescendantCount      *uint64   `json:"descendantCount,omitempty"` //only abstract tasks
        IsParallel           *bool     `json:"isParallel,omitempty"`      //only abstract tasks
        Member               *id.Id    `json:"member,omitempty"`          //only task tasks
}

type Ancestor struct {
        Id   id.Id  `json:"id"`
        Name string `json:"name"`
        //may want to add on time values here to render progress bars within breadcrumb ui component
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package timelog

import (
        "bitbucket.org/0xor1/task/server/util/clientsession"
        "bitbucket.org/0xor1/task/server/util/cnst"
        "bitbucket.org/0xor1/task/server/util/id"
        tlog "bitbucket.org/0xor1/task/server/util/timelog"
)

type Client interface {
        Create(css *clientsession.Store, shard int, account, project, task id.Id, duration uint64, note *string) (*tlog.TimeLog, error)                                          //only applys to task tasks
        CreateAndSetRemainingTime(css *clientsession.Store, shard int, account, project, task id.Id, remainingTime uint64, duration uint64, note *string) (*tlog.TimeLog, error) //only applys to task tasks
        SetDuration(css *clientsession.Store, shard int, account, project, timeLog id.Id, duration uint64) error
        SetNote(css *clientsession.Store, shard int, account, project, timeLog id.Id, note *string) error
        Delete(css *clientsession.Store, shard int, account, project, timeLog id.Id) error
        Get(css *clientsession.Store, shard int, account, project id.Id, task, member, timeLog *id.Id, sortDir cnst.SortDir, after *id.Id, limit int) ([]*tlog.TimeLog, error)
}

func NewClient(host string) Client <span class="cov8" title="1">{
        return &amp;client{
                host: host,
        }
}</span>

type client struct {
        host string
}

func (c *client) Create(css *clientsession.Store, shard int, account, project, task id.Id, duration uint64, note *string) (*tlog.TimeLog, error) <span class="cov8" title="1">{
        val, e := create.DoRequest(css, c.host, &amp;createArgs{
                Shard:    shard,
                Account:  account,
                Project:  project,
                Task:     task,
                Duration: duration,
                Note:     note,
        }, nil, &amp;tlog.TimeLog{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*tlog.TimeLog), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) CreateAndSetRemainingTime(css *clientsession.Store, shard int, account, project, task id.Id, remainingTime uint64, duration uint64, note *string) (*tlog.TimeLog, error) <span class="cov8" title="1">{
        val, e := createAndSetRemainingTime.DoRequest(css, c.host, &amp;createAndSetRemainingTimeArgs{
                Shard:         shard,
                Account:       account,
                Project:       project,
                Task:          task,
                RemainingTime: remainingTime,
                Duration:      duration,
                Note:          note,
        }, nil, &amp;tlog.TimeLog{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*tlog.TimeLog), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) SetDuration(css *clientsession.Store, shard int, account, project, timeLog id.Id, duration uint64) error <span class="cov8" title="1">{
        _, e := setDuration.DoRequest(css, c.host, &amp;setDurationArgs{
                Shard:    shard,
                Account:  account,
                Project:  project,
                TimeLog:  timeLog,
                Duration: duration,
        }, nil, nil)
        return e
}</span>

func (c *client) SetNote(css *clientsession.Store, shard int, account, project, timeLog id.Id, note *string) error <span class="cov8" title="1">{
        _, e := setNote.DoRequest(css, c.host, &amp;setNoteArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                TimeLog: timeLog,
                Note:    note,
        }, nil, nil)
        return e
}</span>

func (c *client) Delete(css *clientsession.Store, shard int, account, project, timeLog id.Id) error <span class="cov8" title="1">{
        _, e := delete.DoRequest(css, c.host, &amp;deleteArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                TimeLog: timeLog,
        }, nil, nil)
        return e
}</span>

func (c *client) Get(css *clientsession.Store, shard int, account, project id.Id, task, member, timeLog *id.Id, sortDir cnst.SortDir, after *id.Id, limit int) ([]*tlog.TimeLog, error) <span class="cov8" title="1">{
        val, e := get.DoRequest(css, c.host, &amp;getArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                Task:    task,
                Member:  member,
                TimeLog: timeLog,
                SortDir: sortDir,
                After:   after,
                Limit:   limit,
        }, nil, &amp;[]*tlog.TimeLog{})
        if val != nil </span><span class="cov8" title="1">{
                return *val.(*[]*tlog.TimeLog), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package timelog

import (
        "bitbucket.org/0xor1/task/server/util/cachekey"
        "bitbucket.org/0xor1/task/server/util/cnst"
        "bitbucket.org/0xor1/task/server/util/ctx"
        "bitbucket.org/0xor1/task/server/util/db"
        "bitbucket.org/0xor1/task/server/util/id"
        tlog "bitbucket.org/0xor1/task/server/util/timelog"
        "bytes"
        "fmt"
        "github.com/0xor1/panic"
)

func dbGetTimeLog(ctx ctx.Ctx, shard int, account, project, timeLog id.Id) *tlog.TimeLog <span class="cov8" title="1">{
        cacheKey := cachekey.NewGet("timelog.dbGetTimeLog", shard, account, project, timeLog).TimeLog(account, project, timeLog, nil, nil)
        tl := tlog.TimeLog{}
        if ctx.GetCacheValue(&amp;tl, cacheKey) </span><span class="cov0" title="0">{
                return &amp;tl
        }</span>
        <span class="cov8" title="1">panic.If(ctx.TreeQueryRow(shard, `SELECT project, task, id, member, loggedOn, taskHasBeenDeleted, taskName, duration, note FROM timeLogs WHERE account=? AND project=? AND id=?`, account, project, timeLog).Scan(&amp;tl.Project, &amp;tl.Task, &amp;tl.Id, &amp;tl.Member, &amp;tl.LoggedOn, &amp;tl.TaskHasBeenDeleted, &amp;tl.TaskName, &amp;tl.Duration, &amp;tl.Note))
        ctx.SetCacheValue(tl, cacheKey)
        return &amp;tl</span>
}

func dbSetDuration(ctx ctx.Ctx, shard int, account, project, task, member, timeLog id.Id, duration uint64) <span class="cov8" title="1">{
        ctx.TouchDlms(cachekey.NewSetDlms().CombinedTaskAndTaskChildrenSets(account, project, db.TreeChangeHelper(ctx, shard, `CALL setTimeLogDuration(?, ?, ?, ?, ?)`, account, project, timeLog, ctx.Me(), duration)).TimeLog(account, project, timeLog, &amp;task, &amp;member).ProjectActivities(account, project))
}</span>

func dbSetNote(ctx ctx.Ctx, shard int, account, project, task, member, timeLog id.Id, note *string) <span class="cov8" title="1">{
        db.MakeChangeHelper(ctx, shard, `CALL setTimeLogNote(?, ?, ?, ?, ?)`, account, project, timeLog, ctx.Me(), note)
        ctx.TouchDlms(cachekey.NewSetDlms().TimeLog(account, project, timeLog, &amp;task, &amp;member).ProjectActivities(account, project))
}</span>

func dbDelete(ctx ctx.Ctx, shard int, account, project, task, member, timeLog id.Id) <span class="cov8" title="1">{
        ctx.TouchDlms(cachekey.NewSetDlms().CombinedTaskAndTaskChildrenSets(account, project, db.TreeChangeHelper(ctx, shard, `CALL deleteTimeLog(?, ?, ?, ?)`, account, project, timeLog, ctx.Me())).TimeLog(account, project, timeLog, &amp;task, &amp;member).ProjectActivities(account, project))
}</span>

func dbGetTimeLogs(ctx ctx.Ctx, shard int, account, project id.Id, task, member, timeLog *id.Id, sortDir cnst.SortDir, after *id.Id, limit int) []*tlog.TimeLog <span class="cov8" title="1">{
        if timeLog != nil </span><span class="cov8" title="1">{
                return []*tlog.TimeLog{dbGetTimeLog(ctx, shard, account, project, *timeLog)}
        }</span>
        <span class="cov8" title="1">cacheKey := cachekey.NewGet("timelog.dbGetTimeLogs", shard, account, project, task, member, timeLog, sortDir, after, limit)
        if task != nil </span><span class="cov0" title="0">{
                cacheKey.TaskTimeLogSet(account, project, *task, member)
        }</span>
        <span class="cov8" title="1">if member != nil </span><span class="cov0" title="0">{
                cacheKey.ProjectMemberTimeLogSet(account, project, *member)
        }</span>
        <span class="cov8" title="1">if task == nil &amp;&amp; member == nil </span><span class="cov8" title="1">{
                cacheKey.ProjectTimeLogSet(account, project)
        }</span>
        <span class="cov8" title="1">timeLogsSet := make([]*tlog.TimeLog, 0, limit)
        if ctx.GetCacheValue(&amp;timeLogsSet, cacheKey) </span><span class="cov0" title="0">{
                return timeLogsSet
        }</span>
        <span class="cov8" title="1">query := bytes.NewBufferString(`SELECT project, task, id, member, loggedOn, taskHasBeenDeleted, taskName, duration, note FROM timeLogs WHERE account=? AND project=?`)
        args := make([]interface{}, 0, 9)
        args = append(args, account, project)
        if task != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND task=?`)
                args = append(args, *task)
        }</span>
        <span class="cov8" title="1">if member != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND member=?`)
                args = append(args, *member)
        }</span>
        <span class="cov8" title="1">if after != nil </span><span class="cov8" title="1">{
                query.WriteString(fmt.Sprintf(` AND loggedOn %s= (SELECT loggedOn FROM timeLogs WHERE account=? AND project=? AND id=?) AND id %s ?`, sortDir.GtLtSymbol(), sortDir.GtLtSymbol()))
                args = append(args, account, project, *after, *after)
        }</span>
        <span class="cov8" title="1">query.WriteString(fmt.Sprintf(` ORDER BY loggedOn %s, id %s LIMIT ?`, sortDir.String(), sortDir.String()))
        args = append(args, limit)
        rows, e := ctx.TreeQuery(shard, query.String(), args...)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.If(e)
        for rows.Next() </span><span class="cov8" title="1">{
                tl := tlog.TimeLog{}
                panic.If(rows.Scan(&amp;tl.Project, &amp;tl.Task, &amp;tl.Id, &amp;tl.Member, &amp;tl.LoggedOn, &amp;tl.TaskHasBeenDeleted, &amp;tl.TaskName, &amp;tl.Duration, &amp;tl.Note))
                timeLogsSet = append(timeLogsSet, &amp;tl)
        }</span>
        <span class="cov8" title="1">ctx.SetCacheValue(timeLogsSet, cacheKey)
        return timeLogsSet</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package timelog

import (
        "bitbucket.org/0xor1/task/server/util/cnst"
        "bitbucket.org/0xor1/task/server/util/ctx"
        "bitbucket.org/0xor1/task/server/util/db"
        "bitbucket.org/0xor1/task/server/util/endpoint"
        "bitbucket.org/0xor1/task/server/util/err"
        "bitbucket.org/0xor1/task/server/util/id"
        "bitbucket.org/0xor1/task/server/util/timelog"
        "bitbucket.org/0xor1/task/server/util/validate"
        "github.com/0xor1/panic"
        "net/http"
)

type createArgs struct {
        Shard    int     `json:"shard"`
        Account  id.Id   `json:"account"`
        Project  id.Id   `json:"project"`
        Task     id.Id   `json:"task"`
        Duration uint64  `json:"duration"`
        Note     *string `json:"note,omitempty"`
}

var create = &amp;endpoint.Endpoint{
        Method:                   http.MethodPost,
        Path:                     "/api/v1/timeLog/create",
        RequiresSession:          true,
        ExampleResponseStructure: &amp;timelog.TimeLog{},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;createArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*createArgs)
                return db.SetRemainingTimeAndOrLogTime(ctx, args.Shard, args.Account, args.Project, args.Task, nil, &amp;args.Duration, args.Note)
        }</span>,
}

type createAndSetRemainingTimeArgs struct {
        Shard         int     `json:"shard"`
        Account       id.Id   `json:"account"`
        Project       id.Id   `json:"project"`
        Task          id.Id   `json:"task"`
        RemainingTime uint64  `json:"remainingTime"`
        Duration      uint64  `json:"duration"`
        Note          *string `json:"note,omitempty"`
}

var createAndSetRemainingTime = &amp;endpoint.Endpoint{
        Method:                   http.MethodPost,
        Path:                     "/api/v1/timeLog/createAndSetRemainingTime",
        RequiresSession:          true,
        ExampleResponseStructure: &amp;timelog.TimeLog{},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;createAndSetRemainingTimeArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*createAndSetRemainingTimeArgs)
                return db.SetRemainingTimeAndOrLogTime(ctx, args.Shard, args.Account, args.Project, args.Task, &amp;args.RemainingTime, &amp;args.Duration, args.Note)
        }</span>,
}

type setDurationArgs struct {
        Shard    int    `json:"shard"`
        Account  id.Id  `json:"account"`
        Project  id.Id  `json:"project"`
        TimeLog  id.Id  `json:"timeLog"`
        Duration uint64 `json:"duration"`
}

var setDuration = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/timeLog/setDuration",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setDurationArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setDurationArgs)
                panic.IfTrueWith(args.Duration == 0, err.InvalidArguments)
                tl := dbGetTimeLog(ctx, args.Shard, args.Account, args.Project, args.TimeLog)
                if args.Duration == tl.Duration </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">if tl.Member.Equal(ctx.Me()) </span><span class="cov0" title="0">{
                        validate.MemberHasProjectWriteAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))
                }</span><span class="cov8" title="1"> else {
                        validate.MemberHasProjectAdminAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))
                }</span>
                <span class="cov8" title="1">dbSetDuration(ctx, args.Shard, args.Account, args.Project, tl.Task, tl.Member, args.TimeLog, args.Duration)
                return nil</span>
        },
}

type setNoteArgs struct {
        Shard   int     `json:"shard"`
        Account id.Id   `json:"account"`
        Project id.Id   `json:"project"`
        TimeLog id.Id   `json:"timeLog"`
        Note    *string `json:"note"`
}

var setNote = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/timeLog/setNote",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setNoteArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setNoteArgs)
                tl := dbGetTimeLog(ctx, args.Shard, args.Account, args.Project, args.TimeLog)
                if (args.Note == nil &amp;&amp; tl.Note == nil) || (*args.Note == *tl.Note) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">if tl.Member.Equal(ctx.Me()) </span><span class="cov0" title="0">{
                        validate.MemberHasProjectWriteAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))
                }</span><span class="cov8" title="1"> else {
                        validate.MemberHasProjectAdminAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))
                }</span>
                <span class="cov8" title="1">dbSetNote(ctx, args.Shard, args.Account, args.Project, tl.Task, tl.Member, args.TimeLog, args.Note)
                return nil</span>
        },
}

type deleteArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
        Project id.Id `json:"project"`
        TimeLog id.Id `json:"timeLog"`
}

var delete = &amp;endpoint.Endpoint{
        Method:          http.MethodPost,
        Path:            "/api/v1/timeLog/delete",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;deleteArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*deleteArgs)
                tl := dbGetTimeLog(ctx, args.Shard, args.Account, args.Project, args.TimeLog)
                if tl.Member.Equal(ctx.Me()) </span><span class="cov8" title="1">{
                        validate.MemberHasProjectWriteAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))
                }</span><span class="cov0" title="0"> else {
                        validate.MemberHasProjectAdminAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))
                }</span>
                <span class="cov8" title="1">dbDelete(ctx, args.Shard, args.Account, args.Project, tl.Task, tl.Member, args.TimeLog)
                return nil</span>
        },
}

type getArgs struct {
        Shard   int          `json:"shard"`
        Account id.Id        `json:"account"`
        Project id.Id        `json:"project"`
        Task    *id.Id       `json:"task,omitempty"`
        Member  *id.Id       `json:"member,omitempty"`
        TimeLog *id.Id       `json:"timeLog,omitempty"`
        SortDir cnst.SortDir `json:"sortDir"`
        After   *id.Id       `json:"after,omitempty"`
        Limit   int          `json:"limit"`
}

var get = &amp;endpoint.Endpoint{
        Method:                   http.MethodGet,
        Path:                     "/api/v1/timeLog/get",
        RequiresSession:          false,
        ExampleResponseStructure: []*timelog.TimeLog{{}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getArgs)
                validate.MemberHasProjectReadAccess(db.GetAccountAndProjectRolesAndProjectIsPublic(ctx, args.Shard, args.Account, args.Project, ctx.TryMe()))
                return dbGetTimeLogs(ctx, args.Shard, args.Account, args.Project, args.Task, args.Member, args.TimeLog, args.SortDir, args.After, validate.Limit(args.Limit, ctx.MaxProcessEntityCount()))
        }</span>,
}

var Endpoints = []*endpoint.Endpoint{
        create,
        createAndSetRemainingTime,
        setDuration,
        setNote,
        delete,
        get,
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package crypt

import (
        "crypto/rand"
        "github.com/0xor1/panic"
        "golang.org/x/crypto/scrypt"
        "io"
        "math/big"
)

var urlSafeRunes = []rune("0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")

func Bytes(length int) []byte <span class="cov8" title="1">{
        k := make([]byte, length)
        _, e := io.ReadFull(rand.Reader, k)
        panic.If(e)
        return k
}</span>

func UrlSafeString(length int) string <span class="cov8" title="1">{
        buf := make([]rune, length)
        urlSafeRunesLength := big.NewInt(int64(len(urlSafeRunes)))
        for i := range buf </span><span class="cov8" title="1">{
                randomIdx, e := rand.Int(rand.Reader, urlSafeRunesLength)
                panic.If(e)
                buf[i] = urlSafeRunes[int(randomIdx.Int64())]
        }</span>
        <span class="cov8" title="1">return string(buf)</span>
}

func ScryptKey(password, salt []byte, N, r, p, keyLen int) []byte <span class="cov8" title="1">{
        key, e := scrypt.Key(password, salt, N, r, p, keyLen)
        panic.If(e)
        return key
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package id

import (
        "bitbucket.org/0xor1/task/server/util/err"
        "bitbucket.org/0xor1/task/server/util/time"
        "bytes"
        "encoding/base64"
        "github.com/0xor1/panic"
        "github.com/oklog/ulid"
        "math/rand"
        "sync"
)

var (
        entropyMtx = &amp;sync.Mutex{}
        entropy    = rand.New(rand.NewSource(time.NowUnixMillis()))
        parseErr   = &amp;err.Err{Code: "u_i_p", Message: "failed to parse id"}
)

//returns ulid as a byte slice
func New() Id <span class="cov8" title="1">{
        entropyMtx.Lock() //rand source is not safe for concurrent use :(
        defer entropyMtx.Unlock()
        id := ulid.MustNew(ulid.Timestamp(time.Now()), entropy)
        return Id(id[:])
}</span>

func Parse(id string) Id <span class="cov0" title="0">{
        b, e := base64.RawURLEncoding.DecodeString(id)
        panic.IfTrueWith(e != nil || len(b) != 16, parseErr)
        return Id(b)
}</span>

type Id []byte

func (id Id) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return []byte(`"` + id.String() + `"`), nil
}</span>

func (id *Id) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        *id = Parse(string(bytes.Trim(data, `"`)))
        return nil
}</span>

func (id Id) String() string <span class="cov0" title="0">{
        return base64.RawURLEncoding.EncodeToString(id)
}</span>

func (id Id) Equal(other Id) bool <span class="cov8" title="1">{
        return bytes.Equal(id, other)
}</span>

func (id Id) Copy() Id <span class="cov8" title="1">{
        return Id(append(make([]byte, 0, 16), id...))
}</span>

type Identifiable interface{
        Id() Id
}</pre>
		
		<pre class="file" id="file21" style="display: none">package validate

import (
        "bitbucket.org/0xor1/task/server/util/cnst"
        "bitbucket.org/0xor1/task/server/util/err"
        "fmt"
        "github.com/0xor1/panic"
        "regexp"
        "unicode/utf8"
)

var (
        invalidStringArgErr = &amp;err.Err{Code: "u_v_isa", Message: "invalid string arg"}
        emailRegex          = regexp.MustCompile(`.+@.+\..+`)
)

type invalidErr struct {
        *err.Err
        ArgName       string           `json:"argName"`
        MinRuneCount  int              `json:"minRuneCount"`
        MaxRuneCount  int              `json:"maxRuneCount"`
        RegexMatchers []*regexp.Regexp `json:"regexMatchers"`
}

func (e *invalidErr) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("invalid string arg: argName: %q, minRuneCount: %d, maxRuneCount: %d, regexMatchers: %v", e.ArgName, e.MinRuneCount, e.MaxRuneCount, e.RegexMatchers)
}</span>

func invalidStringArgErrPanic(argName string, minRuneCount, maxRuneCount int, regexMatchers []*regexp.Regexp) <span class="cov8" title="1">{
        panic.If(&amp;invalidErr{
                Err:           invalidStringArgErr,
                ArgName:       argName,
                MinRuneCount:  minRuneCount,
                MaxRuneCount:  maxRuneCount,
                RegexMatchers: append(make([]*regexp.Regexp, 0, len(regexMatchers)), regexMatchers...),
        })
}</span>

func StringArg(argPurpose, arg string, minRuneCount, maxRuneCount int, regexMatchers []*regexp.Regexp) <span class="cov8" title="1">{
        valRuneCount := utf8.RuneCountInString(arg)
        if valRuneCount &lt; minRuneCount || valRuneCount &gt; maxRuneCount </span><span class="cov8" title="1">{
                invalidStringArgErrPanic(argPurpose, minRuneCount, maxRuneCount, regexMatchers)
        }</span>
        <span class="cov8" title="1">for _, regex := range regexMatchers </span><span class="cov8" title="1">{
                if matches := regex.MatchString(arg); !matches </span><span class="cov8" title="1">{
                        invalidStringArgErrPanic(argPurpose, minRuneCount, maxRuneCount, regexMatchers)
                }</span>
        }
}

func Email(email string) <span class="cov8" title="1">{
        StringArg("email", email, 6, 254, []*regexp.Regexp{emailRegex})
}</span>

func Limit(limit, maxLimit int) int <span class="cov0" title="0">{
        if limit &lt; 1 || limit &gt; maxLimit </span><span class="cov0" title="0">{
                limit = maxLimit
        }</span>
        <span class="cov0" title="0">return limit</span>
}

func EntityCount(entityCount, maxLimit int) <span class="cov0" title="0">{
        panic.IfTrueWith(entityCount &lt; 1 || entityCount &gt; maxLimit, err.InvalidEntityCount)
}</span>

func Exists(exists bool) <span class="cov0" title="0">{
        panic.IfTrueWith(!exists, err.NoSuchEntity)
}</span>

func MemberHasAccountOwnerAccess(accountRole *cnst.AccountRole) <span class="cov0" title="0">{
        panic.IfTrueWith(accountRole == nil || *accountRole != cnst.AccountOwner, err.InsufficientPermission)
}</span>

func MemberHasAccountAdminAccess(accountRole *cnst.AccountRole) <span class="cov0" title="0">{
        panic.IfTrueWith(accountRole == nil || (*accountRole != cnst.AccountOwner &amp;&amp; *accountRole != cnst.AccountAdmin), err.InsufficientPermission)
}</span>

func MemberHasProjectAdminAccess(accountRole *cnst.AccountRole, projectRole *cnst.ProjectRole) <span class="cov0" title="0">{
        panic.IfTrueWith(accountRole == nil || ((*accountRole != cnst.AccountOwner &amp;&amp; *accountRole != cnst.AccountAdmin) &amp;&amp; (projectRole == nil || *projectRole != cnst.ProjectAdmin)), err.InsufficientPermission)
}</span>

func MemberHasProjectWriteAccess(accountRole *cnst.AccountRole, projectRole *cnst.ProjectRole) <span class="cov0" title="0">{
        panic.IfTrueWith(accountRole == nil || ((*accountRole != cnst.AccountOwner &amp;&amp; *accountRole != cnst.AccountAdmin) &amp;&amp; (projectRole == nil || (*projectRole != cnst.ProjectAdmin &amp;&amp; *projectRole != cnst.ProjectWriter))), err.InsufficientPermission)
}</span>

func MemberIsAProjectMemberWithWriteAccess(projectRole *cnst.ProjectRole) <span class="cov0" title="0">{
        panic.IfTrueWith(projectRole == nil || (*projectRole != cnst.ProjectAdmin &amp;&amp; *projectRole != cnst.ProjectWriter), err.InsufficientPermission)
}</span>

func MemberHasProjectReadAccess(accountRole *cnst.AccountRole, projectRole *cnst.ProjectRole, projectIsPublic *bool) <span class="cov0" title="0">{
        panic.IfTrueWith(projectIsPublic == nil || (!*projectIsPublic &amp;&amp; (accountRole == nil || ((*accountRole != cnst.AccountOwner &amp;&amp; *accountRole != cnst.AccountAdmin) &amp;&amp; (projectRole == nil || (*projectRole != cnst.ProjectAdmin &amp;&amp; *projectRole != cnst.ProjectWriter &amp;&amp; *projectRole != cnst.ProjectReader))))), err.InsufficientPermission)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
