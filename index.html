
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/0xor1/trees/server/api/v1/account/account_client.go (81.0%)</option>
				
				<option value="file1">github.com/0xor1/trees/server/api/v1/account/account_db_helpers.go (78.1%)</option>
				
				<option value="file2">github.com/0xor1/trees/server/api/v1/account/account_endpoints.go (100.0%)</option>
				
				<option value="file3">github.com/0xor1/trees/server/api/v1/centralaccount/central_account_client.go (84.0%)</option>
				
				<option value="file4">github.com/0xor1/trees/server/api/v1/centralaccount/central_account_db_helpers.go (89.9%)</option>
				
				<option value="file5">github.com/0xor1/trees/server/api/v1/centralaccount/central_account_email_helpers.go (75.0%)</option>
				
				<option value="file6">github.com/0xor1/trees/server/api/v1/centralaccount/central_account_endpoints.go (82.9%)</option>
				
				<option value="file7">github.com/0xor1/trees/server/api/v1/private/private_client.go (66.7%)</option>
				
				<option value="file8">github.com/0xor1/trees/server/api/v1/private/private_db_helpers.go (77.9%)</option>
				
				<option value="file9">github.com/0xor1/trees/server/api/v1/private/private_endpoints.go (81.5%)</option>
				
				<option value="file10">github.com/0xor1/trees/server/api/v1/project/project_client.go (74.4%)</option>
				
				<option value="file11">github.com/0xor1/trees/server/api/v1/project/project_db_helpers.go (78.8%)</option>
				
				<option value="file12">github.com/0xor1/trees/server/api/v1/project/project_endpoints.go (88.1%)</option>
				
				<option value="file13">github.com/0xor1/trees/server/api/v1/task/task_client.go (87.0%)</option>
				
				<option value="file14">github.com/0xor1/trees/server/api/v1/task/task_db_helpers.go (94.4%)</option>
				
				<option value="file15">github.com/0xor1/trees/server/api/v1/task/task_endpoints.go (100.0%)</option>
				
				<option value="file16">github.com/0xor1/trees/server/api/v1/timelog/timelog_client.go (82.4%)</option>
				
				<option value="file17">github.com/0xor1/trees/server/api/v1/timelog/timelog_db_helpers.go (81.1%)</option>
				
				<option value="file18">github.com/0xor1/trees/server/api/v1/timelog/timelog_endpoints.go (93.3%)</option>
				
				<option value="file19">github.com/0xor1/trees/server/util/crypt/crypt.go (100.0%)</option>
				
				<option value="file20">github.com/0xor1/trees/server/util/id/id.go (46.2%)</option>
				
				<option value="file21">github.com/0xor1/trees/server/util/validate/validate.go (27.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package account

import (
        "github.com/0xor1/trees/server/util/account"
        "github.com/0xor1/trees/server/util/activity"
        "github.com/0xor1/trees/server/util/clientsession"
        "github.com/0xor1/trees/server/util/cnst"
        "github.com/0xor1/trees/server/util/id"
        "time"
)

type Client interface {
        //must be account owner
        Edit(css *clientsession.Store, region cnst.Region, shard int, account id.Id, fields Fields) error
        //must be account owner/admin
        Get(css *clientsession.Store, region cnst.Region, shard int, account id.Id) (*account.Account, error)
        //must be account owner/admin
        SetMemberRole(css *clientsession.Store, region cnst.Region, shard int, account, member id.Id, role cnst.AccountRole) error
        //pointers are optional filters
        GetMembers(css *clientsession.Store, region cnst.Region, shard int, account id.Id, role *cnst.AccountRole, nameOrDisplayNamePrefix *string, after *id.Id, limit int) (*GetMembersResp, error)
        //either one or both of OccurredAfter/Before must be nil
        GetActivities(css *clientsession.Store, region cnst.Region, shard int, account id.Id, item, member *id.Id, occurredAfter, occurredBefore *time.Time, limit int) ([]*activity.Activity, error)
        //for anyone
        GetMe(css *clientsession.Store, region cnst.Region, shard int, account id.Id) (*Member, error)
}

func NewClient(host string) Client <span class="cov8" title="1">{
        return &amp;client{
                host: host,
        }
}</span>

type client struct {
        host string
}

func (c *client) Edit(css *clientsession.Store, region cnst.Region, shard int, account id.Id, fields Fields) error <span class="cov8" title="1">{
        _, e := edit.DoRequest(css, c.host, region, &amp;editArgs{
                Shard:   shard,
                Account: account,
                Fields:  fields,
        }, nil, nil)
        return e
}</span>

func (c *client) Get(css *clientsession.Store, region cnst.Region, shard int, acc id.Id) (*account.Account, error) <span class="cov8" title="1">{
        val, e := get.DoRequest(css, c.host, region, &amp;getArgs{
                Shard:   shard,
                Account: acc,
        }, nil, &amp;account.Account{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*account.Account), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) SetMemberRole(css *clientsession.Store, region cnst.Region, shard int, account, member id.Id, role cnst.AccountRole) error <span class="cov8" title="1">{
        _, e := setMemberRole.DoRequest(css, c.host, region, &amp;setMemberRoleArgs{
                Shard:   shard,
                Account: account,
                Member:  member,
                Role:    role,
        }, nil, nil)
        return e
}</span>

func (c *client) GetMembers(css *clientsession.Store, region cnst.Region, shard int, account id.Id, role *cnst.AccountRole, nameOrDisplayNamePrefix *string, after *id.Id, limit int) (*GetMembersResp, error) <span class="cov8" title="1">{
        val, e := getMembers.DoRequest(css, c.host, region, &amp;getMembersArgs{
                Shard:   shard,
                Account: account,
                Role:    role,
                NameOrDisplayNamePrefix: nameOrDisplayNamePrefix,
                After: after,
                Limit: limit,
        }, nil, &amp;GetMembersResp{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*GetMembersResp), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) GetActivities(css *clientsession.Store, region cnst.Region, shard int, account id.Id, itemId *id.Id, member *id.Id, occurredAfter, occurredBefore *time.Time, limit int) ([]*activity.Activity, error) <span class="cov8" title="1">{
        val, e := getActivities.DoRequest(css, c.host, region, &amp;getActivitiesArgs{
                Shard:          shard,
                Account:        account,
                Item:           itemId,
                Member:         member,
                OccurredAfter:  occurredAfter,
                OccurredBefore: occurredBefore,
                Limit:          limit,
        }, nil, &amp;[]*activity.Activity{})
        if val != nil </span><span class="cov8" title="1">{
                return *val.(*[]*activity.Activity), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) GetMe(css *clientsession.Store, region cnst.Region, shard int, account id.Id) (*Member, error) <span class="cov8" title="1">{
        val, e := getMe.DoRequest(css, c.host, region, &amp;getMeArgs{
                Shard:   shard,
                Account: account,
        }, nil, &amp;Member{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*Member), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package account

import (
        "github.com/0xor1/trees/server/util/activity"
        "github.com/0xor1/trees/server/util/cachekey"
        "github.com/0xor1/trees/server/util/cnst"
        "github.com/0xor1/trees/server/util/ctx"
        "github.com/0xor1/trees/server/util/db"
        "github.com/0xor1/trees/server/util/field"
        "github.com/0xor1/trees/server/util/id"
        "github.com/0xor1/trees/server/util/validate"
        "bytes"
        "fmt"
        "github.com/0xor1/panic"
        "strings"
        "time"
)

func dbEdit(ctx ctx.Ctx, shard int, account id.Id, fields Fields) <span class="cov8" title="1">{
        setPublicProjectsEnabled := false
        if fields.PublicProjectsEnabled != nil </span><span class="cov8" title="1">{
                setPublicProjectsEnabled = true
        }</span> else<span class="cov0" title="0"> {
                fields.PublicProjectsEnabled = &amp;field.Bool{}
        }</span>
        <span class="cov8" title="1">setHoursPerDay := false
        if fields.HoursPerDay != nil </span><span class="cov8" title="1">{
                setHoursPerDay = true
        }</span> else<span class="cov0" title="0"> {
                fields.HoursPerDay = &amp;field.UInt8{}
        }</span>
        <span class="cov8" title="1">setDaysPerWeek := false
        if fields.DaysPerWeek != nil </span><span class="cov8" title="1">{
                setDaysPerWeek = true
        }</span> else<span class="cov0" title="0"> {
                fields.DaysPerWeek = &amp;field.UInt8{}
        }</span>
        <span class="cov8" title="1">if !setPublicProjectsEnabled &amp;&amp; !setHoursPerDay &amp;&amp; !setDaysPerWeek </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">_, e := ctx.TreeExec(shard, `CALL editAccount(?, ?, ?, ?, ?, ?, ?, ?)`, account, ctx.Me(), setPublicProjectsEnabled, fields.PublicProjectsEnabled.Val, setHoursPerDay, fields.HoursPerDay.Val, setDaysPerWeek, fields.DaysPerWeek.Val)
        panic.IfNotNil(e)
        cacheKey := cachekey.NewSetDlms().Account(account).AccountActivities(account)
        if fields.PublicProjectsEnabled != nil &amp;&amp; !fields.PublicProjectsEnabled.Val </span><span class="cov0" title="0">{ //if setting publicProjectsEnabled to false this could have set some projects to not public
                cacheKey.AccountProjectsSet(account)
        }</span>
        <span class="cov8" title="1">ctx.TouchDlms(cacheKey)</span>
}

func dbSetMemberRole(ctx ctx.Ctx, shard int, account, member id.Id, role cnst.AccountRole) <span class="cov8" title="1">{
        db.MakeChangeHelper(ctx, shard, `CALL setAccountMemberRole(?, ?, ?, ?)`, account, ctx.Me(), member, role)
        ctx.TouchDlms(cachekey.NewSetDlms().AccountMember(account, member).AccountActivities(account))
}</span>

func dbGetMember(ctx ctx.Ctx, shard int, account, mem id.Id) *Member <span class="cov8" title="1">{
        res := Member{}
        cacheKey := cachekey.NewGet("account.dbGetMember", shard, account, mem).AccountMember(account, mem)
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return &amp;res
        }</span>
        <span class="cov8" title="1">row := ctx.TreeQueryRow(shard, `SELECT id, name, displayName, hasAvatar, isActive, role FROM accountMembers WHERE account=? AND id=?`, account, mem)
        panic.IfNotNil(row.Scan(&amp;res.Id, &amp;res.Name, &amp;res.DisplayName, &amp;res.HasAvatar, &amp;res.IsActive, &amp;res.Role))
        ctx.SetCacheValue(res, cacheKey)
        return &amp;res</span>
}

/***
TODO need to determine which of these is most efficient on the db (this applys to project.GetMembers too):
1)
SELECT id, isActive, role
FROM accountMembers
WHERE account=:acc
AND isActive=true
AND (
        (
            name &gt; (SELECT name FROM accountMembers WHERE account=:acc AND id=:id)
            AND role = (SELECT role FROM accountMembers WHERE account=:acc AND id=:id)
        )
        OR role &gt; (SELECT role FROM accountMembers WHERE account=:acc AND id=:id)
)
ORDER BY role ASC, name ASC LIMIT :lim

2)
SELECT a1.id, a1.name, a1.displayName, a1.hasAvatar, a1.isActive, a1.role
FROM accountMembers a1, accountMembers a2
WHERE a1.account=:acc
AND a1.isActive=true
AND a2.account=:acc
AND a2.id=:id
AND (
        (
            a1.name&gt;a2.name
            AND a1.role=a2.role
        )
        OR a1.role&gt;a2.role
)
ORDER BY a1.role ASC, a1.name ASC LIMIT :lim
***/

func dbGetMembers(ctx ctx.Ctx, shard int, account id.Id, role *cnst.AccountRole, nameOrDisplayNamePrefix *string, after *id.Id, limit int) *GetMembersResp <span class="cov8" title="1">{
        if nameOrDisplayNamePrefix != nil </span><span class="cov0" title="0">{
                validate.StringArg("nameOrDisplayNamePrefix", *nameOrDisplayNamePrefix, ctx.DisplayNameMinRuneCount(), ctx.DisplayNameMaxRuneCount(), ctx.DisplayNameRegexMatchers())
        }</span>
        <span class="cov8" title="1">res := GetMembersResp{}
        cacheKey := cachekey.NewGet("account.dbGetMembers", shard, account, role, nameOrDisplayNamePrefix, after, limit).AccountMembersSet(account)
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return &amp;res
        }</span>
        <span class="cov8" title="1">query := bytes.NewBufferString(`SELECT a1.id, a1.name, a1.displayName, a1.hasAvatar, a1.isActive, a1.role FROM accountMembers a1`)
        args := make([]interface{}, 0, 7)
        if after != nil </span><span class="cov8" title="1">{
                query.WriteString(`, accountMembers a2`)
        }</span>
        <span class="cov8" title="1">query.WriteString(` WHERE a1.account=? AND a1.isActive=true`)
        args = append(args, account)
        if after != nil </span><span class="cov8" title="1">{
                query.WriteString(` AND a2.account=? AND a2.id=? AND ((a1.name&gt;a2.name AND a1.role=a2.role) OR a1.role&gt;a2.role)`)
                args = append(args, account, *after)
        }</span>
        <span class="cov8" title="1">if role != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND a1.role=?`)
                args = append(args, role)
        }</span>
        <span class="cov8" title="1">if nameOrDisplayNamePrefix != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND (a1.name LIKE ? OR a1.displayName LIKE ?)`)
                strVal := strings.Trim(*nameOrDisplayNamePrefix, " ")
                strVal = fmt.Sprintf("%s%%", strVal)
                args = append(args, strVal, strVal)
        }</span>
        <span class="cov8" title="1">query.WriteString(` ORDER BY a1.role ASC, a1.name ASC LIMIT ?`)
        args = append(args, limit+1)
        rows, e := ctx.TreeQuery(shard, query.String(), args...)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.IfNotNil(e)
        memSet := make([]*Member, 0, limit+1)
        for rows.Next() </span><span class="cov8" title="1">{
                mem := Member{}
                panic.IfNotNil(rows.Scan(&amp;mem.Id, &amp;mem.Name, &amp;mem.DisplayName, &amp;mem.HasAvatar, &amp;mem.IsActive, &amp;mem.Role))
                memSet = append(memSet, &amp;mem)
        }</span>
        <span class="cov8" title="1">if len(memSet) == limit+1 </span><span class="cov8" title="1">{
                res.Members = memSet[:limit]
                res.More = true
        }</span> else<span class="cov8" title="1"> {
                res.Members = memSet
                res.More = false
        }</span>
        <span class="cov8" title="1">ctx.SetCacheValue(&amp;res, cacheKey)
        return &amp;res</span>
}

func dbGetActivities(ctx ctx.Ctx, shard int, account id.Id, item *id.Id, member *id.Id, occurredAfter, occurredBefore *time.Time, limit int) []*activity.Activity <span class="cov8" title="1">{
        ctx.ReturnBadRequestNowIf(occurredAfter != nil &amp;&amp; occurredBefore != nil, "only one of occurredAfter and occurredBefore can be set")
        res := make([]*activity.Activity, 0, limit)
        cacheKey := cachekey.NewGet("account.dbGetActivities", shard, account, item, member, occurredAfter, occurredBefore, limit).AccountActivities(account)
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return res
        }</span>
        <span class="cov8" title="1">query := bytes.NewBufferString(`SELECT occurredOn, item, member, itemType, itemHasBeenDeleted, action, itemName, extraInfo FROM accountActivities WHERE account=?`)
        args := make([]interface{}, 0, limit)
        args = append(args, account)
        if item != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND item=?`)
                args = append(args, *item)
        }</span>
        <span class="cov8" title="1">if member != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND member=?`)
                args = append(args, *member)
        }</span>
        <span class="cov8" title="1">if occurredAfter != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND occurredOn&gt;? ORDER BY occurredOn ASC`)
                args = append(args, occurredAfter)
        }</span>
        <span class="cov8" title="1">if occurredBefore != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND occurredOn&lt;? ORDER BY occurredOn DESC`)
                args = append(args, occurredBefore)
        }</span>
        <span class="cov8" title="1">if occurredAfter == nil &amp;&amp; occurredBefore == nil </span><span class="cov8" title="1">{
                query.WriteString(` ORDER BY occurredOn DESC`)
        }</span>
        <span class="cov8" title="1">query.WriteString(` LIMIT ?`)
        args = append(args, limit)
        rows, e := ctx.TreeQuery(shard, query.String(), args...)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.IfNotNil(e)
        for rows.Next() </span><span class="cov8" title="1">{
                act := activity.Activity{}
                panic.IfNotNil(rows.Scan(&amp;act.OccurredOn, &amp;act.Item, &amp;act.Member, &amp;act.ItemType, &amp;act.ItemHasBeenDeleted, &amp;act.Action, &amp;act.ItemName, &amp;act.ExtraInfo))
                res = append(res, &amp;act)
        }</span>
        <span class="cov8" title="1">ctx.SetCacheValue(res, cacheKey)
        return res</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package account

import (
        "github.com/0xor1/trees/server/util/account"
        "github.com/0xor1/trees/server/util/activity"
        "github.com/0xor1/trees/server/util/cnst"
        "github.com/0xor1/trees/server/util/ctx"
        "github.com/0xor1/trees/server/util/db"
        "github.com/0xor1/trees/server/util/endpoint"
        "github.com/0xor1/trees/server/util/field"
        "github.com/0xor1/trees/server/util/id"
        "github.com/0xor1/trees/server/util/validate"
        "time"
)

type editArgs struct {
        Shard   int    `json:"shard"`
        Account id.Id  `json:"account"`
        Fields  Fields `json:"fields"`
}

var edit = &amp;endpoint.Endpoint{
        Path:            "/api/v1/account/edit",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;editArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*editArgs)
                validate.MemberHasAccountOwnerAccess(db.GetAccountRole(ctx, args.Shard, args.Account, ctx.Me()))
                if args.Fields.HoursPerDay != nil </span><span class="cov8" title="1">{
                        validate.HoursPerDay(args.Fields.HoursPerDay.Val)
                }</span>
                <span class="cov8" title="1">if args.Fields.DaysPerWeek != nil </span><span class="cov8" title="1">{
                        validate.DaysPerWeek(args.Fields.DaysPerWeek.Val)
                }</span>
                <span class="cov8" title="1">dbEdit(ctx, args.Shard, args.Account, args.Fields)
                return nil</span>
        },
}

type getArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
}

var get = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/account/get",
        RequiresSession:          true,
        ExampleResponseStructure: &amp;account.Account{},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getArgs)
                validate.MemberHasAccountAdminAccess(db.GetAccountRole(ctx, args.Shard, args.Account, ctx.Me()))
                return db.GetAccount(ctx, args.Shard, args.Account)
        }</span>,
}

type setMemberRoleArgs struct {
        Shard   int              `json:"shard"`
        Account id.Id            `json:"account"`
        Member  id.Id            `json:"member"`
        Role    cnst.AccountRole `json:"role"`
}

var setMemberRole = &amp;endpoint.Endpoint{
        Path:            "/api/v1/account/setMemberRole",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setMemberRoleArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setMemberRoleArgs)
                accountRole := db.GetAccountRole(ctx, args.Shard, args.Account, ctx.Me())
                validate.MemberHasAccountAdminAccess(accountRole)
                args.Role.Validate()
                ctx.ReturnUnauthorizedNowIf(args.Role == cnst.AccountOwner &amp;&amp; *accountRole != cnst.AccountOwner)
                dbSetMemberRole(ctx, args.Shard, args.Account, args.Member, args.Role)
                return nil
        }</span>,
}

type getMembersArgs struct {
        Shard                   int               `json:"shard"`
        Account                 id.Id             `json:"account"`
        Role                    *cnst.AccountRole `json:"role,omitempty"`
        NameOrDisplayNamePrefix *string           `json:"nameOrDisplayPrefix,omitempty"`
        After                   *id.Id            `json:"after,omitempty"`
        Limit                   int               `json:"limit"`
}

type GetMembersResp struct {
        Members []*Member `json:"members"`
        More    bool      `json:"more"`
}

var getMembers = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/account/getMembers",
        RequiresSession:          true,
        ExampleResponseStructure: &amp;GetMembersResp{Members: []*Member{{}}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getMembersArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getMembersArgs)
                validate.MemberHasAccountAdminAccess(db.GetAccountRole(ctx, args.Shard, args.Account, ctx.Me()))
                return dbGetMembers(ctx, args.Shard, args.Account, args.Role, args.NameOrDisplayNamePrefix, args.After, validate.Limit(args.Limit, ctx.MaxProcessEntityCount()))
        }</span>,
}

type getActivitiesArgs struct {
        Shard          int        `json:"shard"`
        Account        id.Id      `json:"account"`
        Item           *id.Id     `json:"item,omitempty"`
        Member         *id.Id     `json:"member,omitempty"`
        OccurredAfter  *time.Time `json:"occurredAfter,omitempty"`
        OccurredBefore *time.Time `json:"occurredBefore,omitempty"`
        Limit          int        `json:"limit"`
}

var getActivities = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/account/getActivities",
        RequiresSession:          true,
        ExampleResponseStructure: []*activity.Activity{{}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getActivitiesArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getActivitiesArgs)
                ctx.ReturnUnauthorizedNowIf(args.OccurredAfter != nil &amp;&amp; args.OccurredBefore != nil)
                validate.MemberHasAccountAdminAccess(db.GetAccountRole(ctx, args.Shard, args.Account, ctx.Me()))
                return dbGetActivities(ctx, args.Shard, args.Account, args.Item, args.Member, args.OccurredAfter, args.OccurredBefore, validate.Limit(args.Limit, ctx.MaxProcessEntityCount()))
        }</span>,
}

type getMeArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
}

var getMe = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/account/getMe",
        RequiresSession:          true,
        ExampleResponseStructure: &amp;Member{},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getMeArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getMeArgs)
                return dbGetMember(ctx, args.Shard, args.Account, ctx.Me())
        }</span>,
}

var Endpoints = []*endpoint.Endpoint{
        edit,
        get,
        setMemberRole,
        getMembers,
        getActivities,
        getMe,
}

type Fields struct {
        PublicProjectsEnabled *field.Bool  `json:"publicProjectsEnabled,omitempty"`
        HoursPerDay           *field.UInt8 `json:"hoursPerDay,omitempty"`
        DaysPerWeek           *field.UInt8 `json:"daysPerWeek,omitempty"`
}

type Member struct {
        Id          id.Id            `json:"id"`
        Name        string           `json:"name"`
        DisplayName *string          `json:"displayName,omitempty"`
        HasAvatar   bool             `json:"hasAvatar"`
        Role        cnst.AccountRole `json:"role"`
        IsActive    bool             `json:"isActive"`
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package centralaccount

import (
        "github.com/0xor1/trees/server/util/clientsession"
        "github.com/0xor1/trees/server/util/cnst"
        "github.com/0xor1/trees/server/util/id"
        "bytes"
        "github.com/0xor1/panic"
        "io"
        "io/ioutil"
        "mime/multipart"
)

type Client interface {
        //accessible outside of active session
        Register(region cnst.Region, name, email, pwd, language string, displayName *string, theme cnst.Theme) error
        ResendActivationEmail(email string) error
        Activate(email, activationCode string) error
        Authenticate(css *clientsession.Store, email, pwd string) (*AuthenticateResult, error)
        ConfirmNewEmail(currentEmail, newEmail, confirmationCode string) error
        ResetPwd(email string) error
        SetNewPwdFromPwdReset(newPwd, email, resetPwdCode string) error
        GetAccount(name string) (*Account, error)
        GetAccounts(accounts []id.Id) ([]*Account, error)
        SearchAccounts(nameOrDisplayNamePrefix string) ([]*Account, error)
        SearchPersonalAccounts(nameOrDisplayNamePrefix string) ([]*Account, error)
        //requires active session to access
        GetMe(css *clientsession.Store) (*Me, error)
        SetMyPwd(css *clientsession.Store, oldPwd, newPwd string) error
        SetMyEmail(css *clientsession.Store, newEmail string) error
        ResendMyNewEmailConfirmationEmail(css *clientsession.Store) error
        SetAccountName(css *clientsession.Store, account id.Id, newName string) error
        SetAccountDisplayName(css *clientsession.Store, account id.Id, newDisplayName *string) error
        SetAccountAvatar(css *clientsession.Store, account id.Id, avatar io.ReadCloser) error
        MigrateAccount(css *clientsession.Store, account id.Id, newRegion cnst.Region) error
        CreateAccount(css *clientsession.Store, region cnst.Region, name string, displayName *string) (*Account, error)
        GetMyAccounts(css *clientsession.Store, after *id.Id, limit int) (*GetMyAccountsResult, error)
        DeleteAccount(css *clientsession.Store, account id.Id) error
        //member centric - must be an owner or admin
        AddMembers(css *clientsession.Store, account id.Id, newMembers []*AddMember) error
        RemoveMembers(css *clientsession.Store, account id.Id, existingMembers []id.Id) error
}

func NewClient(host string) Client <span class="cov8" title="1">{
        return &amp;client{
                host: host,
        }
}</span>

type client struct {
        host string
}

func (c *client) Register(region cnst.Region, name, email, pwd, language string, displayName *string, theme cnst.Theme) error <span class="cov8" title="1">{
        _, e := register.DoRequest(nil, c.host, cnst.CentralRegion, &amp;registerArgs{
                Name:        name,
                Email:       email,
                Pwd:         pwd,
                Region:      region,
                Language:    language,
                DisplayName: displayName,
                Theme:       theme,
        }, nil, nil)
        return e
}</span>

func (c *client) ResendActivationEmail(email string) error <span class="cov8" title="1">{
        _, e := resendActivationEmail.DoRequest(nil, c.host, cnst.CentralRegion, &amp;resendActivationEmailArgs{
                Email: email,
        }, nil, nil)
        return e
}</span>

func (c *client) Activate(email, activationCode string) error <span class="cov8" title="1">{
        _, e := activate.DoRequest(nil, c.host, cnst.CentralRegion, &amp;activateArgs{
                Email:          email,
                ActivationCode: activationCode,
        }, nil, nil)
        return e
}</span>

func (c *client) Authenticate(css *clientsession.Store, email, pwdTry string) (*AuthenticateResult, error) <span class="cov8" title="1">{
        val, e := authenticate.DoRequest(css, c.host, cnst.CentralRegion, &amp;authenticateArgs{
                Email:  email,
                PwdTry: pwdTry,
        }, nil, &amp;AuthenticateResult{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*AuthenticateResult), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) ConfirmNewEmail(currentEmail, newEmail, confirmationCode string) error <span class="cov8" title="1">{
        _, e := confirmNewEmail.DoRequest(nil, c.host, cnst.CentralRegion, &amp;confirmNewEmailArgs{
                CurrentEmail:     currentEmail,
                NewEmail:         newEmail,
                ConfirmationCode: confirmationCode,
        }, nil, nil)
        return e
}</span>

func (c *client) ResetPwd(email string) error <span class="cov8" title="1">{
        _, e := resetPwd.DoRequest(nil, c.host, cnst.CentralRegion, &amp;resetPwdArgs{
                Email: email,
        }, nil, nil)
        return e
}</span>

func (c *client) SetNewPwdFromPwdReset(newPwd, email, resetPwdCode string) error <span class="cov8" title="1">{
        _, e := setNewPwdFromPwdReset.DoRequest(nil, c.host, cnst.CentralRegion, &amp;setNewPwdFromPwdResetArgs{
                NewPwd:       newPwd,
                Email:        email,
                ResetPwdCode: resetPwdCode,
        }, nil, nil)
        return e
}</span>

func (c *client) GetAccount(name string) (*Account, error) <span class="cov8" title="1">{
        val, e := getAccount.DoRequest(nil, c.host, cnst.CentralRegion, &amp;getAccountArgs{
                Name: name,
        }, nil, &amp;Account{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*Account), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) GetAccounts(accounts []id.Id) ([]*Account, error) <span class="cov8" title="1">{
        val, e := getAccounts.DoRequest(nil, c.host, cnst.CentralRegion, &amp;getAccountsArgs{
                Accounts: accounts,
        }, nil, &amp;[]*Account{})
        if val != nil </span><span class="cov8" title="1">{
                return *val.(*[]*Account), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) SearchAccounts(nameOrDisplayNamePrefix string) ([]*Account, error) <span class="cov8" title="1">{
        val, e := searchAccounts.DoRequest(nil, c.host, cnst.CentralRegion, &amp;searchAccountsArgs{
                NameOrDisplayNamePrefix: nameOrDisplayNamePrefix,
        }, nil, &amp;[]*Account{})
        if val != nil </span><span class="cov8" title="1">{
                return *val.(*[]*Account), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) SearchPersonalAccounts(nameOrDisplayNamePrefix string) ([]*Account, error) <span class="cov8" title="1">{
        val, e := searchPersonalAccounts.DoRequest(nil, c.host, cnst.CentralRegion, &amp;searchPersonalAccountsArgs{
                NameOrDisplayNamePrefix: nameOrDisplayNamePrefix,
        }, nil, &amp;[]*Account{})
        if val != nil </span><span class="cov8" title="1">{
                return *val.(*[]*Account), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) GetMe(css *clientsession.Store) (*Me, error) <span class="cov8" title="1">{
        val, e := getMe.DoRequest(css, c.host, cnst.CentralRegion, nil, nil, &amp;Me{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*Me), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) SetMyPwd(css *clientsession.Store, oldPwd, newPwd string) error <span class="cov8" title="1">{
        _, e := setMyPwd.DoRequest(css, c.host, cnst.CentralRegion, &amp;setMyPwdArgs{
                OldPwd: oldPwd,
                NewPwd: newPwd,
        }, nil, nil)
        return e
}</span>

func (c *client) SetMyEmail(css *clientsession.Store, newEmail string) error <span class="cov8" title="1">{
        _, e := setMyEmail.DoRequest(css, c.host, cnst.CentralRegion, &amp;setMyEmailArgs{
                NewEmail: newEmail,
        }, nil, nil)
        return e
}</span>

func (c *client) ResendMyNewEmailConfirmationEmail(css *clientsession.Store) error <span class="cov8" title="1">{
        _, e := resendMyNewEmailConfirmationEmail.DoRequest(css, c.host, cnst.CentralRegion, nil, nil, nil)
        return e
}</span>

func (c *client) SetAccountName(css *clientsession.Store, account id.Id, newName string) error <span class="cov8" title="1">{
        _, e := setAccountName.DoRequest(css, c.host, cnst.CentralRegion, &amp;setAccountNameArgs{
                Account: account,
                NewName: newName,
        }, nil, nil)
        return e
}</span>

func (c *client) SetAccountDisplayName(css *clientsession.Store, account id.Id, newDisplayName *string) error <span class="cov8" title="1">{
        _, e := setAccountDisplayName.DoRequest(css, c.host, cnst.CentralRegion, &amp;setAccountDisplayNameArgs{
                Account:        account,
                NewDisplayName: newDisplayName,
        }, nil, nil)
        return e
}</span>

func (c *client) SetAccountAvatar(css *clientsession.Store, account id.Id, avatar io.ReadCloser) error <span class="cov8" title="1">{
        defer avatar.Close()
        _, e := setAccountAvatar.DoRequest(css, c.host, cnst.CentralRegion, &amp;setAccountAvatarArgs{
                Account: account,
                Avatar:  avatar,
        }, func() (io.ReadCloser, string) </span><span class="cov8" title="1">{
                body := bytes.NewBuffer([]byte{})
                writer := multipart.NewWriter(body)
                part, e := writer.CreateFormFile("avatar", "avatar")
                panic.IfNotNil(e)
                _, e = io.Copy(part, avatar)
                panic.IfNotNil(e)
                panic.IfNotNil(writer.WriteField("account", account.String()))
                panic.IfNotNil(writer.Close())
                return ioutil.NopCloser(body), writer.FormDataContentType()
        }</span>, nil)
        <span class="cov8" title="1">return e</span>
}

func (c *client) MigrateAccount(css *clientsession.Store, account id.Id, newRegion cnst.Region) error <span class="cov0" title="0">{
        _, e := migrateAccount.DoRequest(css, c.host, cnst.CentralRegion, &amp;migrateAccountArgs{
                Account:   account,
                NewRegion: newRegion,
        }, nil, nil)
        return e
}</span>

func (c *client) CreateAccount(css *clientsession.Store, region cnst.Region, name string, displayName *string) (*Account, error) <span class="cov8" title="1">{
        val, e := createAccount.DoRequest(css, c.host, cnst.CentralRegion, &amp;createAccountArgs{
                Name:        name,
                Region:      region,
                DisplayName: displayName,
        }, nil, &amp;Account{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*Account), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) GetMyAccounts(css *clientsession.Store, after *id.Id, limit int) (*GetMyAccountsResult, error) <span class="cov8" title="1">{
        val, e := getMyAccounts.DoRequest(css, c.host, cnst.CentralRegion, &amp;getMyAccountsArgs{
                After: after,
                Limit: limit,
        }, nil, &amp;GetMyAccountsResult{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*GetMyAccountsResult), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) DeleteAccount(css *clientsession.Store, account id.Id) error <span class="cov8" title="1">{
        _, e := deleteAccount.DoRequest(css, c.host, cnst.CentralRegion, &amp;deleteAccountArgs{
                Account: account,
        }, nil, nil)
        return e
}</span>

func (c *client) AddMembers(css *clientsession.Store, account id.Id, newMembers []*AddMember) error <span class="cov8" title="1">{
        _, e := addMembers.DoRequest(css, c.host, cnst.CentralRegion, &amp;addMembersArgs{
                Account:    account,
                NewMembers: newMembers,
        }, nil, nil)
        return e
}</span>

func (c *client) RemoveMembers(css *clientsession.Store, account id.Id, existingMembers []id.Id) error <span class="cov0" title="0">{
        _, e := removeMembers.DoRequest(css, c.host, cnst.CentralRegion, &amp;removeMembersArgs{
                Account:         account,
                ExistingMembers: existingMembers,
        }, nil, nil)
        return e
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package centralaccount

import (
        "github.com/0xor1/trees/server/util/ctx"
        "github.com/0xor1/trees/server/util/err"
        "github.com/0xor1/trees/server/util/id"
        "github.com/0xor1/trees/server/util/validate"
        "bytes"
        "github.com/0xor1/panic"
        "net/http"
        "strings"
        "unicode/utf8"
)

func dbAccountWithCiNameExists(ctx ctx.Ctx, name string) bool <span class="cov8" title="1">{
        row := ctx.AccountQueryRow(`SELECT COUNT(*) FROM accounts WHERE name = ?`, name)
        count := 0
        panic.IfNotNil(row.Scan(&amp;count))
        return count != 0
}</span>

func dbGetAccountByCiName(ctx ctx.Ctx, name string) *Account <span class="cov8" title="1">{
        row := ctx.AccountQueryRow(`SELECT id, name, displayName, createdOn, region, newRegion, shard, hasAvatar, isPersonal FROM accounts WHERE name = ?`, name)
        acc := Account{}
        if err.IsSqlErrNoRowsElsePanicIf(row.Scan(&amp;acc.Id, &amp;acc.Name, &amp;acc.DisplayName, &amp;acc.CreatedOn, &amp;acc.Region, &amp;acc.NewRegion, &amp;acc.Shard, &amp;acc.HasAvatar, &amp;acc.IsPersonal)) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;acc</span>
}

func dbCreatePersonalAccount(ctx ctx.Ctx, account *fullPersonalAccountInfo, pwdInfo *pwdInfo) <span class="cov8" title="1">{
        _, e := ctx.AccountExec(`CALL createPersonalAccount(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`, account.Id, account.Name, account.DisplayName, account.CreatedOn, account.Region, account.NewRegion, account.Shard, account.HasAvatar, account.Email, account.Language, account.Theme, account.NewEmail, account.activationCode, account.activatedOn, account.newEmailConfirmationCode, account.resetPwdCode)
        panic.IfNotNil(e)
        _, e = ctx.PwdExec(`INSERT INTO pwds (id, salt, pwd, n, r, p, keyLen) VALUES (?, ?, ?, ?, ?, ?, ?)`, account.Id, pwdInfo.salt, pwdInfo.pwd, pwdInfo.n, pwdInfo.r, pwdInfo.p, pwdInfo.keyLen)
        panic.IfNotNil(e)
}</span>

func dbGetPersonalAccountByEmail(ctx ctx.Ctx, email string) *fullPersonalAccountInfo <span class="cov8" title="1">{
        row := ctx.AccountQueryRow(`SELECT a.id, a.name, a.displayName, a.createdOn, a.region, a.newRegion, a.shard, a.hasAvatar, p.email, p.language, p.theme, p.newEmail, p.activationCode, p.activatedOn, p.newEmailConfirmationCode, p.resetPwdCode FROM accounts a, personalAccounts p WHERE a.id = (SELECT id FROM personalAccounts WHERE email = ?) AND p.email = ?`, email, email)
        account := fullPersonalAccountInfo{}
        account.IsPersonal = true
        if err.IsSqlErrNoRowsElsePanicIf(row.Scan(&amp;account.Id, &amp;account.Name, &amp;account.DisplayName, &amp;account.CreatedOn, &amp;account.Region, &amp;account.NewRegion, &amp;account.Shard, &amp;account.HasAvatar, &amp;account.Email, &amp;account.Language, &amp;account.Theme, &amp;account.NewEmail, &amp;account.activationCode, &amp;account.activatedOn, &amp;account.newEmailConfirmationCode, &amp;account.resetPwdCode)) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;account</span>
}

func dbGetPersonalAccountById(ctx ctx.Ctx, id id.Id) *fullPersonalAccountInfo <span class="cov8" title="1">{
        row := ctx.AccountQueryRow(`SELECT a.id, a.name, a.displayName, a.createdOn, a.region, a.newRegion, a.shard, a.hasAvatar, p.email, p.language, p.theme, p.newEmail, p.activationCode, p.activatedOn, p.newEmailConfirmationCode, p.resetPwdCode FROM accounts a, personalAccounts p WHERE a.id = ? AND p.id = ?`, id, id)
        account := fullPersonalAccountInfo{}
        account.IsPersonal = true
        if err.IsSqlErrNoRowsElsePanicIf(row.Scan(&amp;account.Id, &amp;account.Name, &amp;account.DisplayName, &amp;account.CreatedOn, &amp;account.Region, &amp;account.NewRegion, &amp;account.Shard, &amp;account.HasAvatar, &amp;account.Email, &amp;account.Language, &amp;account.Theme, &amp;account.NewEmail, &amp;account.activationCode, &amp;account.activatedOn, &amp;account.newEmailConfirmationCode, &amp;account.resetPwdCode)) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;account</span>
}

func dbGetPwdInfo(ctx ctx.Ctx, id id.Id) *pwdInfo <span class="cov8" title="1">{
        row := ctx.PwdQueryRow(`SELECT salt, pwd, n, r, p, keyLen FROM pwds WHERE id = ?`, id)
        pwd := pwdInfo{}
        if err.IsSqlErrNoRowsElsePanicIf(row.Scan(&amp;pwd.salt, &amp;pwd.pwd, &amp;pwd.n, &amp;pwd.r, &amp;pwd.p, &amp;pwd.keyLen)) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;pwd</span>
}

func dbUpdatePersonalAccount(ctx ctx.Ctx, personalAccountInfo *fullPersonalAccountInfo) <span class="cov8" title="1">{
        _, e := ctx.AccountExec(`CALL updatePersonalAccount(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`, personalAccountInfo.Id, personalAccountInfo.Name, personalAccountInfo.DisplayName, personalAccountInfo.CreatedOn, personalAccountInfo.Region, personalAccountInfo.NewRegion, personalAccountInfo.Shard, personalAccountInfo.HasAvatar, personalAccountInfo.Email, personalAccountInfo.Language, personalAccountInfo.Theme, personalAccountInfo.NewEmail, personalAccountInfo.activationCode, personalAccountInfo.activatedOn, personalAccountInfo.newEmailConfirmationCode, personalAccountInfo.resetPwdCode)
        panic.IfNotNil(e)
}</span>

func dbUpdateAccount(ctx ctx.Ctx, account *Account) <span class="cov8" title="1">{
        _, e := ctx.AccountExec(`CALL updateAccountInfo(?, ?, ?, ?, ?, ?, ?, ?, ?)`, account.Id, account.Name, account.DisplayName, account.CreatedOn, account.Region, account.NewRegion, account.Shard, account.HasAvatar, account.IsPersonal)
        panic.IfNotNil(e)
}</span>

func dbUpdatePwdInfo(ctx ctx.Ctx, id id.Id, pwdInfo *pwdInfo) <span class="cov8" title="1">{
        _, e := ctx.PwdExec(`UPDATE pwds SET salt=?, pwd=?, n=?, r=?, p=?, keyLen=? WHERE id = ?`, pwdInfo.salt, pwdInfo.pwd, pwdInfo.n, pwdInfo.r, pwdInfo.p, pwdInfo.keyLen, id)
        panic.IfNotNil(e)
}</span>

func dbDeleteAccountAndAllAssociatedMemberships(ctx ctx.Ctx, id id.Id) <span class="cov8" title="1">{
        _, e := ctx.AccountExec(`CALL deleteAccountAndAllAssociatedMemberships(?)`, id)
        panic.IfNotNil(e)
        _, e = ctx.PwdExec(`DELETE FROM pwds WHERE id = ?`, id)
        panic.IfNotNil(e)
}</span>

func dbGetAccount(ctx ctx.Ctx, id id.Id) *Account <span class="cov8" title="1">{
        row := ctx.AccountQueryRow(`SELECT id, name, displayName, createdOn, region, newRegion, shard, hasAvatar, isPersonal FROM accounts WHERE id = ?`, id)
        a := Account{}
        if err.IsSqlErrNoRowsElsePanicIf(row.Scan(&amp;a.Id, &amp;a.Name, &amp;a.DisplayName, &amp;a.CreatedOn, &amp;a.Region, &amp;a.NewRegion, &amp;a.Shard, &amp;a.HasAvatar, &amp;a.IsPersonal)) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;a</span>
}

func dbGetAccounts(ctx ctx.Ctx, ids []id.Id) []*Account <span class="cov8" title="1">{
        args := make([]interface{}, 0, len(ids))
        args = append(args, ids[0])
        query := bytes.NewBufferString(`SELECT id, name, displayName, createdOn, region, newRegion, shard, hasAvatar, isPersonal FROM accounts WHERE id IN (?`)
        for _, i := range ids[1:] </span><span class="cov0" title="0">{
                query.WriteString(`,?`)
                args = append(args, i)
        }</span>
        <span class="cov8" title="1">query.WriteString(`)`)
        rows, e := ctx.AccountQuery(query.String(), args...)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.IfNotNil(e)
        res := make([]*Account, 0, len(ids))
        for rows.Next() </span><span class="cov8" title="1">{
                a := Account{}
                panic.IfNotNil(rows.Scan(&amp;a.Id, &amp;a.Name, &amp;a.DisplayName, &amp;a.CreatedOn, &amp;a.Region, &amp;a.NewRegion, &amp;a.Shard, &amp;a.HasAvatar, &amp;a.IsPersonal))
                res = append(res, &amp;a)
        }</span>
        <span class="cov8" title="1">return res</span>
}

func dbSearchAccounts(ctx ctx.Ctx, nameOrDisplayNamePrefix string) []*Account <span class="cov8" title="1">{
        nameOrDisplayNamePrefix = strings.Trim(nameOrDisplayNamePrefix, " ")
        validate.StringArg("nameOrDisplayNamePrefix", nameOrDisplayNamePrefix, ctx.DisplayNameMinRuneCount(), ctx.DisplayNameMaxRuneCount(), ctx.DisplayNameRegexMatchers())
        ctx.ReturnNowIf(utf8.RuneCountInString(nameOrDisplayNamePrefix) &lt; 3, http.StatusBadRequest, "nameOrDisplayNamePrefix must be &gt;= 3 runes long and can not contain '%'")
        searchTerm := nameOrDisplayNamePrefix + "%"
        //rows, err := ctx.AccountQuery(`SELECT DISTINCT a.id, a.name, a.displayName, a.createdOn, a.region, a.newRegion, a.shard, a.hasAvatar, a.isPersonal FROM ((SELECT id, name, displayName, createdOn, region, newRegion, shard, hasAvatar, isPersonal FROM accounts WHERE name LIKE ? ORDER BY name ASC LIMIT ?, ?) UNION (SELECT id, name, displayName, createdOn, region, newRegion, shard, hasAvatar, isPersonal FROM accounts WHERE displayName LIKE ? ORDER BY name ASC LIMIT ?, ?)) AS a ORDER BY name ASC LIMIT ?, ?`, searchTerm, 0, 100, searchTerm, 0, 100, 0, 100)
        //TODO need to profile these queries to check for best performance
        rows, e := ctx.AccountQuery(`SELECT id, name, displayName, createdOn, region, newRegion, shard, hasAvatar, isPersonal FROM accounts WHERE name LIKE ? OR displayName LIKE ? ORDER BY name ASC LIMIT ?, ?`, searchTerm, searchTerm, 0, 100)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.IfNotNil(e)

        res := make([]*Account, 0, 100)
        for rows.Next() </span><span class="cov8" title="1">{
                acc := Account{}
                panic.IfNotNil(rows.Scan(&amp;acc.Id, &amp;acc.Name, &amp;acc.DisplayName, &amp;acc.CreatedOn, &amp;acc.Region, &amp;acc.NewRegion, &amp;acc.Shard, &amp;acc.HasAvatar, &amp;acc.IsPersonal))
                res = append(res, &amp;acc)
        }</span>
        <span class="cov8" title="1">return res</span>
}

func dbSearchPersonalAccounts(ctx ctx.Ctx, nameOrDisplayNamePrefix string) []*Account <span class="cov8" title="1">{
        nameOrDisplayNamePrefix = strings.Trim(nameOrDisplayNamePrefix, " ")
        validate.StringArg("nameOrDisplayNamePrefix", nameOrDisplayNamePrefix, ctx.DisplayNameMinRuneCount(), ctx.DisplayNameMaxRuneCount(), ctx.DisplayNameRegexMatchers())
        ctx.ReturnNowIf(utf8.RuneCountInString(nameOrDisplayNamePrefix) &lt; 3, http.StatusBadRequest, "nameOrDisplayNamePrefix must be &gt;= 3 runes long and can not contain '%'")
        //rows, e := ctx.AccountQuery(`SELECT id, name, displayName, createdOn, region, newRegion, shard, hasAvatar FROM accounts WHERE isPersonal=TRUE AND name LIKE ? OR displayName LIKE ? ORDER BY name ASC LIMIT ?`, searchTerm, searchTerm, 100)
        //TODO need to profile these queries to check for best performance
        searchTerm := nameOrDisplayNamePrefix + "%"
        rows, e := ctx.AccountQuery(`SELECT DISTINCT a.id, a.name, a.displayName, a.createdOn, a.region, a.newRegion, a.shard, a.hasAvatar FROM ((SELECT id, name, displayName, createdOn, region, newRegion, shard, hasAvatar FROM accounts WHERE isPersonal=TRUE AND name LIKE ? ORDER BY name ASC LIMIT ?) UNION (SELECT id, name, displayName, createdOn, region, newRegion, shard, hasAvatar FROM accounts WHERE isPersonal=TRUE AND displayName LIKE ? ORDER BY name ASC LIMIT ?)) AS a ORDER BY name ASC LIMIT ?`, searchTerm, 100, searchTerm, 100, 100)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.IfNotNil(e)

        res := make([]*Account, 0, 100)
        for rows.Next() </span><span class="cov8" title="1">{
                acc := Account{}
                acc.IsPersonal = true
                panic.IfNotNil(rows.Scan(&amp;acc.Id, &amp;acc.Name, &amp;acc.DisplayName, &amp;acc.CreatedOn, &amp;acc.Region, &amp;acc.NewRegion, &amp;acc.Shard, &amp;acc.HasAvatar))
                res = append(res, &amp;acc)
        }</span>
        <span class="cov8" title="1">return res</span>
}

func dbGetPersonalAccounts(ctx ctx.Ctx, ids []id.Id) []*Account <span class="cov8" title="1">{
        args := make([]interface{}, 0, len(ids))
        args = append(args, ids[0])
        query := bytes.NewBufferString(` SELECT id, name, displayName, createdOn, region, newRegion, shard, hasAvatar FROM accounts WHERE id IN (SELECT id FROM personalAccounts WHERE id IN (?`)
        for _, i := range ids[1:] </span><span class="cov8" title="1">{
                query.WriteString(`,?`)
                args = append(args, i)
        }</span>
        <span class="cov8" title="1">query.WriteString(`) AND activatedOn IS NOT NULL)`)
        rows, e := ctx.AccountQuery(query.String(), args...)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.IfNotNil(e)
        res := make([]*Account, 0, len(ids))
        for rows.Next() </span><span class="cov8" title="1">{
                acc := Account{}
                acc.IsPersonal = true
                panic.IfNotNil(rows.Scan(&amp;acc.Id, &amp;acc.Name, &amp;acc.DisplayName, &amp;acc.CreatedOn, &amp;acc.Region, &amp;acc.NewRegion, &amp;acc.Shard, &amp;acc.HasAvatar))
                res = append(res, &amp;acc)
        }</span>
        <span class="cov8" title="1">return res</span>
}

func dbCreateGroupAccountAndMembership(ctx ctx.Ctx, account *Account, member id.Id) <span class="cov8" title="1">{
        _, e := ctx.AccountExec(`CALL  createGroupAccountAndMembership(?, ?, ?, ?, ?, ?, ?, ?, ?)`, account.Id, account.Name, account.DisplayName, account.CreatedOn, account.Region, account.NewRegion, account.Shard, account.HasAvatar, member)
        panic.IfNotNil(e)
}</span>

func dbGetGroupAccounts(ctx ctx.Ctx, member id.Id, after *id.Id, limit int) ([]*Account, bool) <span class="cov8" title="1">{
        args := make([]interface{}, 0, 3)
        query := bytes.NewBufferString(`SELECT id, name, displayName, createdOn, region, newRegion, shard, hasAvatar, isPersonal FROM accounts WHERE id IN (SELECT account FROM memberships WHERE member = ?)`)
        args = append(args, member)
        if after != nil </span><span class="cov8" title="1">{
                query.WriteString(` AND name &gt; (SELECT name FROM accounts WHERE id = ?)`)
                args = append(args, *after)
        }</span>
        <span class="cov8" title="1">query.WriteString(` ORDER BY name ASC LIMIT ?`)
        args = append(args, limit+1)
        rows, e := ctx.AccountQuery(query.String(), args...)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.IfNotNil(e)
        res := make([]*Account, 0, limit+1)
        for rows.Next() </span><span class="cov8" title="1">{
                a := Account{}
                panic.IfNotNil(rows.Scan(&amp;a.Id, &amp;a.Name, &amp;a.DisplayName, &amp;a.CreatedOn, &amp;a.Region, &amp;a.NewRegion, &amp;a.Shard, &amp;a.HasAvatar, &amp;a.IsPersonal))
                res = append(res, &amp;a)
        }</span>
        <span class="cov8" title="1">if len(res) == limit+1 </span><span class="cov8" title="1">{
                return res[:limit], true
        }</span>
        <span class="cov8" title="1">return res, false</span>
}

func dbCreateMemberships(ctx ctx.Ctx, account id.Id, members []id.Id) <span class="cov8" title="1">{
        args := make([]interface{}, 0, len(members)*2)
        args = append(args, account, members[0])
        query := bytes.NewBufferString(`INSERT INTO memberships (account, member) VALUES (?,?)`)
        for _, member := range members[1:] </span><span class="cov8" title="1">{
                query.WriteString(`,(?,?)`)
                args = append(args, account, member)
        }</span>
        <span class="cov8" title="1">_, e := ctx.AccountExec(query.String(), args...)
        panic.IfNotNil(e)</span>
}

func dbDeleteMemberships(ctx ctx.Ctx, account id.Id, members []id.Id) <span class="cov0" title="0">{
        args := make([]interface{}, 0, len(members)+1)
        args = append(args, account, members[0])
        query := bytes.NewBufferString(`DELETE FROM memberships WHERE account=? AND member IN (?`)
        for _, member := range members[1:] </span><span class="cov0" title="0">{
                query.WriteString(`,?`)
                args = append(args, member)
        }</span>
        <span class="cov0" title="0">query.WriteString(`)`)
        _, e := ctx.AccountExec(query.String(), args...)
        panic.IfNotNil(e)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package centralaccount

import (
        "github.com/0xor1/trees/server/util/ctx"
        "fmt"
)

func emailSendMultipleAccountPolicyNotice(ctx ctx.Ctx, address string) <span class="cov0" title="0">{
        ctx.MailClient().Send([]string{address}, "sendMultipleAccountPolicyNotice")
}</span>

func emailSendActivationLink(ctx ctx.Ctx, address, activationCode string) <span class="cov8" title="1">{
        ctx.MailClient().Send([]string{address}, fmt.Sprintf(`&lt;a href="%s%s/#/activate/%s?email=%s"&gt;Confirm EMail&lt;/a&gt;`, ctx.ClientScheme(), ctx.ClientHost(), activationCode, address))
}</span>

func emailSendPwdResetLink(ctx ctx.Ctx, address, resetCode string) <span class="cov8" title="1">{
        ctx.MailClient().Send([]string{address}, fmt.Sprintf("sendPwdResetLink: resetCode: %s", resetCode))
}</span>

func emailSendNewEmailConfirmationLink(ctx ctx.Ctx, currentAddress, newAddress, confirmationCode string) <span class="cov8" title="1">{
        ctx.MailClient().Send([]string{newAddress}, fmt.Sprintf("sendNewEmailConfirmationLink: currentAddress: %s newAddress: %s confirmationCode: %s", currentAddress, newAddress, confirmationCode))
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package centralaccount

import (
        "github.com/0xor1/trees/server/util/cnst"
        "github.com/0xor1/trees/server/util/crypt"
        "github.com/0xor1/trees/server/util/ctx"
        "github.com/0xor1/trees/server/util/endpoint"
        "github.com/0xor1/trees/server/util/id"
        "github.com/0xor1/trees/server/util/private"
        t "github.com/0xor1/trees/server/util/time"
        "github.com/0xor1/trees/server/util/validate"
        "bytes"
        "github.com/0xor1/panic"
        "github.com/nfnt/resize"
        "image"
        _ "image/gif"
        _ "image/jpeg"
        "image/png"
        "io"
        "net/http"
        "regexp"
        "strings"
        "time"
)

var spacesRegex = regexp.MustCompile(`\s+`)

//endpoints

type registerArgs struct {
        Name        string      `json:"name"`
        Email       string      `json:"email"`
        Pwd         string      `json:"pwd"`
        Region      cnst.Region `json:"region"`
        Language    string      `json:"language"`
        DisplayName *string     `json:"displayName"`
        Theme       cnst.Theme  `json:"theme"`
}

var register = &amp;endpoint.Endpoint{
        Path:            "/api/v1/centralAccount/register",
        RequiresSession: false,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;registerArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*registerArgs)
                args.Name = strings.Trim(args.Name, " ")
                validate.StringArg("name", args.Name, ctx.NameMinRuneCount(), ctx.NameMaxRuneCount(), ctx.NameRegexMatchers())
                args.Email = strings.Trim(args.Email, " ")
                validate.Email(args.Email)
                validate.StringArg("pwd", args.Pwd, ctx.PwdMinRuneCount(), ctx.PwdMaxRuneCount(), ctx.PwdRegexMatchers())
                args.Language = strings.Trim(args.Language, " ") // may need more validation than this at some point to check it is a language we support and not a junk value, but it isnt critical right now
                args.Theme.Validate()
                if args.DisplayName != nil </span><span class="cov8" title="1">{
                        *args.DisplayName = spacesRegex.ReplaceAllString(*args.DisplayName, " ") //replace any multiple spaces with a single space
                        *args.DisplayName = strings.Trim(*args.DisplayName, " ")
                        if *args.DisplayName == "" </span><span class="cov0" title="0">{
                                args.DisplayName = nil
                        }</span>
                        <span class="cov8" title="1">if args.DisplayName != nil </span><span class="cov8" title="1">{
                                validate.StringArg("displayName", *args.DisplayName, ctx.DisplayNameMinRuneCount(), ctx.DisplayNameMaxRuneCount(), ctx.DisplayNameRegexMatchers())
                        }</span>
                }

                <span class="cov8" title="1">args.Region.ValidateForDataRegions()
                ctx.ReturnNowIf(dbAccountWithCiNameExists(ctx, args.Name), http.StatusBadRequest, "name already in use")

                if acc := dbGetPersonalAccountByEmail(ctx, args.Email); acc != nil </span><span class="cov0" title="0">{
                        emailSendMultipleAccountPolicyNotice(ctx, acc.Email)
                }</span>

                <span class="cov8" title="1">activationCode := crypt.UrlSafeString(ctx.CryptCodeLen())
                acc := &amp;fullPersonalAccountInfo{}
                acc.Id = id.New()
                acc.Name = args.Name
                acc.DisplayName = args.DisplayName
                acc.CreatedOn = t.Now()
                acc.Region = args.Region

                defer func() </span><span class="cov8" title="1">{
                        r := recover()
                        if r != nil </span><span class="cov0" title="0">{
                                dbDeleteAccountAndAllAssociatedMemberships(ctx, acc.Id)
                                if e, ok := r.(error); ok </span><span class="cov0" title="0">{
                                        panic.IfNotNil(e)
                                }</span>
                                <span class="cov0" title="0">panic.If(true, "%v", r)</span>
                        }
                }()
                <span class="cov8" title="1">var e error
                acc.Shard, e = ctx.RegionalV1PrivateClient().CreateAccount(acc.Region, acc.Id, acc.Id, acc.Name, acc.DisplayName, acc.HasAvatar)
                panic.IfNotNil(e)
                acc.IsPersonal = true
                acc.Email = args.Email
                acc.Language = args.Language
                acc.Theme = args.Theme
                acc.activationCode = &amp;activationCode

                pwdInfo := &amp;pwdInfo{}
                pwdInfo.salt = crypt.Bytes(ctx.SaltLen())
                pwdInfo.pwd = crypt.ScryptKey([]byte(args.Pwd), pwdInfo.salt, ctx.ScryptN(), ctx.ScryptR(), ctx.ScryptP(), ctx.ScryptKeyLen())
                pwdInfo.n = ctx.ScryptN()
                pwdInfo.r = ctx.ScryptR()
                pwdInfo.p = ctx.ScryptP()
                pwdInfo.keyLen = ctx.ScryptKeyLen()

                dbCreatePersonalAccount(ctx, acc, pwdInfo)

                emailSendActivationLink(ctx, args.Email, *acc.activationCode)
                return nil</span>
        },
}

type resendActivationEmailArgs struct {
        Email string `json:"email"`
}

var resendActivationEmail = &amp;endpoint.Endpoint{
        Path:            "/api/v1/centralAccount/resendActivationEmail",
        RequiresSession: false,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;resendActivationEmailArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*resendActivationEmailArgs)
                args.Email = strings.Trim(args.Email, " ")
                acc := dbGetPersonalAccountByEmail(ctx, args.Email)
                if acc == nil || acc.isActivated() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">emailSendActivationLink(ctx, args.Email, *acc.activationCode)
                return nil</span>
        },
}

type activateArgs struct {
        Email          string `json:"email"`
        ActivationCode string `json:"activationCode"`
}

var activate = &amp;endpoint.Endpoint{
        Path:            "/api/v1/centralAccount/activate",
        RequiresSession: false,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;activateArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*activateArgs)
                args.ActivationCode = strings.Trim(args.ActivationCode, " ")
                acc := dbGetPersonalAccountByEmail(ctx, args.Email)
                ctx.ReturnBadRequestNowIf(acc == nil || acc.activationCode == nil || args.ActivationCode != *acc.activationCode, "invalid activation attempt")
                acc.activationCode = nil
                activationTime := t.Now()
                acc.activatedOn = &amp;activationTime
                dbUpdatePersonalAccount(ctx, acc)
                return nil
        }</span>,
}

type authenticateArgs struct {
        Email  string `json:"email"`
        PwdTry string `json:"pwdTry"`
}

type AuthenticateResult struct {
        Me         *Me                  `json:"me"`
        MyAccounts *GetMyAccountsResult `json:"myAccounts"`
}

func (ar *AuthenticateResult) Id() id.Id <span class="cov8" title="1">{
        return ar.Me.Id
}</span>

var authenticate = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/centralAccount/authenticate",
        RequiresSession:          false,
        ExampleResponseStructure: &amp;Me{},
        IsAuthentication:         true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;authenticateArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*authenticateArgs)
                args.Email = strings.Trim(args.Email, " ")
                acc := dbGetPersonalAccountByEmail(ctx, args.Email)
                ctx.ReturnBadRequestNowIf(acc == nil, "invalid name or password")

                pwdInfo := dbGetPwdInfo(ctx, acc.Id)
                scryptPwdTry := crypt.ScryptKey([]byte(args.PwdTry), pwdInfo.salt, pwdInfo.n, pwdInfo.r, pwdInfo.p, pwdInfo.keyLen)
                ctx.ReturnNowIf(!pwdsMatch(pwdInfo.pwd, scryptPwdTry), http.StatusBadRequest, "invalid name or password")

                //must do this after checking the acc has the correct pwd otherwise it allows anyone to fish for valid emails on the system
                ctx.ReturnNowIf(!acc.isActivated(), http.StatusBadRequest, "account is not activated, confirm email address")

                //if there was an outstanding password reset on this acc, remove it, they have since remembered their password
                if acc.resetPwdCode != nil &amp;&amp; len(*acc.resetPwdCode) &gt; 0 </span><span class="cov0" title="0">{
                        acc.resetPwdCode = nil
                        dbUpdatePersonalAccount(ctx, acc)
                }</span>
                // check that the password is encrypted with the latest scrypt settings, if not, encrypt again using the latest settings
                <span class="cov8" title="1">if pwdInfo.n != ctx.ScryptN() || pwdInfo.r != ctx.ScryptR() || pwdInfo.p != ctx.ScryptP() || pwdInfo.keyLen != ctx.ScryptKeyLen() || len(pwdInfo.salt) != ctx.SaltLen() </span><span class="cov0" title="0">{
                        pwdInfo.salt = crypt.Bytes(ctx.SaltLen())
                        pwdInfo.n = ctx.ScryptN()
                        pwdInfo.r = ctx.ScryptR()
                        pwdInfo.p = ctx.ScryptP()
                        pwdInfo.keyLen = ctx.ScryptKeyLen()
                        pwdInfo.pwd = crypt.ScryptKey([]byte(args.PwdTry), pwdInfo.salt, pwdInfo.n, pwdInfo.r, pwdInfo.p, pwdInfo.keyLen)
                        dbUpdatePwdInfo(ctx, acc.Id, pwdInfo)
                }</span>

                <span class="cov8" title="1">myAccounts, more := dbGetGroupAccounts(ctx, acc.Id, nil, 100)
                return &amp;AuthenticateResult{
                        Me: &amp;acc.Me,
                        MyAccounts: &amp;GetMyAccountsResult{
                                Accounts: myAccounts,
                                More:     more,
                        },
                }</span>
        },
}

type confirmNewEmailArgs struct {
        CurrentEmail     string `json:"currentEmail"`
        NewEmail         string `json:"newEmail"`
        ConfirmationCode string `json:"confirmationCode"`
}

var confirmNewEmail = &amp;endpoint.Endpoint{
        Path:            "/api/v1/centralAccount/confirmNewEmail",
        RequiresSession: false,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;confirmNewEmailArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*confirmNewEmailArgs)
                acc := dbGetPersonalAccountByEmail(ctx, args.CurrentEmail)
                ctx.ReturnBadRequestNowIf(acc == nil || acc.NewEmail == nil || args.NewEmail != *acc.NewEmail || acc.newEmailConfirmationCode == nil || args.ConfirmationCode != *acc.newEmailConfirmationCode, "invalid email confirmation attempt")

                newAcc := dbGetPersonalAccountByEmail(ctx, args.NewEmail)
                ctx.ReturnBadRequestNowIf(newAcc != nil, "email already in use")

                acc.Email = args.NewEmail
                acc.NewEmail = nil
                acc.newEmailConfirmationCode = nil
                dbUpdatePersonalAccount(ctx, acc)
                return nil
        }</span>,
}

type resetPwdArgs struct {
        Email string `json:"email"`
}

var resetPwd = &amp;endpoint.Endpoint{
        Path:            "/api/v1/centralAccount/resetPwd",
        RequiresSession: false,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;resetPwdArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*resetPwdArgs)
                args.Email = strings.Trim(args.Email, " ")
                acc := dbGetPersonalAccountByEmail(ctx, args.Email)
                if acc == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">resetPwdCode := crypt.UrlSafeString(ctx.CryptCodeLen())

                acc.resetPwdCode = &amp;resetPwdCode
                dbUpdatePersonalAccount(ctx, acc)

                emailSendPwdResetLink(ctx, args.Email, resetPwdCode)
                return nil</span>
        },
}

type setNewPwdFromPwdResetArgs struct {
        Email        string `json:"email"`
        ResetPwdCode string `json:"resetCode"`
        NewPwd       string `json:"newPwd"`
}

var setNewPwdFromPwdReset = &amp;endpoint.Endpoint{
        Path:            "/api/v1/centralAccount/setNewPwdFromPwdReset",
        RequiresSession: false,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setNewPwdFromPwdResetArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setNewPwdFromPwdResetArgs)
                validate.StringArg("pwd", args.NewPwd, ctx.PwdMinRuneCount(), ctx.PwdMaxRuneCount(), ctx.PwdRegexMatchers())

                acc := dbGetPersonalAccountByEmail(ctx, args.Email)
                ctx.ReturnBadRequestNowIf(acc == nil || acc.resetPwdCode == nil || args.ResetPwdCode != *acc.resetPwdCode, "invalid reset password attempt")

                scryptSalt := crypt.Bytes(ctx.SaltLen())
                scryptPwd := crypt.ScryptKey([]byte(args.NewPwd), scryptSalt, ctx.ScryptN(), ctx.ScryptR(), ctx.ScryptP(), ctx.ScryptKeyLen())

                acc.activationCode = nil
                acc.resetPwdCode = nil
                dbUpdatePersonalAccount(ctx, acc)

                pwdInfo := &amp;pwdInfo{}
                pwdInfo.pwd = scryptPwd
                pwdInfo.salt = scryptSalt
                pwdInfo.n = ctx.ScryptN()
                pwdInfo.r = ctx.ScryptR()
                pwdInfo.p = ctx.ScryptP()
                pwdInfo.keyLen = ctx.ScryptKeyLen()
                dbUpdatePwdInfo(ctx, acc.Id, pwdInfo)
                return nil
        }</span>,
}

type getAccountArgs struct {
        Name string `json:"name"`
}

var getAccount = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/centralAccount/getAccount",
        RequiresSession:          false,
        ExampleResponseStructure: &amp;Account{},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getAccountArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getAccountArgs)
                return dbGetAccountByCiName(ctx, strings.Trim(args.Name, " "))
        }</span>,
}

type getAccountsArgs struct {
        Accounts []id.Id `json:"accounts"`
}

var getAccounts = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/centralAccount/getAccounts",
        RequiresSession:          false,
        ExampleResponseStructure: []*Account{{}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getAccountsArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getAccountsArgs)
                validate.EntityCount(len(args.Accounts), ctx.MaxProcessEntityCount())

                return dbGetAccounts(ctx, args.Accounts)
        }</span>,
}

type searchAccountsArgs struct {
        NameOrDisplayNamePrefix string `json:"nameOrDisplayNamePrefix"`
}

var searchAccounts = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/centralAccount/searchAccounts",
        RequiresSession:          false,
        ExampleResponseStructure: []*Account{{}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;searchAccountsArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*searchAccountsArgs)
                return dbSearchAccounts(ctx, args.NameOrDisplayNamePrefix)
        }</span>,
}

type searchPersonalAccountsArgs struct {
        NameOrDisplayNamePrefix string `json:"nameOrDisplayNamePrefix"`
}

var searchPersonalAccounts = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/centralAccount/searchPersonalAccounts",
        RequiresSession:          false,
        ExampleResponseStructure: []*Account{{}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;searchPersonalAccountsArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*searchPersonalAccountsArgs)
                return dbSearchPersonalAccounts(ctx, args.NameOrDisplayNamePrefix)
        }</span>,
}

var getMe = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/centralAccount/getMe",
        RequiresSession:          true,
        ExampleResponseStructure: &amp;Me{},
        CtxHandler: func(ctx ctx.Ctx, _ interface{}) interface{} <span class="cov8" title="1">{
                acc := dbGetPersonalAccountById(ctx, ctx.Me())
                ctx.ReturnNowIf(acc == nil, http.StatusNotFound, "no such account")
                return &amp;acc.Me
        }</span>,
}

type setMyPwdArgs struct {
        NewPwd string `json:"newPwd"`
        OldPwd string `json:"oldPwd"`
}

var setMyPwd = &amp;endpoint.Endpoint{
        Path:            "/api/v1/centralAccount/setMyPwd",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setMyPwdArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setMyPwdArgs)
                validate.StringArg("pwd", args.NewPwd, ctx.PwdMinRuneCount(), ctx.PwdMaxRuneCount(), ctx.PwdRegexMatchers())

                pwdInfo := dbGetPwdInfo(ctx, ctx.Me())
                panic.If(pwdInfo == nil, "no such account")

                scryptPwdTry := crypt.ScryptKey([]byte(args.OldPwd), pwdInfo.salt, pwdInfo.n, pwdInfo.r, pwdInfo.p, pwdInfo.keyLen)

                ctx.ReturnNowIf(!pwdsMatch(pwdInfo.pwd, scryptPwdTry), http.StatusBadRequest, "password mismatch")

                pwdInfo.salt = crypt.Bytes(ctx.SaltLen())
                pwdInfo.pwd = crypt.ScryptKey([]byte(args.NewPwd), pwdInfo.salt, ctx.ScryptN(), ctx.ScryptR(), ctx.ScryptP(), ctx.ScryptKeyLen())
                pwdInfo.n = ctx.ScryptN()
                pwdInfo.r = ctx.ScryptR()
                pwdInfo.p = ctx.ScryptP()
                pwdInfo.keyLen = ctx.ScryptKeyLen()
                dbUpdatePwdInfo(ctx, ctx.Me(), pwdInfo)
                return nil
        }</span>,
}

type setMyEmailArgs struct {
        NewEmail string `json:"newEmail"`
}

var setMyEmail = &amp;endpoint.Endpoint{
        Path:            "/api/v1/centralAccount/setMyEmail",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setMyEmailArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setMyEmailArgs)
                args.NewEmail = strings.Trim(args.NewEmail, " ")
                validate.Email(args.NewEmail)

                if acc := dbGetPersonalAccountByEmail(ctx, args.NewEmail); acc != nil </span><span class="cov0" title="0">{
                        emailSendMultipleAccountPolicyNotice(ctx, acc.Email)
                }</span>

                <span class="cov8" title="1">acc := dbGetPersonalAccountById(ctx, ctx.Me())
                panic.If(acc == nil, "no such account")

                confirmationCode := crypt.UrlSafeString(ctx.CryptCodeLen())

                acc.NewEmail = &amp;args.NewEmail
                acc.newEmailConfirmationCode = &amp;confirmationCode
                dbUpdatePersonalAccount(ctx, acc)
                emailSendNewEmailConfirmationLink(ctx, acc.Email, args.NewEmail, confirmationCode)
                return nil</span>
        },
}

var resendMyNewEmailConfirmationEmail = &amp;endpoint.Endpoint{
        Path:            "/api/v1/centralAccount/resendMyNewEmailConfirmationEmail",
        RequiresSession: true,
        CtxHandler: func(ctx ctx.Ctx, _ interface{}) interface{} <span class="cov8" title="1">{
                acc := dbGetPersonalAccountById(ctx, ctx.Me())
                panic.If(acc == nil, "no such account")

                // check the acc has actually registered a new email
                ctx.ReturnBadRequestNowIf(acc.NewEmail == nil, "no new email registered")

                // just in case something has gone crazy wrong
                panic.If(acc.newEmailConfirmationCode == nil, "new email confirmation code is nil when new email was not nil")

                emailSendNewEmailConfirmationLink(ctx, acc.Email, *acc.NewEmail, *acc.newEmailConfirmationCode)
                return nil
        }</span>,
}

type setAccountNameArgs struct {
        Account id.Id  `json:"account"`
        NewName string `json:"newName"`
}

var setAccountName = &amp;endpoint.Endpoint{
        Path:            "/api/v1/centralAccount/setAccountName",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setAccountNameArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setAccountNameArgs)
                args.NewName = strings.Trim(args.NewName, " ")
                validate.StringArg("name", args.NewName, ctx.NameMinRuneCount(), ctx.NameMaxRuneCount(), ctx.NameRegexMatchers())

                ctx.ReturnNowIf(dbAccountWithCiNameExists(ctx, args.NewName), http.StatusBadRequest, "name already in use")

                acc := dbGetAccount(ctx, args.Account)
                ctx.ReturnBadRequestNowIf(acc == nil, "no such account")

                if !ctx.Me().Equal(args.Account) </span><span class="cov0" title="0">{
                        ctx.ReturnUnauthorizedNowIf(acc.IsPersonal) // can't rename someone else's personal account

                        isAccountOwner, e := ctx.RegionalV1PrivateClient().MemberIsAccountOwner(acc.Region, acc.Shard, args.Account, ctx.Me())
                        panic.IfNotNil(e)
                        ctx.ReturnUnauthorizedNowIf(!isAccountOwner)
                }</span>

                <span class="cov8" title="1">acc.Name = args.NewName
                dbUpdateAccount(ctx, acc)

                if ctx.Me().Equal(args.Account) </span><span class="cov8" title="1">{ // if i did rename my personal account, i need to update all the stored names in all the accounts Im a member of
                        var after *id.Id
                        privateClientCallBatch := make([]func(), 0, 10)
                        privateClientCallBatch = append(privateClientCallBatch, func(a *Account) func() </span><span class="cov8" title="1">{
                                return func() </span><span class="cov8" title="1">{
                                        ctx.RegionalV1PrivateClient().SetMemberName(a.Region, a.Shard, a.Id, ctx.Me(), args.NewName)
                                }</span>
                        }(acc))
                        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                                accs, more := dbGetGroupAccounts(ctx, ctx.Me(), after, 100)
                                for _, acc := range accs </span><span class="cov0" title="0">{
                                        privateClientCallBatch = append(privateClientCallBatch, func(a *Account) func() </span><span class="cov0" title="0">{
                                                return func() </span><span class="cov0" title="0">{
                                                        ctx.RegionalV1PrivateClient().SetMemberName(a.Region, a.Shard, a.Id, ctx.Me(), args.NewName)
                                                }</span>
                                        }(acc))
                                }
                                <span class="cov8" title="1">if more </span><span class="cov0" title="0">{
                                        after = &amp;accs[len(accs)-1].Id
                                }</span> else<span class="cov8" title="1"> {
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">panic.IfNotNil(panic.SafeGoGroup(privateClientCallBatch...))</span>
                }
                <span class="cov8" title="1">return nil</span>
        },
}

type setAccountDisplayNameArgs struct {
        Account        id.Id   `json:"account"`
        NewDisplayName *string `json:"newDisplayName"`
}

var setAccountDisplayName = &amp;endpoint.Endpoint{
        Path:            "/api/v1/centralAccount/setAccountDisplayName",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setAccountDisplayNameArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setAccountDisplayNameArgs)
                if args.NewDisplayName != nil </span><span class="cov8" title="1">{
                        *args.NewDisplayName = spacesRegex.ReplaceAllString(*args.NewDisplayName, " ") //replace any multiple spaces with a single space
                        *args.NewDisplayName = strings.Trim(*args.NewDisplayName, " ")
                        if *args.NewDisplayName == "" </span><span class="cov0" title="0">{
                                args.NewDisplayName = nil
                        }</span>
                        <span class="cov8" title="1">if args.NewDisplayName != nil </span><span class="cov8" title="1">{
                                validate.StringArg("displayName", *args.NewDisplayName, ctx.DisplayNameMinRuneCount(), ctx.DisplayNameMaxRuneCount(), ctx.DisplayNameRegexMatchers())
                        }</span>
                }

                <span class="cov8" title="1">acc := dbGetAccount(ctx, args.Account)
                ctx.ReturnBadRequestNowIf(acc == nil, "no such account")

                if !ctx.Me().Equal(args.Account) </span><span class="cov0" title="0">{
                        ctx.ReturnUnauthorizedNowIf(acc.IsPersonal) // can't rename someone else's personal account

                        isAccountOwner, e := ctx.RegionalV1PrivateClient().MemberIsAccountOwner(acc.Region, acc.Shard, args.Account, ctx.Me())
                        panic.IfNotNil(e)
                        ctx.ReturnUnauthorizedNowIf(!isAccountOwner)
                }</span>

                <span class="cov8" title="1">if (acc.DisplayName == nil &amp;&amp; args.NewDisplayName == nil) || (acc.DisplayName != nil &amp;&amp; args.NewDisplayName != nil &amp;&amp; *acc.DisplayName == *args.NewDisplayName) </span><span class="cov0" title="0">{
                        return nil //if there is no change, dont do any redundant work
                }</span>

                <span class="cov8" title="1">acc.DisplayName = args.NewDisplayName
                dbUpdateAccount(ctx, acc)

                if ctx.Me().Equal(args.Account) </span><span class="cov8" title="1">{ // if i did set my personal account displayName, i need to update all the stored displayNames in all the accounts Im a member of
                        var after *id.Id
                        privateClientCallBatch := make([]func(), 0, 10)
                        privateClientCallBatch = append(privateClientCallBatch, func(a *Account) func() </span><span class="cov8" title="1">{
                                return func() </span><span class="cov8" title="1">{
                                        ctx.RegionalV1PrivateClient().SetMemberDisplayName(a.Region, a.Shard, a.Id, ctx.Me(), args.NewDisplayName)
                                }</span>
                        }(acc))
                        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                                accs, more := dbGetGroupAccounts(ctx, ctx.Me(), after, 100)
                                for _, acc := range accs </span><span class="cov0" title="0">{
                                        privateClientCallBatch = append(privateClientCallBatch, func(a *Account) func() </span><span class="cov0" title="0">{
                                                return func() </span><span class="cov0" title="0">{
                                                        ctx.RegionalV1PrivateClient().SetMemberDisplayName(a.Region, a.Shard, a.Id, ctx.Me(), args.NewDisplayName)
                                                }</span>
                                        }(acc))
                                }
                                <span class="cov8" title="1">if more </span><span class="cov0" title="0">{
                                        after = &amp;accs[len(accs)-1].Id
                                }</span> else<span class="cov8" title="1"> {
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">panic.IfNotNil(panic.SafeGoGroup(privateClientCallBatch...))</span>
                }
                <span class="cov8" title="1">return nil</span>
        },
}

type setAccountAvatarArgs struct {
        Account id.Id         `json:"account"`
        Avatar  io.ReadCloser `json:"avatar"`
}

var setAccountAvatar = &amp;endpoint.Endpoint{
        Path:            "/api/v1/centralAccount/setAccountAvatar",
        RequiresSession: true,
        FormStruct: map[string]string{
                "account": "Id",
                "avatar":  "file (png, jpeg, gif)",
        },
        ProcessForm: func(w http.ResponseWriter, r *http.Request) interface{} <span class="cov8" title="1">{
                r.Body = http.MaxBytesReader(w, r.Body, 600000) //limit to 6kb
                f, _, err := r.FormFile("avatar")
                if err != nil </span><span class="cov0" title="0">{
                        f = nil
                }</span>
                <span class="cov8" title="1">return &amp;setAccountAvatarArgs{
                        Account: id.Parse(r.FormValue("account")),
                        Avatar:  f,
                }</span>
        },
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setAccountAvatarArgs)
                if args.Avatar != nil </span><span class="cov8" title="1">{
                        defer args.Avatar.Close()
                }</span>

                <span class="cov8" title="1">account := dbGetAccount(ctx, args.Account)
                ctx.ReturnBadRequestNowIf(account == nil, "no such account")

                if !ctx.Me().Equal(args.Account) </span><span class="cov0" title="0">{
                        ctx.ReturnUnauthorizedNowIf(account.IsPersonal) // can't set avatar on someone else's personal account

                        isAccountOwner, e := ctx.RegionalV1PrivateClient().MemberIsAccountOwner(account.Region, account.Shard, args.Account, ctx.Me())
                        panic.IfNotNil(e)
                        ctx.ReturnUnauthorizedNowIf(!isAccountOwner)
                }</span>

                <span class="cov8" title="1">hasAvatarStatusChanged := false
                if args.Avatar != nil </span><span class="cov8" title="1">{
                        avatarImage, _, e := image.Decode(args.Avatar)
                        panic.IfNotNil(e)
                        bounds := avatarImage.Bounds()
                        ctx.ReturnBadRequestNowIf(bounds.Max.X-bounds.Min.X != bounds.Max.Y-bounds.Min.Y, "invalid avatar shape, must be square") //if it  isn't square, then error
                        if uint(bounds.Max.X-bounds.Min.X) &gt; ctx.AvatarClient().MaxAvatarDim() </span><span class="cov8" title="1">{                                                  // if it is larger than allowed then resize
                                avatarImage = resize.Resize(ctx.AvatarClient().MaxAvatarDim(), ctx.AvatarClient().MaxAvatarDim(), avatarImage, resize.NearestNeighbor)
                        }</span>
                        <span class="cov8" title="1">buff := &amp;bytes.Buffer{}
                        panic.IfNotNil(png.Encode(buff, avatarImage))
                        data := buff.Bytes()
                        reader := bytes.NewReader(data)
                        ctx.AvatarClient().Save(ctx.Me().String(), "image/png", reader)
                        hasAvatarStatusChanged = !account.HasAvatar</span>
                } else<span class="cov0" title="0"> {
                        ctx.AvatarClient().Delete(ctx.Me().String())
                        hasAvatarStatusChanged = account.HasAvatar
                }</span>
                <span class="cov8" title="1">if hasAvatarStatusChanged </span><span class="cov8" title="1">{
                        account.HasAvatar = !account.HasAvatar
                        dbUpdateAccount(ctx, account)
                        if account.Id.Equal(ctx.Me()) </span><span class="cov8" title="1">{
                                var after *id.Id
                                privateClientCallBatch := make([]func(), 0, 10)
                                privateClientCallBatch = append(privateClientCallBatch, func(a *Account) func() </span><span class="cov8" title="1">{
                                        return func() </span><span class="cov8" title="1">{
                                                ctx.RegionalV1PrivateClient().SetMemberHasAvatar(a.Region, a.Shard, a.Id, ctx.Me(), account.HasAvatar)
                                        }</span>
                                }(account))
                                <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                                        accs, more := dbGetGroupAccounts(ctx, ctx.Me(), after, 100)
                                        for _, acc := range accs </span><span class="cov0" title="0">{
                                                privateClientCallBatch = append(privateClientCallBatch, func(a *Account) func() </span><span class="cov0" title="0">{
                                                        return func() </span><span class="cov0" title="0">{
                                                                ctx.RegionalV1PrivateClient().SetMemberHasAvatar(a.Region, a.Shard, a.Id, ctx.Me(), account.HasAvatar)
                                                        }</span>
                                                }(acc))
                                        }
                                        <span class="cov8" title="1">if more </span><span class="cov0" title="0">{
                                                after = &amp;accs[len(accs)-1].Id
                                        }</span> else<span class="cov8" title="1"> {
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">panic.IfNotNil(panic.SafeGoGroup(privateClientCallBatch...))</span>
                        }
                }
                <span class="cov8" title="1">return nil</span>
        },
}

type migrateAccountArgs struct {
        Account   id.Id       `json:"account"`
        NewRegion cnst.Region `json:"newRegion"`
}

var migrateAccount = &amp;endpoint.Endpoint{
        Path:            "/api/v1/centralAccount/migrateAccount",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;migrateAccountArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, _ interface{}) interface{} <span class="cov0" title="0">{
                ctx.ReturnBadRequestNowIf(true, "not implemented")
                return nil
        }</span>,
}

type createAccountArgs struct {
        Name        string      `json:"name"`
        Region      cnst.Region `json:"region"`
        DisplayName *string     `json:"displayName"`
}

var createAccount = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/centralAccount/createAccount",
        RequiresSession:          true,
        ExampleResponseStructure: &amp;Account{},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;createAccountArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*createAccountArgs)
                args.Name = strings.Trim(args.Name, " ")
                validate.StringArg("name", args.Name, ctx.NameMinRuneCount(), ctx.NameMaxRuneCount(), ctx.NameRegexMatchers())

                args.Region.ValidateForDataRegions()
                ctx.ReturnNowIf(dbAccountWithCiNameExists(ctx, args.Name), http.StatusBadRequest, "name already in use")

                account := &amp;Account{}
                account.Id = id.New()
                account.Name = args.Name
                account.DisplayName = args.DisplayName
                account.CreatedOn = t.Now()
                account.Region = args.Region
                account.Shard = -1
                account.IsPersonal = false
                dbCreateGroupAccountAndMembership(ctx, account, ctx.Me())

                owner := dbGetPersonalAccountById(ctx, ctx.Me())
                ctx.ReturnBadRequestNowIf(owner == nil, "no such account")

                defer func() </span><span class="cov8" title="1">{
                        r := recover()
                        if r != nil </span><span class="cov0" title="0">{
                                dbDeleteAccountAndAllAssociatedMemberships(ctx, account.Id)
                                if e, ok := r.(error); ok </span><span class="cov0" title="0">{
                                        panic.IfNotNil(e)
                                }</span>
                                <span class="cov0" title="0">panic.If(true, "%v", r)</span>
                        }
                }()
                <span class="cov8" title="1">shard, e := ctx.RegionalV1PrivateClient().CreateAccount(args.Region, account.Id, ctx.Me(), owner.Name, owner.DisplayName, owner.HasAvatar)
                panic.IfNotNil(e)

                account.Shard = shard
                dbUpdateAccount(ctx, account)
                return account</span>
        },
}

type getMyAccountsArgs struct {
        After *id.Id `json:"after"`
        Limit int    `json:"limit"`
}

type GetMyAccountsResult struct {
        Accounts []*Account `json:"accounts"`
        More     bool       `json:"more"`
}

var getMyAccounts = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/centralAccount/getMyAccounts",
        RequiresSession:          true,
        ExampleResponseStructure: &amp;GetMyAccountsResult{Accounts: []*Account{{}}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getMyAccountsArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getMyAccountsArgs)
                res := &amp;GetMyAccountsResult{}
                res.Accounts, res.More = dbGetGroupAccounts(ctx, ctx.Me(), args.After, validate.Limit(args.Limit, ctx.MaxProcessEntityCount()))
                return res
        }</span>,
}

type deleteAccountArgs struct {
        Account id.Id `json:"account"`
}

var deleteAccount = &amp;endpoint.Endpoint{
        Path:            "/api/v1/centralAccount/deleteAccount",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;deleteAccountArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*deleteAccountArgs)
                acc := dbGetAccount(ctx, args.Account)
                ctx.ReturnBadRequestNowIf(acc == nil, "no such account")

                if !ctx.Me().Equal(args.Account) </span><span class="cov8" title="1">{
                        ctx.ReturnUnauthorizedNowIf(acc.IsPersonal) // can't delete someone else's personal account

                        //otherwise attempting to delete a group account
                        isAccountOwner, e := ctx.RegionalV1PrivateClient().MemberIsAccountOwner(acc.Region, acc.Shard, args.Account, ctx.Me())
                        panic.IfNotNil(e)
                        ctx.ReturnUnauthorizedNowIf(!isAccountOwner)

                        ctx.RegionalV1PrivateClient().DeleteAccount(acc.Region, acc.Shard, args.Account, ctx.Me())
                }</span> else<span class="cov8" title="1"> {
                        var after *id.Id
                        privateClientCallBatch := make([]func(), 0, 10)
                        privateClientCallBatch = append(privateClientCallBatch, func(a *Account) func() </span><span class="cov8" title="1">{
                                return func() </span><span class="cov8" title="1">{
                                        panic.IfNotNil(ctx.RegionalV1PrivateClient().DeleteAccount(a.Region, a.Shard, a.Id, ctx.Me()))
                                }</span>
                        }(acc))
                        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                                accs, more := dbGetGroupAccounts(ctx, ctx.Me(), after, 100)
                                for _, acc := range accs </span><span class="cov0" title="0">{
                                        privateClientCallBatch = append(privateClientCallBatch, func(a *Account) func() </span><span class="cov0" title="0">{
                                                return func() </span><span class="cov0" title="0">{
                                                        isOnlyAccountOwner, e := ctx.RegionalV1PrivateClient().MemberIsOnlyAccountOwner(a.Region, a.Shard, a.Id, ctx.Me())
                                                        panic.IfNotNil(e)
                                                        panic.If(isOnlyAccountOwner, "only account owner on account %s, please delete the group account or add another account owner before deleting your personal account", acc.Id)
                                                }</span>
                                        }(acc))
                                }
                                <span class="cov8" title="1">errors := panic.SafeGoGroup(privateClientCallBatch...)
                                if errors != nil </span>{<span class="cov0" title="0">

                                }</span>
                                <span class="cov8" title="1">privateClientCallBatch = privateClientCallBatch[:0]
                                for _, acc := range accs </span><span class="cov0" title="0">{
                                        privateClientCallBatch = append(privateClientCallBatch, func(a *Account) func() </span><span class="cov0" title="0">{
                                                return func() </span><span class="cov0" title="0">{
                                                        panic.IfNotNil(ctx.RegionalV1PrivateClient().DeleteAccount(a.Region, a.Shard, a.Id, ctx.Me()))
                                                }</span>
                                        }(acc))
                                }
                                <span class="cov8" title="1">if more </span><span class="cov0" title="0">{
                                        after = &amp;accs[len(accs)-1].Id
                                }</span> else<span class="cov8" title="1"> {
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">panic.IfNotNil(panic.SafeGoGroup(privateClientCallBatch...))</span>
                }
                <span class="cov8" title="1">dbDeleteAccountAndAllAssociatedMemberships(ctx, args.Account)
                return nil</span>
        },
}

type addMembersArgs struct {
        Account    id.Id        `json:"account"`
        NewMembers []*AddMember `json:"newMembers"`
}

var addMembers = &amp;endpoint.Endpoint{
        Path:            "/api/v1/centralAccount/addMembers",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;addMembersArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*addMembersArgs)
                ctx.ReturnBadRequestNowIf(args.Account.Equal(ctx.Me()), "can't add/remove members to/from a personal account")
                validate.EntityCount(len(args.NewMembers), ctx.MaxProcessEntityCount())

                account := dbGetAccount(ctx, args.Account)
                ctx.ReturnBadRequestNowIf(account == nil, "no such account")

                ids := make([]id.Id, 0, len(args.NewMembers))
                addMembersMap := map[string]*AddMember{}
                for _, member := range args.NewMembers </span><span class="cov8" title="1">{
                        ids = append(ids, member.Id)
                        addMembersMap[member.Id.String()] = member
                }</span>

                <span class="cov8" title="1">accs := dbGetPersonalAccounts(ctx, ids)

                members := make([]*private.AddMember, 0, len(accs))
                for _, acc := range accs </span><span class="cov8" title="1">{
                        role := addMembersMap[acc.Id.String()].Role
                        role.Validate()
                        ami := &amp;private.AddMember{}
                        ami.Id = acc.Id
                        ami.Role = role
                        ami.Name = acc.Name
                        ami.DisplayName = acc.DisplayName
                        ami.HasAvatar = acc.HasAvatar
                        members = append(members, ami)
                }</span>

                <span class="cov8" title="1">ctx.RegionalV1PrivateClient().AddMembers(account.Region, account.Shard, args.Account, ctx.Me(), members)
                dbCreateMemberships(ctx, args.Account, ids)
                return nil</span>
        },
}

type removeMembersArgs struct {
        Account         id.Id   `json:"account"`
        ExistingMembers []id.Id `json:"existingMembers"`
}

var removeMembers = &amp;endpoint.Endpoint{
        Path:            "/api/v1/centralAccount/removeMembers",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;removeMembersArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov0" title="0">{
                args := a.(*removeMembersArgs)
                ctx.ReturnBadRequestNowIf(args.Account.Equal(ctx.Me()), "can't add/remove members to/from a personal account")
                validate.EntityCount(len(args.ExistingMembers), ctx.MaxProcessEntityCount())

                account := dbGetAccount(ctx, args.Account)
                ctx.ReturnBadRequestNowIf(account == nil, "no such account")

                ctx.RegionalV1PrivateClient().RemoveMembers(account.Region, account.Shard, args.Account, ctx.Me(), args.ExistingMembers)
                dbDeleteMemberships(ctx, args.Account, args.ExistingMembers)
                return nil
        }</span>,
}

var Endpoints = []*endpoint.Endpoint{
        register,
        resendActivationEmail,
        activate,
        authenticate,
        confirmNewEmail,
        resetPwd,
        setNewPwdFromPwdReset,
        getAccount,
        getAccounts,
        searchAccounts,
        searchPersonalAccounts,
        getMe,
        setMyPwd,
        setMyEmail,
        resendMyNewEmailConfirmationEmail,
        setAccountName,
        setAccountDisplayName,
        setAccountAvatar,
        migrateAccount,
        createAccount,
        getMyAccounts,
        deleteAccount,
        addMembers,
        removeMembers,
}

//structs
type Account struct {
        Id          id.Id       `json:"id"`
        Name        string      `json:"name"`
        DisplayName *string     `json:"displayName"`
        CreatedOn   time.Time   `json:"createdOn"`
        Region      cnst.Region `json:"region"`
        NewRegion   *string     `json:"newRegion,omitempty"`
        Shard       int         `json:"shard"`
        HasAvatar   bool        `json:"hasAvatar"`
        IsPersonal  bool        `json:"isPersonal"`
}

func (a *Account) isMigrating() bool <span class="cov0" title="0">{
        return a.NewRegion != nil
}</span>

type Me struct {
        Account
        Email    string     `json:"email"`
        Language string     `json:"language"`
        Theme    cnst.Theme `json:"theme"`
        NewEmail *string    `json:"newEmail,omitempty"`
}

type fullPersonalAccountInfo struct {
        Me
        activationCode           *string
        activatedOn              *time.Time
        newEmailConfirmationCode *string
        resetPwdCode             *string
}

func (a *fullPersonalAccountInfo) isActivated() bool <span class="cov8" title="1">{
        return a.activatedOn != nil
}</span>

type pwdInfo struct {
        salt   []byte
        pwd    []byte
        n      int
        r      int
        p      int
        keyLen int
}

func pwdsMatch(a, b []byte) bool <span class="cov8" title="1">{
        return bytes.Compare(a, b) == 0
}</span>

type AddMember struct {
        Id   id.Id            `json:"id"`
        Role cnst.AccountRole `json:"role"`
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package private

import (
        "github.com/0xor1/trees/server/util/cnst"
        "github.com/0xor1/trees/server/util/id"
        "github.com/0xor1/trees/server/util/private"
        "fmt"
)

func NewTestClient(testServerBaseUrl string) private.V1Client <span class="cov8" title="1">{
        return &amp;testClient{
                testServerBaseUrl: testServerBaseUrl,
        }
}</span>

type testClient struct {
        testServerBaseUrl string
}

func (c *testClient) CreateAccount(region cnst.Region, account, me id.Id, myName string, myDisplayName *string, hasAvatar bool) (int, error) <span class="cov8" title="1">{
        return _createAccount(c.testServerBaseUrl, region, account, me, myName, myDisplayName, hasAvatar)
}</span>

func (c *testClient) DeleteAccount(region cnst.Region, shard int, account, me id.Id) error <span class="cov8" title="1">{
        return _deleteAccount(c.testServerBaseUrl, region, shard, account, me)
}</span>

func (c *testClient) AddMembers(region cnst.Region, shard int, account, me id.Id, members []*private.AddMember) error <span class="cov8" title="1">{
        return _addMembers(c.testServerBaseUrl, region, shard, account, me, members)
}</span>

func (c *testClient) RemoveMembers(region cnst.Region, shard int, account, me id.Id, members []id.Id) error <span class="cov8" title="1">{
        return _removeMembers(c.testServerBaseUrl, region, shard, account, me, members)
}</span>

func (c *testClient) MemberIsOnlyAccountOwner(region cnst.Region, shard int, account, me id.Id) (bool, error) <span class="cov8" title="1">{
        return _memberIsOnlyAccountOwner(c.testServerBaseUrl, region, shard, account, me)
}</span>

func (c *testClient) SetMemberName(region cnst.Region, shard int, account, me id.Id, newName string) error <span class="cov8" title="1">{
        return _setMemberName(c.testServerBaseUrl, region, shard, account, me, newName)
}</span>

func (c *testClient) SetMemberDisplayName(region cnst.Region, shard int, account, me id.Id, newDisplayName *string) error <span class="cov0" title="0">{
        return _setMemberDisplayName(c.testServerBaseUrl, region, shard, account, me, newDisplayName)
}</span>

func (c *testClient) SetMemberHasAvatar(region cnst.Region, shard int, account, me id.Id, hasAvatar bool) error <span class="cov8" title="1">{
        return _setMemberHasAvatar(c.testServerBaseUrl, region, shard, account, me, hasAvatar)
}</span>

func (c *testClient) MemberIsAccountOwner(region cnst.Region, shard int, account, me id.Id) (bool, error) <span class="cov8" title="1">{
        return _memberIsAccountOwner(c.testServerBaseUrl, region, shard, account, me)
}</span>

func NewClient(env cnst.Env, scheme, nakedHost string) private.V1Client <span class="cov8" title="1">{
        return &amp;client{
                env:       env,
                scheme:    scheme,
                nakedHost: nakedHost,
        }
}</span>

type client struct {
        env       cnst.Env
        scheme    string
        nakedHost string
}

func (c *client) getBaseUrl(region cnst.Region) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%s-%s-api.%s", c.scheme, c.env, region, c.nakedHost)
}</span>

func (c *client) CreateAccount(region cnst.Region, account, me id.Id, myName string, myDisplayName *string, hasAvatar bool) (int, error) <span class="cov0" title="0">{
        return _createAccount(c.getBaseUrl(region), region, account, me, myName, myDisplayName, hasAvatar)
}</span>

func (c *client) DeleteAccount(region cnst.Region, shard int, account, me id.Id) error <span class="cov0" title="0">{
        return _deleteAccount(c.getBaseUrl(region), region, shard, account, me)
}</span>

func (c *client) AddMembers(region cnst.Region, shard int, account, me id.Id, members []*private.AddMember) error <span class="cov0" title="0">{
        return _addMembers(c.getBaseUrl(region), region, shard, account, me, members)
}</span>

func (c *client) RemoveMembers(region cnst.Region, shard int, account, me id.Id, members []id.Id) error <span class="cov0" title="0">{
        return _removeMembers(c.getBaseUrl(region), region, shard, account, me, members)
}</span>

func (c *client) MemberIsOnlyAccountOwner(region cnst.Region, shard int, account, me id.Id) (bool, error) <span class="cov0" title="0">{
        return _memberIsOnlyAccountOwner(c.getBaseUrl(region), region, shard, account, me)
}</span>

func (c *client) SetMemberName(region cnst.Region, shard int, account, me id.Id, newName string) error <span class="cov0" title="0">{
        return _setMemberName(c.getBaseUrl(region), region, shard, account, me, newName)
}</span>

func (c *client) SetMemberDisplayName(region cnst.Region, shard int, account, me id.Id, newDisplayName *string) error <span class="cov0" title="0">{
        return _setMemberDisplayName(c.getBaseUrl(region), region, shard, account, me, newDisplayName)
}</span>

func (c *client) SetMemberHasAvatar(region cnst.Region, shard int, account, me id.Id, hasAvatar bool) error <span class="cov0" title="0">{
        return _setMemberHasAvatar(c.getBaseUrl(region), region, shard, account, me, hasAvatar)
}</span>

func (c *client) MemberIsAccountOwner(region cnst.Region, shard int, account, me id.Id) (bool, error) <span class="cov0" title="0">{
        return _memberIsAccountOwner(c.getBaseUrl(region), region, shard, account, me)
}</span>

func _createAccount(baseUrl string, region cnst.Region, account, me id.Id, myName string, myDisplayName *string, hasAvatar bool) (int, error) <span class="cov8" title="1">{
        respVal := 0
        val, e := createAccount.DoRequest(nil, baseUrl, region, &amp;createAccountArgs{
                Account:       account,
                Me:            me,
                MyName:        myName,
                MyDisplayName: myDisplayName,
                HasAvatar:     hasAvatar,
        }, nil, &amp;respVal)
        if val != nil </span><span class="cov8" title="1">{
                return *val.(*int), e
        }</span>
        <span class="cov0" title="0">return 0, e</span>
}

func _deleteAccount(baseUrl string, region cnst.Region, shard int, account, me id.Id) error <span class="cov8" title="1">{
        _, e := deleteAccount.DoRequest(nil, baseUrl, region, &amp;deleteAccountArgs{
                Shard:   shard,
                Account: account,
                Me:      me,
        }, nil, nil)
        return e
}</span>

func _addMembers(baseUrl string, region cnst.Region, shard int, account, me id.Id, members []*private.AddMember) error <span class="cov8" title="1">{
        _, e := addMembers.DoRequest(nil, baseUrl, region, &amp;addMembersArgs{
                Shard:   shard,
                Account: account,
                Me:      me,
                Members: members,
        }, nil, nil)
        return e
}</span>

func _removeMembers(baseUrl string, region cnst.Region, shard int, account, me id.Id, members []id.Id) error <span class="cov8" title="1">{
        _, err := removeMembers.DoRequest(nil, baseUrl, region, &amp;removeMembersArgs{
                Shard:   shard,
                Account: account,
                Me:      me,
                Members: members,
        }, nil, nil)
        return err
}</span>

func _memberIsOnlyAccountOwner(baseUrl string, region cnst.Region, shard int, account, me id.Id) (bool, error) <span class="cov8" title="1">{
        respVal := false
        val, e := memberIsOnlyAccountOwner.DoRequest(nil, baseUrl, region, &amp;memberIsOnlyAccountOwnerArgs{
                Shard:   shard,
                Account: account,
                Me:      me,
        }, nil, &amp;respVal)
        if val != nil </span><span class="cov8" title="1">{
                return *val.(*bool), e
        }</span>
        <span class="cov0" title="0">return false, e</span>
}

func _setMemberName(baseUrl string, region cnst.Region, shard int, account, me id.Id, newName string) error <span class="cov8" title="1">{
        _, e := setMemberName.DoRequest(nil, baseUrl, region, &amp;setMemberNameArgs{
                Shard:   shard,
                Account: account,
                Me:      me,
                NewName: newName,
        }, nil, nil)
        return e
}</span>

func _setMemberDisplayName(baseUrl string, region cnst.Region, shard int, account, me id.Id, newDisplayName *string) error <span class="cov0" title="0">{
        _, e := setMemberDisplayName.DoRequest(nil, baseUrl, region, &amp;setMemberDisplayNameArgs{
                Shard:          shard,
                Account:        account,
                Me:             me,
                NewDisplayName: newDisplayName,
        }, nil, nil)
        return e
}</span>

func _setMemberHasAvatar(baseUrl string, region cnst.Region, shard int, account, me id.Id, hasAvatar bool) error <span class="cov8" title="1">{
        _, e := setMemberHasAvatar.DoRequest(nil, baseUrl, region, &amp;setMemberHasAvatarArgs{
                Shard:     shard,
                Account:   account,
                Me:        me,
                HasAvatar: hasAvatar,
        }, nil, nil)
        return e
}</span>

func _memberIsAccountOwner(baseUrl string, region cnst.Region, shard int, account, me id.Id) (bool, error) <span class="cov8" title="1">{
        respVal := false
        val, e := memberIsAccountOwner.DoRequest(nil, baseUrl, region, &amp;memberIsAccountOwnerArgs{
                Shard:   shard,
                Account: account,
                Me:      me,
        }, nil, &amp;respVal)
        if val != nil </span><span class="cov8" title="1">{
                return *val.(*bool), e
        }</span>
        <span class="cov0" title="0">return false, e</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package private

import (
        "github.com/0xor1/trees/server/util/cachekey"
        "github.com/0xor1/trees/server/util/ctx"
        "github.com/0xor1/trees/server/util/err"
        "github.com/0xor1/trees/server/util/id"
        "github.com/0xor1/trees/server/util/private"
        "github.com/0xor1/trees/server/util/time"
        "bytes"
        "github.com/0xor1/panic"
        "math/rand"
)

func dbCreateAccount(ctx ctx.Ctx, account, me id.Id, myName string, myDisplayName *string, hasAvatar bool) int <span class="cov8" title="1">{
        shard := rand.Intn(ctx.TreeShardCount())
        _, e := ctx.TreeExec(shard, `CALL registerAccount(?, ?, ?, ?, ?)`, account, me, myName, myDisplayName, hasAvatar)
        panic.IfNotNil(e)
        return shard
}</span>

func dbDeleteAccount(ctx ctx.Ctx, shard int, account id.Id) <span class="cov8" title="1">{
        _, e := ctx.TreeExec(shard, `CALL deleteAccount(?)`, account)
        panic.IfNotNil(e)
        ctx.TouchDlms(cachekey.NewSetDlms().AccountMaster(account))
}</span>

func dbGetAllInactiveMembersFromInputSet(ctx ctx.Ctx, shard int, account id.Id, members []id.Id) []id.Id <span class="cov8" title="1">{
        res := make([]id.Id, 0, len(members))
        cacheKey := cachekey.NewGet("private.dbGetAllInactiveMembersFromInputSet", shard, account, members).AccountMembers(account, members)
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return res
        }</span>
        <span class="cov8" title="1">queryArgs := make([]interface{}, 0, len(members)+1)
        queryArgs = append(queryArgs, account, members[0])
        query := bytes.NewBufferString(`SELECT id FROM accountMembers WHERE account=? AND isActive=false AND id IN (?`)
        for _, mem := range members[1:] </span><span class="cov8" title="1">{
                query.WriteString(`,?`)
                queryArgs = append(queryArgs, mem)
        }</span>
        <span class="cov8" title="1">query.WriteString(`)`)
        rows, e := ctx.TreeQuery(shard, query.String(), queryArgs...)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.IfNotNil(e)
        for rows.Next() </span><span class="cov0" title="0">{
                i := make([]byte, 0, 16)
                rows.Scan(&amp;i)
                res = append(res, id.Id(i))
        }</span>
        <span class="cov8" title="1">ctx.SetCacheValue(res, cacheKey)
        return res</span>
}

func dbAddMembers(ctx ctx.Ctx, shard int, account id.Id, members []*private.AddMember) <span class="cov8" title="1">{
        queryArgs := make([]interface{}, 0, 3*len(members))
        queryArgs = append(queryArgs, account, members[0].Id, members[0].Name, members[0].DisplayName, members[0].HasAvatar, members[0].Role)
        query := bytes.NewBufferString(`INSERT INTO accountMembers (account, id, name, displayName, hasAvatar, role) VALUES (?,?,?,?,?,?)`)
        for _, mem := range members[1:] </span><span class="cov8" title="1">{
                query.WriteString(`,(?,?,?,?,?,?)`)
                queryArgs = append(queryArgs, account, mem.Id, mem.Name, mem.DisplayName, mem.HasAvatar, mem.Role)
        }</span>
        <span class="cov8" title="1">_, e := ctx.TreeExec(shard, query.String(), queryArgs...)
        panic.IfNotNil(e)
        ctx.TouchDlms(cachekey.NewSetDlms().AccountMembersSet(account))</span>
}

func dbUpdateMembersAndSetActive(ctx ctx.Ctx, shard int, account id.Id, members []*private.AddMember) <span class="cov0" title="0">{
        memberIds := make([]id.Id, 0, len(members))
        for _, mem := range members </span><span class="cov0" title="0">{
                memberIds = append(memberIds, mem.Id)
                _, e := ctx.TreeExec(shard, `CALL updateMembersAndSetActive(?, ?, ?, ?, ?, ?)`, account, mem.Id, mem.Name, mem.DisplayName, mem.HasAvatar, mem.Role)
                panic.IfNotNil(e)
        }</span>
        <span class="cov0" title="0">ctx.TouchDlms(cachekey.NewSetDlms().AccountMembers(account, memberIds))</span>
}

func dbGetTotalOwnerCount(ctx ctx.Ctx, shard int, account id.Id) int <span class="cov8" title="1">{
        count := 0
        cacheKey := cachekey.NewGet("private.dbGetTotalOwnerCount", shard, account).AccountMembersSet(account)
        if ctx.GetCacheValue(&amp;count, cacheKey) </span><span class="cov0" title="0">{
                return count
        }</span>
        <span class="cov8" title="1">err.IsSqlErrNoRowsElsePanicIf(ctx.TreeQueryRow(shard, `SELECT COUNT(*) FROM accountMembers WHERE account=? AND isActive=true AND role=0`, account).Scan(&amp;count))
        ctx.SetCacheValue(count, cacheKey)
        return count</span>
}

func dbGetOwnerCountInSet(ctx ctx.Ctx, shard int, account id.Id, members []id.Id) int <span class="cov8" title="1">{
        count := 0
        cacheKey := cachekey.NewGet("private.dbGetOwnerCountInSet", shard, account, members).AccountMembers(account, members)
        if ctx.GetCacheValue(&amp;count, cacheKey) </span><span class="cov0" title="0">{
                return count
        }</span>
        <span class="cov8" title="1">queryArgs := make([]interface{}, 0, len(members)+1)
        queryArgs = append(queryArgs, account, members[0])
        query := bytes.NewBufferString(`SELECT COUNT(*) FROM accountMembers WHERE account=? AND isActive=true AND role=0 AND id IN (?`)
        for _, mem := range members[1:] </span><span class="cov0" title="0">{
                query.WriteString(`,?`)
                queryArgs = append(queryArgs, mem)
        }</span>
        <span class="cov8" title="1">query.WriteString(`)`)
        err.IsSqlErrNoRowsElsePanicIf(ctx.TreeQueryRow(shard, query.String(), queryArgs...).Scan(&amp;count))
        ctx.SetCacheValue(count, cacheKey)
        return count</span>
}

func dbSetMembersInactive(ctx ctx.Ctx, shard int, account id.Id, members []id.Id) <span class="cov8" title="1">{
        cacheKey := cachekey.NewSetDlms().AccountMembers(account, members)
        for _, mem := range members </span><span class="cov8" title="1">{
                rows, e := ctx.TreeQuery(shard, `CALL setAccountMemberInactive(?, ?)`, account, mem)
                if rows != nil </span><span class="cov8" title="1">{
                        defer rows.Close()
                }</span>
                <span class="cov8" title="1">panic.IfNotNil(e)
                for rows.Next() </span><span class="cov0" title="0">{
                        var project id.Id
                        var task id.Id
                        panic.IfNotNil(rows.Scan(&amp;project, task))
                        cacheKey.Task(account, project, task).ProjectMembersSet(account, project).ProjectMember(account, project, mem)
                }</span>
        }
        <span class="cov8" title="1">ctx.TouchDlms(cacheKey)</span>
}

func dbSetMemberName(ctx ctx.Ctx, shard int, account id.Id, member id.Id, newName string) <span class="cov8" title="1">{
        _, e := ctx.TreeExec(shard, `CALL setMemberName(?, ?, ?)`, account, member, newName)
        panic.IfNotNil(e)
        ctx.TouchDlms(cachekey.NewSetDlms().AccountMember(account, member))
}</span>

func dbSetMemberDisplayName(ctx ctx.Ctx, shard int, account, member id.Id, newDisplayName *string) <span class="cov0" title="0">{
        _, e := ctx.TreeExec(shard, `CALL setMemberDisplayName(?, ?, ?)`, account, member, newDisplayName)
        panic.IfNotNil(e)
        ctx.TouchDlms(cachekey.NewSetDlms().AccountMember(account, member))
}</span>

func dbSetMemberHasAvatar(ctx ctx.Ctx, shard int, account, member id.Id, hasAvatar bool) <span class="cov8" title="1">{
        _, e := ctx.TreeExec(shard, `UPDATE accountMembers SET hasAvatar=? WHERE account=? AND id=?`, hasAvatar, account, member)
        panic.IfNotNil(e)
        ctx.TouchDlms(cachekey.NewSetDlms().AccountMember(account, member))
}</span>

func dbLogAccountBatchAddOrRemoveMembersActivity(ctx ctx.Ctx, shard int, account, member id.Id, members []id.Id, action string) <span class="cov8" title="1">{
        query := bytes.NewBufferString(`INSERT INTO accountActivities (account, occurredOn, member, item, itemType, action, itemName, extraInfo) VALUES (?,?,?,?,?,?,?,?)`)
        args := make([]interface{}, 0, len(members)*8)
        now := time.Now()
        args = append(args, account, now, member, members[0], "member", action, nil, nil)
        for _, mem := range members[1:] </span><span class="cov8" title="1">{
                query.WriteString(`,(?,?,?,?,?,?,?,?)`)
                args = append(args, account, now, member, mem, "member", action, nil, nil)
        }</span>
        <span class="cov8" title="1">_, e := ctx.TreeExec(shard, query.String(), args...)
        panic.IfNotNil(e)
        ctx.TouchDlms(cachekey.NewSetDlms().AccountActivities(account))</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package private

import (
        "github.com/0xor1/trees/server/util/cnst"
        "github.com/0xor1/trees/server/util/ctx"
        "github.com/0xor1/trees/server/util/db"
        "github.com/0xor1/trees/server/util/endpoint"
        "github.com/0xor1/trees/server/util/id"
        "github.com/0xor1/trees/server/util/private"
        "github.com/0xor1/trees/server/util/validate"
)

type createAccountArgs struct {
        Account       id.Id   `json:"account"`
        Me            id.Id   `json:"me"`
        MyName        string  `json:"myName"`
        MyDisplayName *string `json:"myDisplayName"`
        HasAvatar     bool    `json:"hasAvatar"`
}

var createAccount = &amp;endpoint.Endpoint{
        Path:      "/api/v1/private/createAccount",
        IsPrivate: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;createAccountArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*createAccountArgs)
                return dbCreateAccount(ctx, args.Account, args.Me, args.MyName, args.MyDisplayName, args.HasAvatar)
        }</span>,
}

type deleteAccountArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
        Me      id.Id `json:"me"`
}

var deleteAccount = &amp;endpoint.Endpoint{
        Path:      "/api/v1/private/deleteAccount",
        IsPrivate: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;deleteAccountArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*deleteAccountArgs)
                if !args.Me.Equal(args.Account) </span><span class="cov8" title="1">{
                        validate.MemberHasAccountOwnerAccess(db.GetAccountRole(ctx, args.Shard, args.Account, args.Me))
                }</span>
                <span class="cov8" title="1">dbDeleteAccount(ctx, args.Shard, args.Account)
                //TODO delete s3 data, uploaded files etc
                return nil</span>
        },
}

type addMembersArgs struct {
        Shard   int                  `json:"shard"`
        Account id.Id                `json:"account"`
        Me      id.Id                `json:"me"`
        Members []*private.AddMember `json:"members"`
}

var addMembers = &amp;endpoint.Endpoint{
        Path:      "/api/v1/private/addMembers",
        IsPrivate: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;addMembersArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*addMembersArgs)
                validate.EntityCount(len(args.Members), ctx.MaxProcessEntityCount())
                ctx.ReturnBadRequestNowIf(args.Account.Equal(args.Me), "can't add/remove members to/from personal accounts")
                accountRole := db.GetAccountRole(ctx, args.Shard, args.Account, args.Me)
                validate.MemberHasAccountAdminAccess(accountRole)

                allIds := make([]id.Id, 0, len(args.Members))
                newMembersMap := map[string]*private.AddMember{}
                for _, mem := range args.Members </span><span class="cov8" title="1">{ //loop over all the new entries and check permissions and build up useful id map and allIds slice
                        mem.Role.Validate()
                        if mem.Role == cnst.AccountOwner </span><span class="cov0" title="0">{
                                validate.MemberHasAccountOwnerAccess(accountRole)
                        }</span>
                        <span class="cov8" title="1">newMembersMap[mem.Id.String()] = mem
                        allIds = append(allIds, mem.Id)</span>
                }

                <span class="cov8" title="1">inactiveMemberIds := dbGetAllInactiveMembersFromInputSet(ctx, args.Shard, args.Account, allIds)
                inactiveMembers := make([]*private.AddMember, 0, len(inactiveMemberIds))
                for _, inactiveMember := range inactiveMemberIds </span><span class="cov0" title="0">{
                        idStr := inactiveMember.String()
                        inactiveMembers = append(inactiveMembers, newMembersMap[idStr])
                        delete(newMembersMap, idStr)
                }</span>

                <span class="cov8" title="1">newMembers := make([]*private.AddMember, 0, len(newMembersMap))
                for _, newMem := range newMembersMap </span><span class="cov8" title="1">{
                        newMembers = append(newMembers, newMem)
                }</span>

                <span class="cov8" title="1">if len(newMembers) &gt; 0 </span><span class="cov8" title="1">{
                        dbAddMembers(ctx, args.Shard, args.Account, newMembers)
                }</span>
                <span class="cov8" title="1">if len(inactiveMembers) &gt; 0 </span><span class="cov0" title="0">{
                        dbUpdateMembersAndSetActive(ctx, args.Shard, args.Account, inactiveMembers) //has to be private.AddMember in case the member changed their name whilst they were inactive on the account
                }</span>
                <span class="cov8" title="1">dbLogAccountBatchAddOrRemoveMembersActivity(ctx, args.Shard, args.Account, args.Me, allIds, "added")
                return nil</span>
        },
}

type removeMembersArgs struct {
        Shard   int     `json:"shard"`
        Account id.Id   `json:"account"`
        Me      id.Id   `json:"me"`
        Members []id.Id `json:"members"`
}

var removeMembers = &amp;endpoint.Endpoint{
        Path:      "/api/v1/private/removeMembers",
        IsPrivate: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;removeMembersArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*removeMembersArgs)
                validate.EntityCount(len(args.Members), ctx.MaxProcessEntityCount())
                ctx.ReturnBadRequestNowIf(args.Account.Equal(args.Me), "can;t add/remove members to/from personal accounts")

                accountRole := db.GetAccountRole(ctx, args.Shard, args.Account, args.Me)
                ctx.ReturnUnauthorizedNowIf(accountRole == nil)

                switch *accountRole </span>{
                case cnst.AccountOwner:<span class="cov8" title="1">
                        totalOwnerCount := dbGetTotalOwnerCount(ctx, args.Shard, args.Account)
                        ownerCountInRemoveSet := dbGetOwnerCountInSet(ctx, args.Shard, args.Account, args.Members)
                        ctx.ReturnBadRequestNowIf(totalOwnerCount == ownerCountInRemoveSet, "action would result in no owners on the account")</span>
                case cnst.AccountAdmin:<span class="cov0" title="0">
                        ownerCountInRemoveSet := dbGetOwnerCountInSet(ctx, args.Shard, args.Account, args.Members)
                        ctx.ReturnUnauthorizedNowIf(ownerCountInRemoveSet &gt; 0)</span>
                default:<span class="cov0" title="0">
                        ctx.ReturnUnauthorizedNowIf(len(args.Members) != 1 || !args.Members[0].Equal(args.Me))</span>
                }

                <span class="cov8" title="1">dbSetMembersInactive(ctx, args.Shard, args.Account, args.Members)
                dbLogAccountBatchAddOrRemoveMembersActivity(ctx, args.Shard, args.Account, args.Me, args.Members, "removed")
                return nil</span>
        },
}

type memberIsOnlyAccountOwnerArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
        Me      id.Id `json:"me"`
}

var memberIsOnlyAccountOwner = &amp;endpoint.Endpoint{
        Path:      "/api/v1/private/memberIsOnlyAccountOwner",
        IsPrivate: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;memberIsOnlyAccountOwnerArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*memberIsOnlyAccountOwnerArgs)
                if args.Account.Equal(args.Me) </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov8" title="1">totalOwnerCount := dbGetTotalOwnerCount(ctx, args.Shard, args.Account)
                ownerCount := dbGetOwnerCountInSet(ctx, args.Shard, args.Account, []id.Id{args.Me})
                return totalOwnerCount == 1 &amp;&amp; ownerCount == 1</span>
        },
}

type setMemberNameArgs struct {
        Shard   int    `json:"shard"`
        Account id.Id  `json:"account"`
        Me      id.Id  `json:"me"`
        NewName string `json:"newName"`
}

var setMemberName = &amp;endpoint.Endpoint{
        Path:      "/api/v1/private/setMemberName",
        IsPrivate: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setMemberNameArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setMemberNameArgs)
                dbSetMemberName(ctx, args.Shard, args.Account, args.Me, args.NewName)
                return nil
        }</span>,
}

type setMemberDisplayNameArgs struct {
        Shard          int     `json:"shard"`
        Account        id.Id   `json:"account"`
        Me             id.Id   `json:"me"`
        NewDisplayName *string `json:"newDisplayName"`
}

var setMemberDisplayName = &amp;endpoint.Endpoint{
        Path:      "/api/v1/private/setMemberDisplayName",
        IsPrivate: true,
        GetArgsStruct: func() interface{} <span class="cov0" title="0">{
                return &amp;setMemberDisplayNameArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov0" title="0">{
                args := a.(*setMemberDisplayNameArgs)
                dbSetMemberDisplayName(ctx, args.Shard, args.Account, args.Me, args.NewDisplayName)
                return nil
        }</span>,
}

type setMemberHasAvatarArgs struct {
        Shard     int   `json:"shard"`
        Account   id.Id `json:"account"`
        Me        id.Id `json:"me"`
        HasAvatar bool  `json:"hasAvatar"`
}

var setMemberHasAvatar = &amp;endpoint.Endpoint{
        Path:      "/api/v1/private/setMemberHasAvatar",
        IsPrivate: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setMemberHasAvatarArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setMemberHasAvatarArgs)
                dbSetMemberHasAvatar(ctx, args.Shard, args.Account, args.Me, args.HasAvatar)
                return nil
        }</span>,
}

type memberIsAccountOwnerArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
        Me      id.Id `json:"me"`
}

var memberIsAccountOwner = &amp;endpoint.Endpoint{
        Path:      "/api/v1/private/memberIsAccountOwner",
        IsPrivate: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;memberIsAccountOwnerArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*memberIsAccountOwnerArgs)
                if !args.Me.Equal(args.Account) </span><span class="cov8" title="1">{
                        accountRole := db.GetAccountRole(ctx, args.Shard, args.Account, args.Me)
                        if accountRole != nil &amp;&amp; *accountRole == cnst.AccountOwner </span><span class="cov8" title="1">{
                                return true
                        }</span> else<span class="cov0" title="0"> {
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        },
}

var Endpoints = []*endpoint.Endpoint{
        createAccount,
        deleteAccount,
        addMembers,
        removeMembers,
        memberIsOnlyAccountOwner,
        setMemberName,
        setMemberDisplayName,
        setMemberHasAvatar,
        memberIsAccountOwner,
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package project

import (
        "github.com/0xor1/trees/server/util/activity"
        "github.com/0xor1/trees/server/util/clientsession"
        "github.com/0xor1/trees/server/util/cnst"
        "github.com/0xor1/trees/server/util/id"
        "time"
)

type Client interface {
        //must be account owner/admin
        Create(css *clientsession.Store, region cnst.Region, shard int, account id.Id, name string, description *string, hoursPerDay, daysPerWeek uint8, startOn, dueOn *time.Time, isParallel, isPublic bool, members []*AddProjectMember) (*Project, error)
        //see individual fields for permissions
        Edit(css *clientsession.Store, region cnst.Region, shard int, account, project id.Id, fields Fields) error
        //check project access permission per user
        Get(css *clientsession.Store, region cnst.Region, shard int, account, project id.Id) (*Project, error)
        //check project access permission per user
        GetSet(css *clientsession.Store, region cnst.Region, shard int, account id.Id, nameContains *string, createdOnAfter, createdOnBefore, startOnAfter, startOnBefore, dueOnAfter, dueOnBefore *time.Time, isArchived bool, sortBy cnst.SortBy, sortAsc bool, after *id.Id, limit int) (*GetSetResult, error)
        //must be account owner/admin
        Delete(css *clientsession.Store, region cnst.Region, shard int, account, project id.Id) error
        //must be account owner/admin or project admin
        AddMembers(css *clientsession.Store, region cnst.Region, shard int, account, project id.Id, members []*AddProjectMember) error
        //must be account owner/admin or project admin
        SetMemberRole(css *clientsession.Store, region cnst.Region, shard int, account, project id.Id, member id.Id, role cnst.ProjectRole) error
        //must be account owner/admin or project admin
        RemoveMembers(css *clientsession.Store, region cnst.Region, shard int, account, project id.Id, members []id.Id) error
        //pointers are optional filters, anyone who can see a project can see all the member info for that project
        GetMembers(css *clientsession.Store, region cnst.Region, shard int, account, project id.Id, role *cnst.ProjectRole, nameOrDisplayNameContains *string, after *id.Id, limit int) (*GetMembersResult, error)
        //used when typing a chat message after entering @ symbol
        GetAtMentions(css *clientsession.Store, region cnst.Region, shard int, account, project id.Id, nameOrDisplayNamePrefix string) ([]*member, error)
        //for anyone
        GetMe(css *clientsession.Store, region cnst.Region, shard int, account, project id.Id) (*member, error)
        //either one or both of OccurredAfter/Before must be nil
        GetActivities(css *clientsession.Store, region cnst.Region, shard int, account, project id.Id, item, member *id.Id, occurredAfter, occurredBefore *time.Time, limit int) ([]*activity.Activity, error)
}

func NewClient(host string) Client <span class="cov8" title="1">{
        return &amp;client{
                host: host,
        }
}</span>

type client struct {
        host string
}

func (c *client) Create(css *clientsession.Store, region cnst.Region, shard int, account id.Id, name string, description *string, hoursPerDay, daysPerWeek uint8, startOn, dueOn *time.Time, isParallel, isPublic bool, members []*AddProjectMember) (*Project, error) <span class="cov8" title="1">{
        val, e := create.DoRequest(css, c.host, region, &amp;createArgs{
                Shard:       shard,
                Account:     account,
                Name:        name,
                Description: description,
                HoursPerDay: hoursPerDay,
                DaysPerWeek: daysPerWeek,
                StartOn:     startOn,
                DueOn:       dueOn,
                IsParallel:  isParallel,
                IsPublic:    isPublic,
                Members:     members,
        }, nil, &amp;Project{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*Project), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) Edit(css *clientsession.Store, region cnst.Region, shard int, account, project id.Id, fields Fields) error <span class="cov8" title="1">{
        _, e := edit.DoRequest(css, c.host, region, &amp;editArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                Fields:  fields,
        }, nil, nil)
        return e
}</span>

func (c *client) Get(css *clientsession.Store, region cnst.Region, shard int, account, proj id.Id) (*Project, error) <span class="cov8" title="1">{
        val, e := get.DoRequest(css, c.host, region, &amp;getArgs{
                Shard:   shard,
                Account: account,
                Project: proj,
        }, nil, &amp;Project{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*Project), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) GetSet(css *clientsession.Store, region cnst.Region, shard int, account id.Id, nameContains *string, createdOnAfter, createdOnBefore, startOnAfter, startOnBefore, dueOnAfter, dueOnBefore *time.Time, isArchived bool, sortBy cnst.SortBy, sortAsc bool, after *id.Id, limit int) (*GetSetResult, error) <span class="cov8" title="1">{
        val, e := getSet.DoRequest(css, c.host, region, &amp;getSetArgs{
                Shard:           shard,
                Account:         account,
                NameContains:    nameContains,
                CreatedOnAfter:  createdOnAfter,
                CreatedOnBefore: createdOnBefore,
                StartOnAfter:    startOnAfter,
                StartOnBefore:   startOnBefore,
                DueOnAfter:      dueOnAfter,
                DueOnBefore:     dueOnBefore,
                IsArchived:      isArchived,
                SortBy:          sortBy,
                SortAsc:         sortAsc,
                After:           after,
                Limit:           limit,
        }, nil, &amp;GetSetResult{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*GetSetResult), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) Delete(css *clientsession.Store, region cnst.Region, shard int, account, project id.Id) error <span class="cov8" title="1">{
        _, e := delete.DoRequest(css, c.host, region, &amp;deleteArgs{
                Shard:   shard,
                Account: account,
                Project: project,
        }, nil, nil)
        return e
}</span>

func (c *client) AddMembers(css *clientsession.Store, region cnst.Region, shard int, account, project id.Id, members []*AddProjectMember) error <span class="cov8" title="1">{
        _, e := addMembers.DoRequest(css, c.host, region, &amp;addMembersArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                Members: members,
        }, nil, nil)
        return e
}</span>

func (c *client) SetMemberRole(css *clientsession.Store, region cnst.Region, shard int, account, project, member id.Id, role cnst.ProjectRole) error <span class="cov8" title="1">{
        _, e := setMemberRole.DoRequest(css, c.host, region, &amp;setMemberRoleArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                Member:  member,
                Role:    role,
        }, nil, nil)
        return e
}</span>

func (c *client) RemoveMembers(css *clientsession.Store, region cnst.Region, shard int, account, project id.Id, members []id.Id) error <span class="cov8" title="1">{
        _, e := removeMembers.DoRequest(css, c.host, region, &amp;removeMembersArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                Members: members,
        }, nil, nil)
        return e
}</span>

func (c *client) GetMembers(css *clientsession.Store, region cnst.Region, shard int, account, project id.Id, role *cnst.ProjectRole, nameOrDisplayNameContains *string, after *id.Id, limit int) (*GetMembersResult, error) <span class="cov8" title="1">{
        val, e := getMembers.DoRequest(css, c.host, region, &amp;getMembersArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                Role:    role,
                NameOrDisplayNameContains: nameOrDisplayNameContains,
                After: after,
                Limit: limit,
        }, nil, &amp;GetMembersResult{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*GetMembersResult), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) GetAtMentions(css *clientsession.Store, region cnst.Region, shard int, account, project id.Id, nameOrDisplayNamePrefix string) ([]*member, error) <span class="cov0" title="0">{
        val, e := getMembers.DoRequest(css, c.host, region, &amp;getAtMentionsArgs{
                Shard:                   shard,
                Account:                 account,
                Project:                 project,
                NameOrDisplayNamePrefix: nameOrDisplayNamePrefix,
        }, nil, &amp;[]*member{})
        if val != nil </span><span class="cov0" title="0">{
                return *val.(*[]*member), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) GetMe(css *clientsession.Store, region cnst.Region, shard int, account, project id.Id) (*member, error) <span class="cov8" title="1">{
        val, e := getMe.DoRequest(css, c.host, region, &amp;getMeArgs{
                Shard:   shard,
                Account: account,
                Project: project,
        }, nil, &amp;member{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*member), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) GetActivities(css *clientsession.Store, region cnst.Region, shard int, account, project id.Id, item, member *id.Id, occurredAfter, occurredBefore *time.Time, limit int) ([]*activity.Activity, error) <span class="cov8" title="1">{
        val, e := getActivities.DoRequest(css, c.host, region, &amp;getActivitiesArgs{
                Shard:          shard,
                Account:        account,
                Project:        project,
                Item:           item,
                Member:         member,
                OccurredAfter:  occurredAfter,
                OccurredBefore: occurredBefore,
                Limit:          limit,
        }, nil, &amp;[]*activity.Activity{})
        if val != nil </span><span class="cov8" title="1">{
                return *val.(*[]*activity.Activity), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package project

import (
        "github.com/0xor1/trees/server/util/activity"
        "github.com/0xor1/trees/server/util/cachekey"
        "github.com/0xor1/trees/server/util/cnst"
        "github.com/0xor1/trees/server/util/ctx"
        "github.com/0xor1/trees/server/util/db"
        "github.com/0xor1/trees/server/util/err"
        "github.com/0xor1/trees/server/util/field"
        "github.com/0xor1/trees/server/util/id"
        "github.com/0xor1/trees/server/util/sortdir"
        "github.com/0xor1/trees/server/util/validate"
        "bytes"
        "fmt"
        "github.com/0xor1/panic"
        "strings"
        "time"
)

func dbGetProjectExists(ctx ctx.Ctx, shard int, account, project id.Id) bool <span class="cov8" title="1">{
        var exists bool
        cacheKey := cachekey.NewGet("db.GetProjectExists", shard, account, project).Project(account, project)
        if ctx.GetCacheValue(&amp;exists, cacheKey) </span><span class="cov0" title="0">{
                return exists
        }</span>
        <span class="cov8" title="1">row := ctx.TreeQueryRow(shard, `SELECT COUNT(*) = 1 FROM projects WHERE account=? AND id=?`, account, project)
        panic.IfNotNil(row.Scan(&amp;exists))
        ctx.SetCacheValue(exists, cacheKey)
        return exists</span>
}

func dbCreateProject(ctx ctx.Ctx, shard int, account id.Id, project *Project) <span class="cov8" title="1">{
        _, e := ctx.TreeExec(shard, `CALL createProject(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`, account, project.Id, ctx.Me(), project.Name, project.Description, project.HoursPerDay, project.DaysPerWeek, project.CreatedOn, project.StartOn, project.DueOn, project.IsParallel, project.IsPublic)
        panic.IfNotNil(e)
        ctx.TouchDlms(cachekey.NewSetDlms().AccountActivities(account).AccountProjectsSet(account))
}</span>

func dbEdit(ctx ctx.Ctx, shard int, account, project id.Id, fields Fields) <span class="cov8" title="1">{
        setIsPublic := fields.IsPublic != nil
        if !setIsPublic </span><span class="cov8" title="1">{
                fields.IsPublic = &amp;field.Bool{}
        }</span>
        <span class="cov8" title="1">setIsArchived := fields.IsArchived != nil
        if !setIsArchived </span><span class="cov8" title="1">{
                fields.IsArchived = &amp;field.Bool{}
        }</span>
        <span class="cov8" title="1">setHoursPerDay := fields.HoursPerDay != nil
        if !setHoursPerDay </span><span class="cov8" title="1">{
                fields.HoursPerDay = &amp;field.UInt8{}
        }</span>
        <span class="cov8" title="1">setDaysPerWeek := fields.DaysPerWeek != nil
        if !setDaysPerWeek </span><span class="cov8" title="1">{
                fields.DaysPerWeek = &amp;field.UInt8{}
        }</span>
        <span class="cov8" title="1">setStartOn := fields.StartOn != nil
        if !setStartOn </span><span class="cov8" title="1">{
                fields.StartOn = &amp;field.TimePtr{}
        }</span>
        <span class="cov8" title="1">setDueOn := fields.DueOn != nil
        if !setDueOn </span><span class="cov8" title="1">{
                fields.DueOn = &amp;field.TimePtr{}
        }</span>
        <span class="cov8" title="1">if !setIsPublic &amp;&amp; !setIsArchived &amp;&amp; !setHoursPerDay &amp;&amp; !setDaysPerWeek &amp;&amp; !setStartOn &amp;&amp; !setDueOn </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">_, e := ctx.TreeExec(shard, `CALL editProject(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`, account, project, ctx.Me(), setIsPublic, fields.IsPublic.Val, setIsArchived, fields.IsArchived.Val, setHoursPerDay, fields.HoursPerDay.Val, setDaysPerWeek, fields.DaysPerWeek.Val, setStartOn, fields.StartOn.Val, setDueOn, fields.DueOn.Val)
        panic.IfNotNil(e)
        ctx.TouchDlms(cachekey.NewSetDlms().AccountActivities(account).Project(account, project).ProjectActivities(account, project))</span>
}

func dbGetProject(ctx ctx.Ctx, shard int, account, proj id.Id) *Project <span class="cov8" title="1">{
        res := Project{}
        cacheKey := cachekey.NewGet("project.dbGetProject", shard, account, proj).Project(account, proj)
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return &amp;res
        }</span>
        <span class="cov8" title="1">row := ctx.TreeQueryRow(shard, `SELECT p.id, p.isArchived, p.name, p.hoursPerDay, p.daysPerWeek, p.createdOn, p.startOn, p.dueOn, p.fileCount, p.fileSize, p.isPublic, t.description, t.totalRemainingTime, t.totalLoggedTime, t.minimumRemainingTime, t.linkedFileCount, t.chatCount, t.childCount, t.descendantCount, t.isParallel FROM projects p, tasks t WHERE p.account=? AND p.id=? AND t.account=? AND t.project=? AND t.id=?`, account, proj, account, proj, proj)
        if err.IsSqlErrNoRowsElsePanicIf(row.Scan(&amp;res.Id, &amp;res.IsArchived, &amp;res.Name, &amp;res.HoursPerDay, &amp;res.DaysPerWeek, &amp;res.CreatedOn, &amp;res.StartOn, &amp;res.DueOn, &amp;res.FileCount, &amp;res.FileSize, &amp;res.IsPublic, &amp;res.Description, &amp;res.TotalRemainingTime, &amp;res.TotalLoggedTime, &amp;res.MinimumRemainingTime, &amp;res.LinkedFileCount, &amp;res.ChatCount, &amp;res.ChildCount, &amp;res.DescendantCount, &amp;res.IsParallel)) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">ctx.SetCacheValue(res, cacheKey)
        return &amp;res</span>
}

func dbGetPublicProjects(ctx ctx.Ctx, shard int, account id.Id, nameContains *string, createdOnAfter, createdOnBefore, startOnAfter, startOnBefore, dueOnAfter, dueOnBefore *time.Time, isArchived bool, sortBy cnst.SortBy, sortAsc bool, after *id.Id, limit int) *GetSetResult <span class="cov0" title="0">{
        return dbGetProjects(ctx, shard, `AND isPublic=true`, account, nil, nameContains, createdOnAfter, createdOnBefore, startOnAfter, startOnBefore, dueOnAfter, dueOnBefore, isArchived, sortBy, sortAsc, after, limit)
}</span>

func dbGetPublicAndSpecificAccessProjects(ctx ctx.Ctx, shard int, account, me id.Id, nameContains *string, createdOnAfter, createdOnBefore, startOnAfter, startOnBefore, dueOnAfter, dueOnBefore *time.Time, isArchived bool, sortBy cnst.SortBy, sortAsc bool, after *id.Id, limit int) *GetSetResult <span class="cov0" title="0">{
        return dbGetProjects(ctx, shard, `AND (isPublic=true OR id IN (SELECT project FROM projectMembers WHERE account=? AND isActive=true AND id=?))`, account, &amp;me, nameContains, createdOnAfter, createdOnBefore, startOnAfter, startOnBefore, dueOnAfter, dueOnBefore, isArchived, sortBy, sortAsc, after, limit)
}</span>

func dbGetAllProjects(ctx ctx.Ctx, shard int, account id.Id, nameContains *string, createdOnAfter, createdOnBefore, startOnAfter, startOnBefore, dueOnAfter, dueOnBefore *time.Time, isArchived bool, sortBy cnst.SortBy, sortAsc bool, after *id.Id, limit int) *GetSetResult <span class="cov8" title="1">{
        return dbGetProjects(ctx, shard, ``, account, nil, nameContains, createdOnAfter, createdOnBefore, startOnAfter, startOnBefore, dueOnAfter, dueOnBefore, isArchived, sortBy, sortAsc, after, limit)
}</span>

func dbDeleteProject(ctx ctx.Ctx, shard int, account, project id.Id) <span class="cov8" title="1">{
        _, e := ctx.TreeExec(shard, `CALL deleteProject(?, ?, ?)`, account, project, ctx.Me())
        panic.IfNotNil(e)
        ctx.TouchDlms(cachekey.NewSetDlms().AccountProjectsSet(account).ProjectMaster(account, project))
}</span>

func dbAddMemberOrSetActive(ctx ctx.Ctx, shard int, account, project id.Id, member *AddProjectMember) <span class="cov8" title="1">{
        db.MakeChangeHelper(ctx, shard, `CALL addProjectMemberOrSetActive(?, ?, ?, ?, ?)`, account, project, ctx.Me(), member.Id, member.Role)
        ctx.TouchDlms(cachekey.NewSetDlms().ProjectMember(account, project, member.Id).ProjectActivities(account, project))
}</span>

func dbSetMemberRole(ctx ctx.Ctx, shard int, account, project, member id.Id, role cnst.ProjectRole) <span class="cov8" title="1">{
        db.MakeChangeHelper(ctx, shard, `CALL setProjectMemberRole(?, ?, ?, ?, ?)`, account, project, ctx.Me(), member, role)
        ctx.TouchDlms(cachekey.NewSetDlms().ProjectMember(account, project, member).ProjectActivities(account, project))
}</span>

func dbSetMemberInactive(ctx ctx.Ctx, shard int, account, project id.Id, member id.Id) <span class="cov8" title="1">{
        db.MakeChangeHelper(ctx, shard, `CALL setProjectMemberInactive(?, ?, ?, ?)`, account, project, ctx.Me(), member)
        ctx.TouchDlms(cachekey.NewSetDlms().ProjectMember(account, project, member).ProjectActivities(account, project))
}</span>

func dbGetMembers(ctx ctx.Ctx, shard int, account, project id.Id, role *cnst.ProjectRole, nameOrDisplayNameFilter *string, nameOrDisplayNameFilterIsPrefix bool, after *id.Id, limit int) *GetMembersResult <span class="cov8" title="1">{
        if nameOrDisplayNameFilter != nil </span><span class="cov0" title="0">{
                validate.StringArg("nameOrDisplayName", *nameOrDisplayNameFilter, ctx.DisplayNameMinRuneCount(), ctx.DisplayNameMaxRuneCount(), ctx.DisplayNameRegexMatchers())
        }</span>
        <span class="cov8" title="1">res := GetMembersResult{}
        cacheKey := cachekey.NewGet("project.dbGetMembers", shard, account, project, role, nameOrDisplayNameFilter, nameOrDisplayNameFilterIsPrefix, after, limit).ProjectMembersSet(account, project)
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return &amp;res
        }</span>
        <span class="cov8" title="1">query := bytes.NewBufferString(`SELECT p1.id, p1.isActive, p1.totalRemainingTime, p1.totalLoggedTime, p1.role FROM projectMembers p1`)
        args := make([]interface{}, 0, 9)
        if after != nil </span><span class="cov0" title="0">{
                query.WriteString(`, projectMembers p2`)
        }</span>
        <span class="cov8" title="1">query.WriteString(` WHERE p1.account=? AND p1.project=? AND p1.isActive=true`)
        args = append(args, account, project)
        if after != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND p2.account=? AND p2.project=? p2.id=? AND ((p1.name&gt;p2.name AND p1.role=p2.role) OR p1.role&gt;p2.role)`)
                args = append(args, account, project, *after)
        }</span>
        <span class="cov8" title="1">if role != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND p1.role=?`)
                args = append(args, role)
        }</span>
        <span class="cov8" title="1">if nameOrDisplayNameFilter != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND (p1.name LIKE ? OR p1.displayName LIKE ?)`)
                strVal := strings.Trim(*nameOrDisplayNameFilter, " ")
                if nameOrDisplayNameFilterIsPrefix </span><span class="cov0" title="0">{
                        strVal = fmt.Sprintf("%s%%", strVal)
                }</span> else<span class="cov0" title="0"> {
                        strVal = fmt.Sprintf("%%%s%%", strVal)
                }</span>
                <span class="cov0" title="0">args = append(args, strVal, strVal)</span>
        }
        <span class="cov8" title="1">if nameOrDisplayNameFilter == nil || !nameOrDisplayNameFilterIsPrefix </span><span class="cov8" title="1">{
                query.WriteString(` ORDER BY p1.role ASC, p1.name ASC LIMIT ?`)
        }</span> else<span class="cov0" title="0"> {
                query.WriteString(` ORDER BY p1.name ASC LIMIT ?`)
        }</span>

        <span class="cov8" title="1">args = append(args, limit+1)
        rows, e := ctx.TreeQuery(shard, query.String(), args...)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.IfNotNil(e)
        memSet := make([]*member, 0, limit+1)
        for rows.Next() </span><span class="cov8" title="1">{
                mem := member{}
                panic.IfNotNil(rows.Scan(&amp;mem.Id, &amp;mem.IsActive, &amp;mem.TotalRemainingTime, &amp;mem.TotalLoggedTime, &amp;mem.Role))
                memSet = append(memSet, &amp;mem)
        }</span>
        <span class="cov8" title="1">if len(memSet) == limit+1 </span><span class="cov0" title="0">{
                res.Members = memSet[:limit]
                res.More = true
        }</span> else<span class="cov8" title="1"> {
                res.Members = memSet
                res.More = false
        }</span>
        <span class="cov8" title="1">ctx.SetCacheValue(&amp;res, cacheKey)
        return &amp;res</span>
}

func dbGetMember(ctx ctx.Ctx, shard int, account, project, mem id.Id) *member <span class="cov8" title="1">{
        res := member{}
        cacheKey := cachekey.NewGet("project.dbGetMember", shard, account, project, mem).ProjectMember(account, project, mem)
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return &amp;res
        }</span>
        <span class="cov8" title="1">row := ctx.TreeQueryRow(shard, `SELECT id, isActive, role FROM projectMembers WHERE account=? AND project=? AND id=?`, account, project, mem)
        panic.IfNotNil(row.Scan(&amp;res.Id, &amp;res.IsActive, &amp;res.Role))
        ctx.SetCacheValue(&amp;res, cacheKey)
        return &amp;res</span>
}

func dbGetActivities(ctx ctx.Ctx, shard int, account, project id.Id, item, member *id.Id, occurredAfter, occurredBefore *time.Time, limit int) []*activity.Activity <span class="cov8" title="1">{
        ctx.ReturnBadRequestNowIf(occurredAfter != nil &amp;&amp; occurredBefore != nil, "only one of occurredAfter or occurredBefore can be set")
        res := make([]*activity.Activity, 0, limit)
        cacheKey := cachekey.NewGet("project.dbGetActivities", shard, account, project, item, member, occurredAfter, occurredBefore, limit).ProjectActivities(account, project)
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return res
        }</span>
        <span class="cov8" title="1">query := bytes.NewBufferString(`SELECT occurredOn, item, member, itemType, itemHasBeenDeleted, action, itemName, extraInfo FROM projectActivities WHERE account=? AND project=?`)
        args := make([]interface{}, 0, limit)
        args = append(args, account, project)
        if item != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND item=?`)
                args = append(args, *item)
        }</span>
        <span class="cov8" title="1">if member != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND member=?`)
                args = append(args, *member)
        }</span>
        <span class="cov8" title="1">if occurredAfter != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND occurredOn&gt;? ORDER BY occurredOn ASC`)
                args = append(args, occurredAfter)
        }</span>
        <span class="cov8" title="1">if occurredBefore != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND occurredOn&lt;? ORDER BY occurredOn DESC`)
                args = append(args, occurredBefore)
        }</span>
        <span class="cov8" title="1">if occurredAfter == nil &amp;&amp; occurredBefore == nil </span><span class="cov8" title="1">{
                query.WriteString(` ORDER BY occurredOn DESC`)
        }</span>
        <span class="cov8" title="1">query.WriteString(` LIMIT ?`)
        args = append(args, limit)
        rows, e := ctx.TreeQuery(shard, query.String(), args...)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.IfNotNil(e)
        for rows.Next() </span><span class="cov8" title="1">{
                act := activity.Activity{}
                panic.IfNotNil(rows.Scan(&amp;act.OccurredOn, &amp;act.Item, &amp;act.Member, &amp;act.ItemType, &amp;act.ItemHasBeenDeleted, &amp;act.Action, &amp;act.ItemName, &amp;act.ExtraInfo))
                res = append(res, &amp;act)
        }</span>
        <span class="cov8" title="1">ctx.SetCacheValue(res, cacheKey)
        return res</span>
}

func dbGetProjects(ctx ctx.Ctx, shard int, specificSqlFilterTxt string, account id.Id, me *id.Id, nameContains *string, createdOnAfter, createdOnBefore, startOnAfter, startOnBefore, dueOnAfter, dueOnBefore *time.Time, isArchived bool, sortBy cnst.SortBy, sortAsc bool, after *id.Id, limit int) *GetSetResult <span class="cov8" title="1">{
        res := GetSetResult{}
        cacheKey := cachekey.NewGet("project.dbGetProjects", shard, specificSqlFilterTxt, account, me, nameContains, createdOnAfter, createdOnBefore, startOnAfter, startOnBefore, dueOnAfter, dueOnBefore, isArchived, sortBy, sortAsc, after, limit).AccountProjectsSet(account)
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return &amp;res
        }</span>
        <span class="cov8" title="1">query := bytes.NewBufferString(`SELECT id, isArchived, name, hoursPerDay, daysPerWeek, createdOn, startOn, dueOn, fileCount, fileSize, isPublic FROM projects WHERE account=? AND isArchived=? %s`)
        args := make([]interface{}, 0, 14)
        args = append(args, account, isArchived)
        if me != nil </span><span class="cov0" title="0">{
                args = append(args, account, *me)
        }</span>
        <span class="cov8" title="1">if nameContains != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND name LIKE ?`)
                args = append(args, fmt.Sprintf(`%%%s%%`, strings.Trim(*nameContains, " ")))
        }</span>
        <span class="cov8" title="1">if createdOnAfter != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND createdOn&gt;?`)
                args = append(args, createdOnAfter)
        }</span>
        <span class="cov8" title="1">if createdOnBefore != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND createdOn&lt;?`)
                args = append(args, createdOnBefore)
        }</span>
        <span class="cov8" title="1">if startOnAfter != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND startOn&gt;?`)
                args = append(args, startOnAfter)
        }</span>
        <span class="cov8" title="1">if startOnBefore != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND startOn&lt;?`)
                args = append(args, startOnBefore)
        }</span>
        <span class="cov8" title="1">if dueOnAfter != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND dueOn&gt;?`)
                args = append(args, dueOnAfter)
        }</span>
        <span class="cov8" title="1">if dueOnBefore != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND dueOn&lt;?`)
                args = append(args, dueOnBefore)
        }</span>
        <span class="cov8" title="1">if after != nil </span><span class="cov8" title="1">{
                query.WriteString(fmt.Sprintf(` AND %s %s= (SELECT %s FROM projects WHERE account=? AND id=?) AND id &gt; ?`, sortBy, sortdir.GtLtSymbol(sortAsc), sortBy))
                args = append(args, account, *after, *after)
        }</span>
        <span class="cov8" title="1">query.WriteString(fmt.Sprintf(` ORDER BY %s %s, id LIMIT ?`, sortBy, sortdir.String(sortAsc)))
        args = append(args, limit+1)
        rows, e := ctx.TreeQuery(shard, fmt.Sprintf(query.String(), specificSqlFilterTxt), args...)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.IfNotNil(e)
        projSet := make([]*Project, 0, limit+1)
        idx := 0
        resIdx := map[string]int{}
        for rows.Next() </span><span class="cov8" title="1">{
                proj := Project{}
                panic.IfNotNil(rows.Scan(&amp;proj.Id, &amp;proj.IsArchived, &amp;proj.Name, &amp;proj.HoursPerDay, &amp;proj.DaysPerWeek, &amp;proj.CreatedOn, &amp;proj.StartOn, &amp;proj.DueOn, &amp;proj.FileCount, &amp;proj.FileSize, &amp;proj.IsPublic))
                projSet = append(projSet, &amp;proj)
                resIdx[proj.Id.String()] = idx
                idx++
        }</span>
        <span class="cov8" title="1">if len(projSet) &gt; 0 </span><span class="cov8" title="1">{ //populate task properties
                var i id.Id
                var description *string
                var totalRemainingTime, totalLoggedTime, minimumRemainingTime, linkedFileCount, chatCount, childCount, descendantCount uint64
                var isParallel bool
                query.Reset()
                args = make([]interface{}, 0, len(projSet)+1)
                args = append(args, account, projSet[0].Id)
                query.WriteString(`SELECT id, description, totalRemainingTime, totalLoggedTime, minimumRemainingTime, linkedFileCount, chatCount, childCount, descendantCount, isParallel FROM tasks WHERE account=? AND project=id AND project IN (?`)
                for _, proj := range projSet[1:] </span><span class="cov8" title="1">{
                        query.WriteString(`,?`)
                        args = append(args, proj.Id)
                }</span>
                <span class="cov8" title="1">query.WriteString(fmt.Sprintf(`) LIMIT %d`, len(projSet)))
                rows, e := ctx.TreeQuery(shard, query.String(), args...)
                if rows != nil </span><span class="cov8" title="1">{
                        defer rows.Close()
                }</span>
                <span class="cov8" title="1">panic.IfNotNil(e)
                for rows.Next() </span><span class="cov8" title="1">{
                        rows.Scan(&amp;i, &amp;description, &amp;totalRemainingTime, &amp;totalLoggedTime, &amp;minimumRemainingTime, &amp;linkedFileCount, &amp;chatCount, &amp;childCount, &amp;descendantCount, &amp;isParallel)
                        proj := projSet[resIdx[i.String()]]
                        proj.Description = description
                        proj.TotalRemainingTime = totalRemainingTime
                        proj.TotalLoggedTime = totalLoggedTime
                        proj.MinimumRemainingTime = minimumRemainingTime
                        proj.LinkedFileCount = linkedFileCount
                        proj.ChatCount = chatCount
                        proj.ChildCount = childCount
                        proj.DescendantCount = descendantCount
                        proj.IsParallel = isParallel
                }</span>
        }
        <span class="cov8" title="1">if len(projSet) == limit+1 </span><span class="cov8" title="1">{
                res.Projects = projSet[:limit]
                res.More = true
        }</span> else<span class="cov8" title="1"> {
                res.Projects = projSet
                res.More = false
        }</span>
        <span class="cov8" title="1">ctx.SetCacheValue(&amp;res, cacheKey)
        return &amp;res</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package project

import (
        "github.com/0xor1/trees/server/util/activity"
        "github.com/0xor1/trees/server/util/cnst"
        "github.com/0xor1/trees/server/util/ctx"
        "github.com/0xor1/trees/server/util/db"
        "github.com/0xor1/trees/server/util/endpoint"
        "github.com/0xor1/trees/server/util/field"
        "github.com/0xor1/trees/server/util/id"
        t "github.com/0xor1/trees/server/util/time"
        "github.com/0xor1/trees/server/util/validate"
        "net/http"
        "time"
)

type createArgs struct {
        Shard       int                 `json:"shard"`
        Account     id.Id               `json:"account"`
        Name        string              `json:"name"`
        Description *string             `json:"description"`
        HoursPerDay uint8               `json:"hoursPerDay"`
        DaysPerWeek uint8               `json:"daysPerWeek"`
        StartOn     *time.Time          `json:"startOn"`
        DueOn       *time.Time          `json:"dueOn"`
        IsParallel  bool                `json:"isParallel"`
        IsPublic    bool                `json:"isPublic"`
        Members     []*AddProjectMember `json:"members"`
}

var create = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/project/create",
        RequiresSession:          true,
        ExampleResponseStructure: &amp;Project{},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;createArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*createArgs)
                validate.MemberHasAccountAdminAccess(db.GetAccountRole(ctx, args.Shard, args.Account, ctx.Me()))
                ctx.ReturnBadRequestNowIf(args.IsPublic &amp;&amp; !db.GetAccount(ctx, args.Shard, args.Account).PublicProjectsEnabled, "public projects are not enabled on this account")

                validate.HoursPerDay(args.HoursPerDay)
                validate.DaysPerWeek(args.DaysPerWeek)

                project := &amp;Project{}
                project.Id = id.New()
                project.Name = args.Name
                project.HoursPerDay = args.HoursPerDay
                project.DaysPerWeek = args.DaysPerWeek
                project.Description = args.Description
                project.CreatedOn = t.Now()
                project.StartOn = args.StartOn
                project.DueOn = args.DueOn
                project.IsParallel = args.IsParallel
                project.IsPublic = args.IsPublic
                dbCreateProject(ctx, args.Shard, args.Account, project)
                if args.Account.Equal(ctx.Me()) </span><span class="cov0" title="0">{
                        addMem := &amp;AddProjectMember{}
                        addMem.Id = ctx.Me()
                        addMem.Role = cnst.ProjectAdmin
                        dbAddMemberOrSetActive(ctx, args.Shard, args.Account, project.Id, addMem)
                }</span>

                <span class="cov8" title="1">if len(args.Members) &gt; 0 </span><span class="cov0" title="0">{
                        addMembers.CtxHandler(ctx, &amp;addMembersArgs{
                                Shard:   args.Shard,
                                Account: args.Account,
                                Project: project.Id,
                                Members: args.Members,
                        })
                }</span>

                <span class="cov8" title="1">return project</span>
        },
}

type editArgs struct {
        Shard   int    `json:"shard"`
        Account id.Id  `json:"account"`
        Project id.Id  `json:"project"`
        Fields  Fields `json:"fields"`
}

var edit = &amp;endpoint.Endpoint{
        Path:            "/api/v1/project/edit",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;editArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*editArgs)
                accRole, projRole := db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me())
                if args.Fields.IsPublic != nil || args.Fields.IsArchived != nil </span><span class="cov8" title="1">{
                        //must be account owner/admin to set these fields
                        validate.MemberHasAccountAdminAccess(accRole)
                }</span> else<span class="cov0" title="0"> {
                        //other fields only require project admin access
                        validate.MemberHasProjectAdminAccess(accRole, projRole)
                }</span>
                <span class="cov8" title="1">if args.Fields.HoursPerDay != nil </span><span class="cov8" title="1">{
                        validate.HoursPerDay(args.Fields.HoursPerDay.Val)
                }</span>
                <span class="cov8" title="1">if args.Fields.DaysPerWeek != nil </span><span class="cov8" title="1">{
                        validate.DaysPerWeek(args.Fields.DaysPerWeek.Val)
                }</span>
                <span class="cov8" title="1">ctx.ReturnBadRequestNowIf(args.Fields.IsPublic != nil &amp;&amp; args.Fields.IsPublic.Val &amp;&amp; !db.GetAccount(ctx, args.Shard, args.Account).PublicProjectsEnabled, "public projects are not enabled on this account")
                dbEdit(ctx, args.Shard, args.Account, args.Project, args.Fields)
                return nil</span>
        },
}

type getArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
        Project id.Id `json:"project"`
}

var get = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/project/get",
        RequiresSession:          false,
        ExampleResponseStructure: &amp;Project{},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getArgs)
                validate.MemberHasProjectReadAccess(db.GetAccountAndProjectRolesAndProjectIsPublic(ctx, args.Shard, args.Account, args.Project, ctx.TryMe()))

                return dbGetProject(ctx, args.Shard, args.Account, args.Project)
        }</span>,
}

type getSetArgs struct {
        Shard           int         `json:"shard"`
        Account         id.Id       `json:"account"`
        NameContains    *string     `json:"nameContains"`
        CreatedOnAfter  *time.Time  `json:"createdOnAfter"`
        CreatedOnBefore *time.Time  `json:"createdOnBefore"`
        StartOnAfter    *time.Time  `json:"startOnAfter"`
        StartOnBefore   *time.Time  `json:"startOnBefore"`
        DueOnAfter      *time.Time  `json:"dueOnAfter"`
        DueOnBefore     *time.Time  `json:"dueOnBefore"`
        IsArchived      bool        `json:"isArchived"`
        SortBy          cnst.SortBy `json:"sortBy"`
        SortAsc         bool        `json:"sortAsc"`
        After           *id.Id      `json:"after"`
        Limit           int         `json:"limit"`
}

type GetSetResult struct {
        Projects []*Project `json:"projects"`
        More     bool       `json:"more"`
}

var getSet = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/project/getSet",
        RequiresSession:          false,
        ExampleResponseStructure: &amp;GetSetResult{Projects: []*Project{{}}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getSetArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getSetArgs)
                var myAccountRole *cnst.AccountRole
                if ctx.TryMe() != nil </span><span class="cov8" title="1">{
                        myAccountRole = db.GetAccountRole(ctx, args.Shard, args.Account, ctx.Me())
                }</span>
                <span class="cov8" title="1">args.Limit = validate.Limit(args.Limit, ctx.MaxProcessEntityCount())
                if myAccountRole == nil </span><span class="cov0" title="0">{
                        return dbGetPublicProjects(ctx, args.Shard, args.Account, args.NameContains, args.CreatedOnAfter, args.CreatedOnBefore, args.StartOnAfter, args.StartOnBefore, args.DueOnAfter, args.DueOnBefore, args.IsArchived, args.SortBy, args.SortAsc, args.After, args.Limit)
                }</span>
                <span class="cov8" title="1">if *myAccountRole != cnst.AccountOwner &amp;&amp; *myAccountRole != cnst.AccountAdmin </span><span class="cov0" title="0">{
                        return dbGetPublicAndSpecificAccessProjects(ctx, args.Shard, args.Account, ctx.Me(), args.NameContains, args.CreatedOnAfter, args.CreatedOnBefore, args.StartOnAfter, args.StartOnBefore, args.DueOnAfter, args.DueOnBefore, args.IsArchived, args.SortBy, args.SortAsc, args.After, args.Limit)
                }</span>
                <span class="cov8" title="1">return dbGetAllProjects(ctx, args.Shard, args.Account, args.NameContains, args.CreatedOnAfter, args.CreatedOnBefore, args.StartOnAfter, args.StartOnBefore, args.DueOnAfter, args.DueOnBefore, args.IsArchived, args.SortBy, args.SortAsc, args.After, args.Limit)</span>
        },
}

type deleteArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
        Project id.Id `json:"project"`
}

var delete = &amp;endpoint.Endpoint{
        Path:            "/api/v1/project/delete",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;deleteArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*deleteArgs)
                validate.MemberHasAccountAdminAccess(db.GetAccountRole(ctx, args.Shard, args.Account, ctx.Me()))
                dbDeleteProject(ctx, args.Shard, args.Account, args.Project)
                //TODO delete s3 data, uploaded files etc
                return nil
        }</span>,
}

type addMembersArgs struct {
        Shard   int                 `json:"shard"`
        Account id.Id               `json:"account"`
        Project id.Id               `json:"project"`
        Members []*AddProjectMember `json:"members"`
}

var addMembers = &amp;endpoint.Endpoint{
        Path:            "/api/v1/project/addMembers",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;addMembersArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*addMembersArgs)
                validate.EntityCount(len(args.Members), ctx.MaxProcessEntityCount())
                ctx.ReturnBadRequestNowIf(args.Account.Equal(ctx.Me()), "can't add/remove members to/from personal accounts")

                validate.MemberHasProjectAdminAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))
                ctx.ReturnNowIf(!dbGetProjectExists(ctx, args.Shard, args.Account, args.Project), http.StatusBadRequest, "no such project")

                for _, mem := range args.Members </span><span class="cov8" title="1">{
                        mem.Role.Validate()
                        accRole := db.GetAccountRole(ctx, args.Shard, args.Account, mem.Id)
                        ctx.ReturnBadRequestNowIf(accRole == nil, "user is not a member of the account")
                        if *accRole == cnst.AccountOwner || *accRole == cnst.AccountAdmin </span><span class="cov8" title="1">{
                                mem.Role = cnst.ProjectAdmin // account owners and admins cant be added to projects with privelages less than project admin
                        }</span>
                        <span class="cov8" title="1">dbAddMemberOrSetActive(ctx, args.Shard, args.Account, args.Project, mem)</span>
                }
                <span class="cov8" title="1">return nil</span>
        },
}

type setMemberRoleArgs struct {
        Shard   int              `json:"shard"`
        Account id.Id            `json:"account"`
        Project id.Id            `json:"project"`
        Member  id.Id            `json:"member"`
        Role    cnst.ProjectRole `json:"role"`
}

var setMemberRole = &amp;endpoint.Endpoint{
        Path:            "/api/v1/project/setMemberRole",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;setMemberRoleArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*setMemberRoleArgs)
                ctx.ReturnBadRequestNowIf(args.Account.Equal(ctx.Me()), "can't add/remove members to/from personal accounts")
                args.Role.Validate()

                validate.MemberHasProjectAdminAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))

                accRole, projectRole := db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, args.Member)
                ctx.ReturnBadRequestNowIf(projectRole == nil, "user is not a member of this project")
                if *projectRole != args.Role </span><span class="cov8" title="1">{
                        ctx.ReturnBadRequestNowIf(args.Role != cnst.ProjectAdmin &amp;&amp; (*accRole == cnst.AccountOwner || *accRole == cnst.AccountAdmin), "user is an account owner/admin, they can only be assigned project admin roles on projects") // account owners and admins can only be project admins
                        dbSetMemberRole(ctx, args.Shard, args.Account, args.Project, args.Member, args.Role)
                }</span>
                <span class="cov8" title="1">return nil</span>
        },
}

type removeMembersArgs struct {
        Shard   int     `json:"shard"`
        Account id.Id   `json:"account"`
        Project id.Id   `json:"project"`
        Members []id.Id `json:"members"`
}

var removeMembers = &amp;endpoint.Endpoint{
        Path:            "/api/v1/project/removeMembers",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;removeMembersArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*removeMembersArgs)
                validate.EntityCount(len(args.Members), ctx.MaxProcessEntityCount())
                ctx.ReturnBadRequestNowIf(args.Account.Equal(ctx.Me()), "can't add/remove members to/from personal accounts")
                validate.MemberHasProjectAdminAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))

                for _, mem := range args.Members </span><span class="cov8" title="1">{
                        dbSetMemberInactive(ctx, args.Shard, args.Account, args.Project, mem)
                }</span>
                <span class="cov8" title="1">return nil</span>
        },
}

type getMembersArgs struct {
        Shard                     int               `json:"shard"`
        Account                   id.Id             `json:"account"`
        Project                   id.Id             `json:"project"`
        Role                      *cnst.ProjectRole `json:"role,omitempty"`
        NameOrDisplayNameContains *string           `json:"nameOrDisplayNameContains,omitempty"`
        After                     *id.Id            `json:"after,omitempty"`
        Limit                     int               `json:"limit"`
}

type GetMembersResult struct {
        Members []*member `json:"members"`
        More    bool      `json:"more"`
}

var getMembers = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/project/getMembers",
        RequiresSession:          false,
        ExampleResponseStructure: &amp;GetMembersResult{Members: []*member{{}}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getMembersArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getMembersArgs)
                validate.MemberHasProjectReadAccess(db.GetAccountAndProjectRolesAndProjectIsPublic(ctx, args.Shard, args.Account, args.Project, ctx.TryMe()))
                return dbGetMembers(ctx, args.Shard, args.Account, args.Project, args.Role, args.NameOrDisplayNameContains, false, args.After, validate.Limit(args.Limit, ctx.MaxProcessEntityCount()))
        }</span>,
}

type getAtMentionsArgs struct {
        Shard                   int    `json:"shard"`
        Account                 id.Id  `json:"account"`
        Project                 id.Id  `json:"project"`
        NameOrDisplayNamePrefix string `json:"nameOrDisplayNamePrefix,omitempty"`
}

var getAtMentions = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/project/getAtMentions",
        RequiresSession:          false,
        ExampleResponseStructure: []*member{{}},
        GetArgsStruct: func() interface{} <span class="cov0" title="0">{
                return &amp;getMembersArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov0" title="0">{
                args := a.(*getAtMentionsArgs)
                validate.MemberHasProjectReadAccess(db.GetAccountAndProjectRolesAndProjectIsPublic(ctx, args.Shard, args.Account, args.Project, ctx.TryMe()))
                res := dbGetMembers(ctx, args.Shard, args.Account, args.Project, nil, &amp;args.NameOrDisplayNamePrefix, true, nil, 10)
                return res.Members
        }</span>,
}

type getMeArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
        Project id.Id `json:"project"`
}

var getMe = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/project/getMe",
        RequiresSession:          true,
        ExampleResponseStructure: &amp;member{},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getMeArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getMeArgs)
                return dbGetMember(ctx, args.Shard, args.Account, args.Project, ctx.Me())
        }</span>,
}

type getActivitiesArgs struct {
        Shard          int        `json:"shard"`
        Account        id.Id      `json:"account"`
        Project        id.Id      `json:"project"`
        Item           *id.Id     `json:"item,omitempty"`
        Member         *id.Id     `json:"member,omitempty"`
        OccurredAfter  *time.Time `json:"occurredAfter,omitempty"`
        OccurredBefore *time.Time `json:"occurredBefore,omitempty"`
        Limit          int        `json:"limit"`
}

var getActivities = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/project/getActivities",
        RequiresSession:          false,
        ExampleResponseStructure: []*activity.Activity{{}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getActivitiesArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getActivitiesArgs)
                ctx.ReturnBadRequestNowIf(args.OccurredAfter != nil &amp;&amp; args.OccurredBefore != nil, "only one of occurredAfter or occurredBefore can be set")
                validate.MemberHasProjectReadAccess(db.GetAccountAndProjectRolesAndProjectIsPublic(ctx, args.Shard, args.Account, args.Project, ctx.TryMe()))
                return dbGetActivities(ctx, args.Shard, args.Account, args.Project, args.Item, args.Member, args.OccurredAfter, args.OccurredBefore, validate.Limit(args.Limit, ctx.MaxProcessEntityCount()))
        }</span>,
}

var Endpoints = []*endpoint.Endpoint{
        create,
        edit,
        get,
        getSet,
        delete,
        addMembers,
        setMemberRole,
        removeMembers,
        getMembers,
        getMe,
        getActivities,
}

type member struct {
        Id                 id.Id            `json:"id"`
        TotalRemainingTime uint64           `json:"totalRemainingTime"`
        TotalLoggedTime    uint64           `json:"totalLoggedTime"`
        IsActive           bool             `json:"isActive"`
        Role               cnst.ProjectRole `json:"role"`
}

type Project struct {
        Id                   id.Id      `json:"id"`
        IsArchived           bool       `json:"isArchived"`
        Name                 string     `json:"name"`
        Description          *string    `json:"description"`
        HoursPerDay          uint8      `json:"hoursPerDay"`
        DaysPerWeek          uint8      `json:"daysPerWeek"`
        CreatedOn            time.Time  `json:"createdOn"`
        StartOn              *time.Time `json:"startOn,omitempty"`
        DueOn                *time.Time `json:"dueOn,omitempty"`
        TotalRemainingTime   uint64     `json:"totalRemainingTime"`
        TotalLoggedTime      uint64     `json:"totalLoggedTime"`
        MinimumRemainingTime uint64     `json:"minimumRemainingTime"`
        FileCount            uint64     `json:"fileCount"`
        FileSize             uint64     `json:"fileSize"`
        LinkedFileCount      uint64     `json:"linkedFileCount"`
        ChatCount            uint64     `json:"chatCount"`
        ChildCount           uint64     `json:"childCount"`
        DescendantCount      uint64     `json:"descendantCount"`
        IsParallel           bool       `json:"isParallel"`
        IsPublic             bool       `json:"isPublic"`
}

type Fields struct {
        // account owner/admin
        IsPublic *field.Bool `json:"isPublic,omitempty"`
        // account owner/admin
        IsArchived *field.Bool `json:"isArchived,omitempty"`
        // account owner/admin or project admin
        HoursPerDay *field.UInt8 `json:"hoursPerDay,omitempty"`
        // account owner/admin or project admin
        DaysPerWeek *field.UInt8 `json:"daysPerWeek,omitempty"`
        // account owner/admin or project admin
        StartOn *field.TimePtr `json:"startOn,omitempty"`
        // account owner/admin or project admin
        DueOn *field.TimePtr `json:"dueOn,omitempty"`
}

type AddProjectMember struct {
        Id   id.Id            `json:"id"`
        Role cnst.ProjectRole `json:"role"`
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package task

import (
        "github.com/0xor1/trees/server/util/clientsession"
        "github.com/0xor1/trees/server/util/cnst"
        "github.com/0xor1/trees/server/util/id"
)

type Client interface {
        Create(css *clientsession.Store, region cnst.Region, shard int, account, project, parent id.Id, previousSibling *id.Id, name string, description *string, isAbstract bool, isParallel *bool, member *id.Id, remainingTime *uint64) (*Task, error)
        Edit(css *clientsession.Store, region cnst.Region, shard int, account, project, task id.Id, fields Fields) error
        Move(css *clientsession.Store, region cnst.Region, shard int, account, project, task, parent id.Id, nextSibling *id.Id) error
        Delete(css *clientsession.Store, region cnst.Region, shard int, account, project, task id.Id) error
        Get(css *clientsession.Store, region cnst.Region, shard int, account, project id.Id, task id.Id) (*Task, error)
        GetChildren(css *clientsession.Store, region cnst.Region, shard int, account, project, parent id.Id, fromSibling *id.Id, limit int) (*getChildrenResp, error)
        GetAncestors(css *clientsession.Store, region cnst.Region, shard int, account, project, child id.Id, limit int) (*getAncestorsResp, error)
}

func NewClient(host string) Client <span class="cov8" title="1">{
        return &amp;client{
                host: host,
        }
}</span>

type client struct {
        host string
}

func (c *client) Create(css *clientsession.Store, region cnst.Region, shard int, account, project, parent id.Id, previousSibling *id.Id, name string, description *string, isAbstract bool, isParallel *bool, member *id.Id, totalRemainingTime *uint64) (*Task, error) <span class="cov8" title="1">{
        val, e := create.DoRequest(css, c.host, region, &amp;createArgs{
                Shard:              shard,
                Account:            account,
                Project:            project,
                Parent:             parent,
                PreviousSibling:    previousSibling,
                Name:               name,
                Description:        description,
                IsAbstract:         isAbstract,
                IsParallel:         isParallel,
                Member:             member,
                TotalRemainingTime: totalRemainingTime,
        }, nil, &amp;Task{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*Task), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) Edit(css *clientsession.Store, region cnst.Region, shard int, account, project, task id.Id, fields Fields) error <span class="cov8" title="1">{
        _, e := edit.DoRequest(css, c.host, region, &amp;editArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                Task:    task,
                Fields:  fields,
        }, nil, nil)
        return e
}</span>

func (c *client) Move(css *clientsession.Store, region cnst.Region, shard int, account, project, task, newParent id.Id, newPreviousSibling *id.Id) error <span class="cov8" title="1">{
        _, e := move.DoRequest(css, c.host, region, &amp;moveArgs{
                Shard:              shard,
                Account:            account,
                Project:            project,
                Task:               task,
                NewParent:          newParent,
                NewPreviousSibling: newPreviousSibling,
        }, nil, nil)
        return e
}</span>

func (c *client) Delete(css *clientsession.Store, region cnst.Region, shard int, account, project, task id.Id) error <span class="cov8" title="1">{
        _, e := delete.DoRequest(css, c.host, region, &amp;deleteArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                Task:    task,
        }, nil, nil)
        return e
}</span>

func (c *client) Get(css *clientsession.Store, region cnst.Region, shard int, account, project id.Id, task id.Id) (*Task, error) <span class="cov8" title="1">{
        val, e := get.DoRequest(css, c.host, region, &amp;getArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                Task:    task,
        }, nil, &amp;Task{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*Task), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) GetChildren(css *clientsession.Store, region cnst.Region, shard int, account, project, parent id.Id, fromSibling *id.Id, limit int) (*getChildrenResp, error) <span class="cov8" title="1">{
        val, e := getChildren.DoRequest(css, c.host, region, &amp;getChildrenArgs{
                Shard:       shard,
                Account:     account,
                Project:     project,
                Parent:      parent,
                FromSibling: fromSibling,
                Limit:       limit,
        }, nil, &amp;getChildrenResp{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*getChildrenResp), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) GetAncestors(css *clientsession.Store, region cnst.Region, shard int, account, project, child id.Id, limit int) (*getAncestorsResp, error) <span class="cov8" title="1">{
        val, e := getAncestors.DoRequest(css, c.host, region, &amp;getAncestorsArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                Child:   child,
                Limit:   limit,
        }, nil, &amp;getAncestorsResp{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*getAncestorsResp), e
        }</span>
        <span class="cov8" title="1">return nil, e</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package task

import (
        "github.com/0xor1/trees/server/util/cachekey"
        "github.com/0xor1/trees/server/util/ctx"
        "github.com/0xor1/trees/server/util/db"
        "github.com/0xor1/trees/server/util/id"
        "github.com/0xor1/panic"
)

func dbCreateTask(ctx ctx.Ctx, shard int, account, project, parent id.Id, nextSibling *id.Id, newTask *Task) <span class="cov8" title="1">{
        args := make([]interface{}, 0, 18)
        args = append(args, account, project, parent, ctx.Me())
        if nextSibling != nil </span><span class="cov8" title="1">{
                args = append(args, *nextSibling)
        }</span> else<span class="cov8" title="1"> {
                args = append(args, nil)
        }</span>
        <span class="cov8" title="1">args = append(args, newTask.Id)
        args = append(args, newTask.IsAbstract)
        args = append(args, newTask.Name)
        args = append(args, newTask.Description)
        args = append(args, newTask.CreatedOn)
        args = append(args, newTask.TotalRemainingTime)
        args = append(args, newTask.IsParallel)
        if newTask.Member != nil </span><span class="cov8" title="1">{
                args = append(args, *newTask.Member)
        }</span> else<span class="cov8" title="1"> {
                args = append(args, nil)
        }</span>
        <span class="cov8" title="1">ctx.TouchDlms(cachekey.NewSetDlms().ProjectActivities(account, project).TaskChildrenSet(account, project, parent).CombinedTaskAndTaskChildrenSets(account, project, db.TreeChangeHelper(ctx, shard, `CALL createTask(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`, args...)))</span>
}

func dbSetName(ctx ctx.Ctx, shard int, account, project, task id.Id, name string) <span class="cov8" title="1">{
        rows, e := ctx.TreeQuery(shard, `CALL setTaskName(?, ?, ?, ?, ?)`, account, project, task, ctx.Me(), name)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.IfNotNil(e)
        var timeLog *id.Id //on the first pass this is the parent (if any)
        var member *id.Id
        firstRow := true
        cacheKey := cachekey.NewSetDlms().ProjectActivities(account, project).Task(account, project, task)
        for rows.Next() </span><span class="cov8" title="1">{
                rows.Scan(&amp;timeLog, &amp;member)
                if firstRow &amp;&amp; timeLog != nil </span><span class="cov8" title="1">{ //timeLog is the parent id on the first row
                        cacheKey.TaskChildrenSet(account, project, *timeLog)
                }</span> else<span class="cov8" title="1"> if timeLog != nil &amp;&amp; member != nil </span><span class="cov0" title="0">{
                        cacheKey.TimeLog(account, project, *timeLog, &amp;task, member)
                }</span>
                <span class="cov8" title="1">firstRow = false</span>
        }
        <span class="cov8" title="1">ctx.TouchDlms(cacheKey)</span>
}

func dbSetDescription(ctx ctx.Ctx, shard int, account, project, task id.Id, description *string) <span class="cov8" title="1">{
        row := ctx.TreeQueryRow(shard, `CALL setTaskDescription(?, ?, ?, ?, ?)`, account, project, task, ctx.Me(), description)
        var parent *id.Id
        panic.IfNotNil(row.Scan(&amp;parent))
        cacheKey := cachekey.NewSetDlms().ProjectActivities(account, project).Task(account, project, task)
        if parent != nil </span><span class="cov8" title="1">{
                cacheKey.TaskChildrenSet(account, project, *parent)
        }</span>
        <span class="cov8" title="1">ctx.TouchDlms(cacheKey)</span>
}

func dbSetIsAbstract(ctx ctx.Ctx, shard int, account, project id.Id, task id.Id, isAbstract bool) <span class="cov8" title="1">{
        row := ctx.TreeQueryRow(shard, `CALL setTaskIsAbstract(?, ?, ?, ?, ?)`, account, project, task, ctx.Me(), isAbstract)
        var parent *id.Id
        panic.IfNotNil(row.Scan(&amp;parent))
        panic.If(parent == nil, "no change made")
        cacheKey := cachekey.NewSetDlms().ProjectActivities(account, project).Task(account, project, task)
        if parent != nil </span><span class="cov8" title="1">{
                cacheKey.TaskChildrenSet(account, project, *parent)
        }</span>
        <span class="cov8" title="1">ctx.TouchDlms(cacheKey)</span>
}

func dbSetIsParallel(ctx ctx.Ctx, shard int, account, project id.Id, task id.Id, isParallel bool) <span class="cov8" title="1">{
        cacheKey := cachekey.NewSetDlms().ProjectActivities(account, project)
        ctx.TouchDlms(cacheKey.CombinedTaskAndTaskChildrenSets(account, project, db.TreeChangeHelper(ctx, shard, `CALL setTaskIsParallel(?, ?, ?, ?, ?)`, account, project, task, ctx.Me(), isParallel)))
}</span>

func dbSetMember(ctx ctx.Ctx, shard int, account, project, task id.Id, member *id.Id) <span class="cov8" title="1">{
        var memArg []byte
        if member != nil </span><span class="cov8" title="1">{
                memArg = *member
        }</span>
        <span class="cov8" title="1">changeMade := false
        var parent id.Id
        var existingMember *id.Id
        panic.IfNotNil(ctx.TreeQueryRow(shard, `CALL setTaskMember(?, ?, ?, ?, ?)`, account, project, task, ctx.Me(), memArg).Scan(&amp;changeMade, &amp;parent, &amp;existingMember))
        ctx.ReturnBadRequestNowIf(!changeMade, "no change made")
        cacheKey := cachekey.NewSetDlms().ProjectActivities(account, project).TaskChildrenSet(account, project, parent).Task(account, project, task)
        if member != nil </span><span class="cov8" title="1">{
                cacheKey.ProjectMember(account, project, *member)
        }</span>
        <span class="cov8" title="1">if existingMember != nil </span><span class="cov8" title="1">{
                cacheKey.ProjectMember(account, project, *existingMember)
        }</span>
        <span class="cov8" title="1">ctx.TouchDlms(cacheKey)</span>
}

func dbMoveTask(ctx ctx.Ctx, shard int, account, project, task, newParent id.Id, newPreviousSibling *id.Id) <span class="cov8" title="1">{
        ctx.TouchDlms(cachekey.NewSetDlms().ProjectActivities(account, project).CombinedTaskAndTaskChildrenSets(account, project, db.TreeChangeHelper(ctx, shard, `CALL moveTask(?, ?, ?, ?, ?, ?)`, account, project, task, newParent, ctx.Me(), newPreviousSibling)))
}</span>

func dbDeleteTask(ctx ctx.Ctx, shard int, account, project, task id.Id) <span class="cov8" title="1">{
        rows, e := ctx.TreeQuery(shard, `CALL deleteTask(?, ?, ?, ?)`, account, project, task, ctx.Me())
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.IfNotNil(e)
        affectedTasks := make([]id.Id, 0, 100)
        updatedProjectMembers := make([]id.Id, 0, 100)
        cacheKey := cachekey.NewSetDlms().ProjectActivities(account, project)
        for rows.Next() </span><span class="cov8" title="1">{
                var i id.Id
                var j id.Id
                var k id.Id
                key := ""
                rows.Scan(&amp;i, &amp;j, &amp;k, &amp;key)
                switch key </span>{
                case "t":<span class="cov8" title="1">
                        affectedTasks = append(affectedTasks, i)</span>
                case "m":<span class="cov8" title="1">
                        updatedProjectMembers = append(updatedProjectMembers, i)</span>
                case "tl":<span class="cov0" title="0">
                        cacheKey.TimeLog(account, project, i, &amp;j, &amp;k)</span>
                default:<span class="cov0" title="0">
                        panic.If(true, "unknown key value in delete task rows")</span>
                }
        }
        <span class="cov8" title="1">ctx.TouchDlms(cacheKey.CombinedTaskAndTaskChildrenSets(account, project, affectedTasks).ProjectMembers(account, project, updatedProjectMembers))</span>
}

func dbGetTask(ctx ctx.Ctx, shard int, account, project id.Id, task id.Id) *Task <span class="cov8" title="1">{
        cacheKey := cachekey.NewGet("project.dbGetTask", shard, account, project, task).Task(account, project, task)
        res := Task{}
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return &amp;res
        }</span>
        <span class="cov8" title="1">panic.IfNotNil(ctx.TreeQueryRow(shard, `SELECT id, parent, firstChild, nextSibling, isAbstract, name, description, createdOn, totalRemainingTime, totalLoggedTime, minimumRemainingTime, linkedFileCount, chatCount, childCount, descendantCount, isParallel, member FROM tasks WHERE account = ? AND project = ? AND id = ?`, account, project, task).Scan(&amp;res.Id, &amp;res.Parent, &amp;res.FirstChild, &amp;res.NextSibling, &amp;res.IsAbstract, &amp;res.Name, &amp;res.Description, &amp;res.CreatedOn, &amp;res.TotalRemainingTime, &amp;res.TotalLoggedTime, &amp;res.MinimumRemainingTime, &amp;res.LinkedFileCount, &amp;res.ChatCount, &amp;res.ChildCount, &amp;res.DescendantCount, &amp;res.IsParallel, &amp;res.Member))
        ctx.SetCacheValue(res, cacheKey)
        return &amp;res</span>
}

func dbGetChildTasks(ctx ctx.Ctx, shard int, account, project, parent id.Id, fromSibling *id.Id, limit int) *getChildrenResp <span class="cov8" title="1">{
        res := getChildrenResp{}
        cacheKey := cachekey.NewGet("project.dbGetChildTasks", shard, account, project, parent, fromSibling, limit).TaskChildrenSet(account, project, parent)
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return &amp;res
        }</span>
        <span class="cov8" title="1">rows, e := ctx.TreeQuery(shard, `CALL getChildTasks(?, ?, ?, ?, ?)`, account, project, parent, fromSibling, limit+1)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.IfNotNil(e)
        childSet := make([]*Task, 0, limit+1)
        for rows.Next() </span><span class="cov8" title="1">{
                ta := Task{}
                panic.IfNotNil(rows.Scan(&amp;ta.Id, &amp;ta.Parent, &amp;ta.FirstChild, &amp;ta.NextSibling, &amp;ta.IsAbstract, &amp;ta.Name, &amp;ta.Description, &amp;ta.CreatedOn, &amp;ta.TotalRemainingTime, &amp;ta.TotalLoggedTime, &amp;ta.MinimumRemainingTime, &amp;ta.LinkedFileCount, &amp;ta.ChatCount, &amp;ta.ChildCount, &amp;ta.DescendantCount, &amp;ta.IsParallel, &amp;ta.Member))
                nilOutPropertiesThatAreNotNilInTheDb(&amp;ta)
                childSet = append(childSet, &amp;ta)
        }</span>
        <span class="cov8" title="1">if len(childSet) == limit+1 </span><span class="cov8" title="1">{
                res.Children = childSet[:limit]
                res.More = true
        }</span> else<span class="cov8" title="1"> {
                res.Children = childSet
                res.More = false
        }</span>
        <span class="cov8" title="1">ctx.SetCacheValue(res, cacheKey)
        return &amp;res</span>
}

func dbGetAncestorTasks(ctx ctx.Ctx, shard int, account, project, child id.Id, limit int) *getAncestorsResp <span class="cov8" title="1">{
        res := getAncestorsResp{}
        cacheKey := cachekey.NewGet("project.dbGetAncestorTasks", shard, account, project, child, limit).Task(account, project, child)
        innerCacheKey := cachekey.NewGet("project.dbGetAncestorTasks-inner", shard, account, project, child, limit)
        innerRes := true
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov8" title="1">{
                for _, a := range res.Ancestors </span><span class="cov8" title="1">{ //we have to check each task dlm here to ensure the upwards ancestor tree structure is unchanged since the result was cached
                        innerCacheKey.Task(account, project, a.Id)
                }</span>
                <span class="cov8" title="1">if ctx.GetCacheValue(&amp;innerRes, innerCacheKey) </span><span class="cov0" title="0">{
                        return &amp;res
                }</span>
                <span class="cov8" title="1">innerCacheKey.DlmKeys = map[string]bool{}</span>
        }
        <span class="cov8" title="1">rows, e := ctx.TreeQuery(shard, `CALL getAncestorTasks(?, ?, ?, ?)`, account, project, child, limit+1)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.IfNotNil(e)
        ancestorSet := make([]*Ancestor, 0, limit+1)
        for rows.Next() </span><span class="cov8" title="1">{
                an := Ancestor{}
                panic.IfNotNil(rows.Scan(&amp;an.Id, &amp;an.Name))
                innerCacheKey.Task(account, project, an.Id)
                ancestorSet = append(ancestorSet, &amp;an)
        }</span>
        <span class="cov8" title="1">if len(ancestorSet) == limit+1 </span><span class="cov0" title="0">{
                res.Ancestors = ancestorSet[:limit]
                res.More = true
        }</span> else<span class="cov8" title="1"> {
                res.Ancestors = ancestorSet
                res.More = false
        }</span>
        <span class="cov8" title="1">ctx.SetCacheValue(res, cacheKey)
        ctx.SetCacheValue(true, innerCacheKey)
        return &amp;res</span>
}

func nilOutPropertiesThatAreNotNilInTheDb(ta *Task) <span class="cov8" title="1">{
        if !ta.IsAbstract </span><span class="cov8" title="1">{
                ta.MinimumRemainingTime = nil
                ta.ChildCount = nil
                ta.DescendantCount = nil
                ta.IsParallel = nil
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package task

import (
        "github.com/0xor1/trees/server/util/ctx"
        "github.com/0xor1/trees/server/util/db"
        "github.com/0xor1/trees/server/util/endpoint"
        "github.com/0xor1/trees/server/util/field"
        "github.com/0xor1/trees/server/util/id"
        t "github.com/0xor1/trees/server/util/time"
        "github.com/0xor1/trees/server/util/validate"
        "time"
)

type createArgs struct {
        Shard              int     `json:"shard"`
        Account            id.Id   `json:"account"`
        Project            id.Id   `json:"project"`
        Parent             id.Id   `json:"parent"`
        PreviousSibling    *id.Id  `json:"previousSibling,omitempty"`
        Name               string  `json:"name"`
        Description        *string `json:"description,omitempty"`
        IsAbstract         bool    `json:"isAbstract"`
        IsParallel         *bool   `json:"isParallel,omitempty"`
        Member             *id.Id  `json:"member,omitempty"`
        TotalRemainingTime *uint64 `json:"totalRemainingTime,omitempty"`
}

var create = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/task/create",
        RequiresSession:          true,
        ExampleResponseStructure: &amp;Task{},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;createArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*createArgs)
                validate.MemberHasProjectWriteAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))
                if args.IsAbstract </span><span class="cov8" title="1">{
                        ctx.ReturnBadRequestNowIf(args.IsParallel == nil, "abstract tasks must have isParallel set")
                        ctx.ReturnBadRequestNowIf(args.Member != nil, "abstract tasks do not accept a member arg")
                        ctx.ReturnBadRequestNowIf(args.TotalRemainingTime != nil, "abstract tasks do not accept a totalRemainingTime arg")
                }</span> else<span class="cov8" title="1"> {
                        ctx.ReturnBadRequestNowIf(args.IsParallel != nil, "concrete tasks do not accept an isParallel arg")
                        ctx.ReturnBadRequestNowIf(args.TotalRemainingTime == nil, "concrete tasks must have a totalRemainingTime set")
                }</span>
                <span class="cov8" title="1">zeroVal := uint64(0)
                zeroPtr := &amp;zeroVal
                if !args.IsAbstract </span><span class="cov8" title="1">{
                        zeroPtr = nil
                }</span> else<span class="cov8" title="1"> {
                        args.TotalRemainingTime = zeroPtr
                }</span>
                <span class="cov8" title="1">if args.Member != nil </span><span class="cov8" title="1">{ //if a member is being assigned to the task then we need to check they have project write access
                        validate.MemberIsAProjectMemberWithWriteAccess(db.GetProjectRole(ctx, args.Shard, args.Account, args.Project, *args.Member))
                }</span>
                <span class="cov8" title="1">newTask := &amp;Task{
                        Id:                   id.New(),
                        IsAbstract:           args.IsAbstract,
                        Name:                 args.Name,
                        Description:          args.Description,
                        CreatedOn:            t.Now(),
                        TotalRemainingTime:   *args.TotalRemainingTime,
                        MinimumRemainingTime: zeroPtr,
                        ChildCount:           zeroPtr,
                        DescendantCount:      zeroPtr,
                        IsParallel:           args.IsParallel,
                        Member:               args.Member,
                }
                dbCreateTask(ctx, args.Shard, args.Account, args.Project, args.Parent, args.PreviousSibling, newTask)
                return newTask</span>
        },
}

type editArgs struct {
        Shard   int    `json:"shard"`
        Account id.Id  `json:"account"`
        Project id.Id  `json:"project"`
        Task    id.Id  `json:"task"`
        Fields  Fields `json:"fields"`
}

var edit = &amp;endpoint.Endpoint{
        Path:            "/api/v1/task/edit",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;editArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*editArgs)
                if args.Fields.Name != nil &amp;&amp; args.Project.Equal(args.Task) </span><span class="cov8" title="1">{
                        validate.MemberHasAccountAdminAccess(db.GetAccountRole(ctx, args.Shard, args.Account, ctx.Me()))
                }</span> else<span class="cov8" title="1"> {
                        validate.MemberHasProjectWriteAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))
                }</span>
                <span class="cov8" title="1">if args.Fields.Name != nil </span><span class="cov8" title="1">{
                        dbSetName(ctx, args.Shard, args.Account, args.Project, args.Task, args.Fields.Name.Val)
                }</span>
                <span class="cov8" title="1">if args.Fields.Description != nil </span><span class="cov8" title="1">{
                        dbSetDescription(ctx, args.Shard, args.Account, args.Project, args.Task, args.Fields.Description.Val)
                }</span>
                <span class="cov8" title="1">if args.Fields.IsAbstract != nil </span><span class="cov8" title="1">{ //must do isAbstract first before any other tree altering operations
                        ctx.ReturnBadRequestNowIf(args.Project.Equal(args.Task), "can't toggle isAbstract on project task node")
                        dbSetIsAbstract(ctx, args.Shard, args.Account, args.Project, args.Task, args.Fields.IsAbstract.Val)
                }</span>
                <span class="cov8" title="1">if args.Fields.IsParallel != nil </span><span class="cov8" title="1">{
                        dbSetIsParallel(ctx, args.Shard, args.Account, args.Project, args.Task, args.Fields.IsParallel.Val)
                }</span>
                <span class="cov8" title="1">if args.Fields.Member != nil </span><span class="cov8" title="1">{
                        if args.Fields.Member.Val != nil </span><span class="cov8" title="1">{
                                validate.MemberIsAProjectMemberWithWriteAccess(db.GetProjectRole(ctx, args.Shard, args.Account, args.Project, *args.Fields.Member.Val))
                        }</span>
                        <span class="cov8" title="1">dbSetMember(ctx, args.Shard, args.Account, args.Project, args.Task, args.Fields.Member.Val)</span>
                }
                <span class="cov8" title="1">if args.Fields.RemainingTime != nil </span><span class="cov8" title="1">{
                        db.SetRemainingTimeAndOrLogTime(ctx, args.Shard, args.Account, args.Project, args.Task, &amp;args.Fields.RemainingTime.Val, nil, nil)
                }</span>
                <span class="cov8" title="1">return nil</span>
        },
}

type moveArgs struct {
        Shard              int    `json:"shard"`
        Account            id.Id  `json:"account"`
        Project            id.Id  `json:"project"`
        Task               id.Id  `json:"task"`
        NewParent          id.Id  `json:"newParent"`
        NewPreviousSibling *id.Id `json:"newPreviousSibling"`
}

var move = &amp;endpoint.Endpoint{
        Path:            "/api/v1/task/move",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;moveArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*moveArgs)
                validate.MemberHasProjectWriteAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))

                dbMoveTask(ctx, args.Shard, args.Account, args.Project, args.Task, args.NewParent, args.NewPreviousSibling)
                return nil
        }</span>,
}

type deleteArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
        Project id.Id `json:"project"`
        Task    id.Id `json:"task"`
}

var delete = &amp;endpoint.Endpoint{
        Path:            "/api/v1/task/delete",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;deleteArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*deleteArgs)
                ctx.ReturnBadRequestNowIf(args.Project.Equal(args.Task), "use project delete endpoint to delete the project node")
                validate.MemberHasProjectWriteAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))

                dbDeleteTask(ctx, args.Shard, args.Account, args.Project, args.Task)
                return nil
        }</span>,
}

type getArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
        Project id.Id `json:"project"`
        Task    id.Id `json:"task"`
}

var get = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/task/get",
        RequiresSession:          false,
        ExampleResponseStructure: &amp;Task{},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getArgs)
                validate.MemberHasProjectReadAccess(db.GetAccountAndProjectRolesAndProjectIsPublic(ctx, args.Shard, args.Account, args.Project, ctx.TryMe()))
                validate.EntityCount(len(args.Task), ctx.MaxProcessEntityCount())
                return dbGetTask(ctx, args.Shard, args.Account, args.Project, args.Task)
        }</span>,
}

type getChildrenArgs struct {
        Shard       int    `json:"shard"`
        Account     id.Id  `json:"account"`
        Project     id.Id  `json:"project"`
        Parent      id.Id  `json:"parent"`
        FromSibling *id.Id `json:"fromSibling,omitempty"`
        Limit       int    `json:"limit"`
}

type getChildrenResp struct {
        Children []*Task `json:"children"`
        More     bool    `json:"more"`
}

var getChildren = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/task/getChildren",
        RequiresSession:          false,
        ExampleResponseStructure: &amp;getChildrenResp{Children: []*Task{{}}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getChildrenArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getChildrenArgs)
                validate.MemberHasProjectReadAccess(db.GetAccountAndProjectRolesAndProjectIsPublic(ctx, args.Shard, args.Account, args.Project, ctx.TryMe()))
                validate.Limit(args.Limit, ctx.MaxProcessEntityCount())
                return dbGetChildTasks(ctx, args.Shard, args.Account, args.Project, args.Parent, args.FromSibling, args.Limit)
        }</span>,
}

type getAncestorsArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
        Project id.Id `json:"project"`
        Child   id.Id `json:"child"`
        Limit   int   `json:"limit"`
}

type getAncestorsResp struct {
        Ancestors []*Ancestor `json:"ancestors"`
        More      bool        `json:"more"`
}

var getAncestors = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/task/getAncestors",
        RequiresSession:          false,
        ExampleResponseStructure: &amp;getAncestorsResp{Ancestors: []*Ancestor{{}}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getAncestorsArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getAncestorsArgs)
                validate.MemberHasProjectReadAccess(db.GetAccountAndProjectRolesAndProjectIsPublic(ctx, args.Shard, args.Account, args.Project, ctx.TryMe()))
                validate.Limit(args.Limit, ctx.MaxProcessEntityCount())
                return dbGetAncestorTasks(ctx, args.Shard, args.Account, args.Project, args.Child, args.Limit)
        }</span>,
}

var Endpoints = []*endpoint.Endpoint{
        create,
        edit,
        move,
        delete,
        get,
        getChildren,
        getAncestors,
}

type Task struct {
        Id                   id.Id     `json:"id"`
        Parent               *id.Id    `json:"parent,omitempty"`
        FirstChild           *id.Id    `json:"firstChild,omitempty"`
        NextSibling          *id.Id    `json:"nextSibling,omitempty"`
        IsAbstract           bool      `json:"isAbstract"`
        Name                 string    `json:"name"`
        Description          *string   `json:"description"`
        CreatedOn            time.Time `json:"createdOn"`
        TotalRemainingTime   uint64    `json:"totalRemainingTime"`
        TotalLoggedTime      uint64    `json:"totalLoggedTime"`
        MinimumRemainingTime *uint64   `json:"minimumRemainingTime,omitempty"` //only abstract tasks
        LinkedFileCount      uint64    `json:"linkedFileCount"`
        ChatCount            uint64    `json:"chatCount"`
        ChildCount           *uint64   `json:"childCount,omitempty"`      //only abstract tasks
        DescendantCount      *uint64   `json:"descendantCount,omitempty"` //only abstract tasks
        IsParallel           *bool     `json:"isParallel,omitempty"`      //only abstract tasks
        Member               *id.Id    `json:"member,omitempty"`          //only task tasks
}

type Ancestor struct {
        Id   id.Id  `json:"id"`
        Name string `json:"name"`
        //may want to add on time values here to render progress bars within breadcrumb ui component
}

type Fields struct {
        Name          *field.String    `json:"name,omitempty"`
        Description   *field.StringPtr `json:"description,omitempty"`
        IsAbstract    *field.Bool      `json:"isAbstract,omitempty"`    //limit to only editable on abstract tasks which have no children and concrete tasks which have no timelogs
        IsParallel    *field.Bool      `json:"isParallel,omitempty"`    //only relevant to abstract tasks
        Member        *field.IdPtr     `json:"member,omitempty"`        //only relevant to concrete tasks
        RemainingTime *field.UInt64    `json:"remainingTime,omitempty"` //only relevant to concrete tasks
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package timelog

import (
        "github.com/0xor1/trees/server/util/clientsession"
        "github.com/0xor1/trees/server/util/cnst"
        "github.com/0xor1/trees/server/util/id"
        tlog "github.com/0xor1/trees/server/util/timelog"
)

type Client interface {
        Create(css *clientsession.Store, region cnst.Region, shard int, account, project, task id.Id, duration uint64, note *string) (*tlog.TimeLog, error)                                          //only applys to task tasks
        CreateAndSetRemainingTime(css *clientsession.Store, region cnst.Region, shard int, account, project, task id.Id, remainingTime uint64, duration uint64, note *string) (*tlog.TimeLog, error) //only applys to task tasks
        Edit(css *clientsession.Store, region cnst.Region, shard int, account, project, timeLog id.Id, fields Fields) error
        Delete(css *clientsession.Store, region cnst.Region, shard int, account, project, timeLog id.Id) error
        Get(css *clientsession.Store, region cnst.Region, shard int, account, project id.Id, task, member, timeLog *id.Id, sortAsc bool, after *id.Id, limit int) (*getResp, error)
}

func NewClient(host string) Client <span class="cov8" title="1">{
        return &amp;client{
                host: host,
        }
}</span>

type client struct {
        host string
}

func (c *client) Create(css *clientsession.Store, region cnst.Region, shard int, account, project, task id.Id, duration uint64, note *string) (*tlog.TimeLog, error) <span class="cov8" title="1">{
        val, e := create.DoRequest(css, c.host, region, &amp;createArgs{
                Shard:    shard,
                Account:  account,
                Project:  project,
                Task:     task,
                Duration: duration,
                Note:     note,
        }, nil, &amp;tlog.TimeLog{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*tlog.TimeLog), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) CreateAndSetRemainingTime(css *clientsession.Store, region cnst.Region, shard int, account, project, task id.Id, remainingTime uint64, duration uint64, note *string) (*tlog.TimeLog, error) <span class="cov8" title="1">{
        val, e := createAndSetRemainingTime.DoRequest(css, c.host, region, &amp;createAndSetRemainingTimeArgs{
                Shard:         shard,
                Account:       account,
                Project:       project,
                Task:          task,
                RemainingTime: remainingTime,
                Duration:      duration,
                Note:          note,
        }, nil, &amp;tlog.TimeLog{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*tlog.TimeLog), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}

func (c *client) Edit(css *clientsession.Store, region cnst.Region, shard int, account, project, timeLog id.Id, fields Fields) error <span class="cov8" title="1">{
        _, e := edit.DoRequest(css, c.host, region, &amp;editArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                TimeLog: timeLog,
                Fields:  fields,
        }, nil, nil)
        return e
}</span>

func (c *client) Delete(css *clientsession.Store, region cnst.Region, shard int, account, project, timeLog id.Id) error <span class="cov8" title="1">{
        _, e := delete.DoRequest(css, c.host, region, &amp;deleteArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                TimeLog: timeLog,
        }, nil, nil)
        return e
}</span>

func (c *client) Get(css *clientsession.Store, region cnst.Region, shard int, account, project id.Id, task, member, timeLog *id.Id, sortAsc bool, after *id.Id, limit int) (*getResp, error) <span class="cov8" title="1">{
        val, e := get.DoRequest(css, c.host, region, &amp;getArgs{
                Shard:   shard,
                Account: account,
                Project: project,
                Task:    task,
                Member:  member,
                TimeLog: timeLog,
                SortAsc: sortAsc,
                After:   after,
                Limit:   limit,
        }, nil, &amp;getResp{})
        if val != nil </span><span class="cov8" title="1">{
                return val.(*getResp), e
        }</span>
        <span class="cov0" title="0">return nil, e</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package timelog

import (
        "github.com/0xor1/trees/server/util/cachekey"
        "github.com/0xor1/trees/server/util/ctx"
        "github.com/0xor1/trees/server/util/db"
        "github.com/0xor1/trees/server/util/id"
        "github.com/0xor1/trees/server/util/sortdir"
        tlog "github.com/0xor1/trees/server/util/timelog"
        "bytes"
        "fmt"
        "github.com/0xor1/panic"
)

func dbGetTimeLog(ctx ctx.Ctx, shard int, account, project, timeLog id.Id) *tlog.TimeLog <span class="cov8" title="1">{
        cacheKey := cachekey.NewGet("timelog.dbGetTimeLog", shard, account, project, timeLog).TimeLog(account, project, timeLog, nil, nil)
        tl := tlog.TimeLog{}
        if ctx.GetCacheValue(&amp;tl, cacheKey) </span><span class="cov0" title="0">{
                return &amp;tl
        }</span>
        <span class="cov8" title="1">panic.IfNotNil(ctx.TreeQueryRow(shard, `SELECT project, task, id, member, loggedOn, taskHasBeenDeleted, taskName, duration, note FROM timeLogs WHERE account=? AND project=? AND id=?`, account, project, timeLog).Scan(&amp;tl.Project, &amp;tl.Task, &amp;tl.Id, &amp;tl.Member, &amp;tl.LoggedOn, &amp;tl.TaskHasBeenDeleted, &amp;tl.TaskName, &amp;tl.Duration, &amp;tl.Note))
        ctx.SetCacheValue(tl, cacheKey)
        return &amp;tl</span>
}

func dbSetDuration(ctx ctx.Ctx, shard int, account, project, task, member, timeLog id.Id, duration uint64) <span class="cov8" title="1">{
        ctx.TouchDlms(cachekey.NewSetDlms().CombinedTaskAndTaskChildrenSets(account, project, db.TreeChangeHelper(ctx, shard, `CALL setTimeLogDuration(?, ?, ?, ?, ?)`, account, project, timeLog, ctx.Me(), duration)).TimeLog(account, project, timeLog, &amp;task, &amp;member).ProjectActivities(account, project))
}</span>

func dbSetNote(ctx ctx.Ctx, shard int, account, project, task, member, timeLog id.Id, note *string) <span class="cov8" title="1">{
        db.MakeChangeHelper(ctx, shard, `CALL setTimeLogNote(?, ?, ?, ?, ?)`, account, project, timeLog, ctx.Me(), note)
        ctx.TouchDlms(cachekey.NewSetDlms().TimeLog(account, project, timeLog, &amp;task, &amp;member).ProjectActivities(account, project))
}</span>

func dbDelete(ctx ctx.Ctx, shard int, account, project, task, member, timeLog id.Id) <span class="cov8" title="1">{
        ctx.TouchDlms(cachekey.NewSetDlms().CombinedTaskAndTaskChildrenSets(account, project, db.TreeChangeHelper(ctx, shard, `CALL deleteTimeLog(?, ?, ?, ?)`, account, project, timeLog, ctx.Me())).TimeLog(account, project, timeLog, &amp;task, &amp;member).ProjectActivities(account, project))
}</span>

func dbGetTimeLogs(ctx ctx.Ctx, shard int, account, project id.Id, task, member, timeLog *id.Id, sortAsc bool, after *id.Id, limit int) *getResp <span class="cov8" title="1">{
        if timeLog != nil </span><span class="cov8" title="1">{
                return &amp;getResp{TimeLogs: []*tlog.TimeLog{dbGetTimeLog(ctx, shard, account, project, *timeLog)}}
        }</span>
        <span class="cov8" title="1">cacheKey := cachekey.NewGet("timelog.dbGetTimeLogs", shard, account, project, task, member, timeLog, sortAsc, after, limit)
        if task != nil </span><span class="cov0" title="0">{
                cacheKey.TaskTimeLogSet(account, project, *task, member)
        }</span>
        <span class="cov8" title="1">if member != nil </span><span class="cov0" title="0">{
                cacheKey.ProjectMemberTimeLogSet(account, project, *member)
        }</span>
        <span class="cov8" title="1">if task == nil &amp;&amp; member == nil </span><span class="cov8" title="1">{
                cacheKey.ProjectTimeLogSet(account, project)
        }</span>
        <span class="cov8" title="1">res := getResp{}
        if ctx.GetCacheValue(&amp;res, cacheKey) </span><span class="cov0" title="0">{
                return &amp;res
        }</span>
        <span class="cov8" title="1">query := bytes.NewBufferString(`SELECT project, task, id, member, loggedOn, taskHasBeenDeleted, taskName, duration, note FROM timeLogs WHERE account=? AND project=?`)
        args := make([]interface{}, 0, 9)
        args = append(args, account, project)
        if task != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND task=?`)
                args = append(args, *task)
        }</span>
        <span class="cov8" title="1">if member != nil </span><span class="cov0" title="0">{
                query.WriteString(` AND member=?`)
                args = append(args, *member)
        }</span>
        <span class="cov8" title="1">if after != nil </span><span class="cov8" title="1">{
                query.WriteString(fmt.Sprintf(` AND loggedOn %s= (SELECT loggedOn FROM timeLogs WHERE account=? AND project=? AND id=?) AND id %s ?`, sortdir.GtLtSymbol(sortAsc), sortdir.GtLtSymbol(sortAsc)))
                args = append(args, account, project, *after, *after)
        }</span>
        <span class="cov8" title="1">query.WriteString(fmt.Sprintf(` ORDER BY loggedOn %s, id %s LIMIT ?`, sortdir.String(sortAsc), sortdir.String(sortAsc)))
        args = append(args, limit+1)
        rows, e := ctx.TreeQuery(shard, query.String(), args...)
        if rows != nil </span><span class="cov8" title="1">{
                defer rows.Close()
        }</span>
        <span class="cov8" title="1">panic.IfNotNil(e)
        timeLogsSet := make([]*tlog.TimeLog, 0, limit+1)
        for rows.Next() </span><span class="cov8" title="1">{
                tl := tlog.TimeLog{}
                panic.IfNotNil(rows.Scan(&amp;tl.Project, &amp;tl.Task, &amp;tl.Id, &amp;tl.Member, &amp;tl.LoggedOn, &amp;tl.TaskHasBeenDeleted, &amp;tl.TaskName, &amp;tl.Duration, &amp;tl.Note))
                timeLogsSet = append(timeLogsSet, &amp;tl)
        }</span>
        <span class="cov8" title="1">if len(timeLogsSet) == limit+1 </span><span class="cov0" title="0">{
                res.TimeLogs = timeLogsSet[:limit]
                res.More = true
        }</span> else<span class="cov8" title="1"> {
                res.TimeLogs = timeLogsSet
                res.More = false
        }</span>
        <span class="cov8" title="1">ctx.SetCacheValue(res, cacheKey)
        return &amp;res</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package timelog

import (
        "github.com/0xor1/trees/server/util/ctx"
        "github.com/0xor1/trees/server/util/db"
        "github.com/0xor1/trees/server/util/endpoint"
        "github.com/0xor1/trees/server/util/field"
        "github.com/0xor1/trees/server/util/id"
        "github.com/0xor1/trees/server/util/timelog"
        "github.com/0xor1/trees/server/util/validate"
)

type createArgs struct {
        Shard    int     `json:"shard"`
        Account  id.Id   `json:"account"`
        Project  id.Id   `json:"project"`
        Task     id.Id   `json:"task"`
        Duration uint64  `json:"duration"`
        Note     *string `json:"note,omitempty"`
}

var create = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/timeLog/create",
        RequiresSession:          true,
        ExampleResponseStructure: &amp;timelog.TimeLog{},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;createArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*createArgs)
                return db.SetRemainingTimeAndOrLogTime(ctx, args.Shard, args.Account, args.Project, args.Task, nil, &amp;args.Duration, args.Note)
        }</span>,
}

type createAndSetRemainingTimeArgs struct {
        Shard         int     `json:"shard"`
        Account       id.Id   `json:"account"`
        Project       id.Id   `json:"project"`
        Task          id.Id   `json:"task"`
        RemainingTime uint64  `json:"remainingTime"`
        Duration      uint64  `json:"duration"`
        Note          *string `json:"note,omitempty"`
}

var createAndSetRemainingTime = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/timeLog/createAndSetRemainingTime",
        RequiresSession:          true,
        ExampleResponseStructure: &amp;timelog.TimeLog{},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;createAndSetRemainingTimeArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*createAndSetRemainingTimeArgs)
                return db.SetRemainingTimeAndOrLogTime(ctx, args.Shard, args.Account, args.Project, args.Task, &amp;args.RemainingTime, &amp;args.Duration, args.Note)
        }</span>,
}

type editArgs struct {
        Shard   int    `json:"shard"`
        Account id.Id  `json:"account"`
        Project id.Id  `json:"project"`
        TimeLog id.Id  `json:"timeLog"`
        Fields  Fields `json:"fields"`
}

var edit = &amp;endpoint.Endpoint{
        Path:            "/api/v1/timeLog/edit",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;editArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*editArgs)
                ctx.ReturnBadRequestNowIf(args.Fields.Duration != nil &amp;&amp; args.Fields.Duration.Val == 0, "duration must be &gt; 0")
                tl := dbGetTimeLog(ctx, args.Shard, args.Account, args.Project, args.TimeLog)
                if tl.Member.Equal(ctx.Me()) </span><span class="cov0" title="0">{
                        validate.MemberHasProjectWriteAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))
                }</span> else<span class="cov8" title="1"> {
                        validate.MemberHasProjectAdminAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))
                }</span>
                <span class="cov8" title="1">if args.Fields.Duration != nil &amp;&amp; args.Fields.Duration.Val != tl.Duration </span><span class="cov8" title="1">{
                        dbSetDuration(ctx, args.Shard, args.Account, args.Project, tl.Task, ctx.Me(), tl.Id, args.Fields.Duration.Val)
                }</span>
                <span class="cov8" title="1">if args.Fields.Note != nil &amp;&amp; ((args.Fields.Note.Val == nil &amp;&amp; tl.Note != nil) || (args.Fields.Note.Val != nil &amp;&amp; tl.Note == nil) || (tl.Note != nil &amp;&amp; args.Fields.Note.Val != nil &amp;&amp; *tl.Note != *args.Fields.Note.Val)) </span><span class="cov8" title="1">{
                        dbSetNote(ctx, args.Shard, args.Account, args.Project, tl.Task, ctx.Me(), tl.Id, args.Fields.Note.Val)
                }</span>
                <span class="cov8" title="1">return nil</span>
        },
}

type deleteArgs struct {
        Shard   int   `json:"shard"`
        Account id.Id `json:"account"`
        Project id.Id `json:"project"`
        TimeLog id.Id `json:"timeLog"`
}

var delete = &amp;endpoint.Endpoint{
        Path:            "/api/v1/timeLog/delete",
        RequiresSession: true,
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;deleteArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*deleteArgs)
                tl := dbGetTimeLog(ctx, args.Shard, args.Account, args.Project, args.TimeLog)
                if tl.Member.Equal(ctx.Me()) </span><span class="cov8" title="1">{
                        validate.MemberHasProjectWriteAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))
                }</span> else<span class="cov0" title="0"> {
                        validate.MemberHasProjectAdminAccess(db.GetAccountAndProjectRoles(ctx, args.Shard, args.Account, args.Project, ctx.Me()))
                }</span>
                <span class="cov8" title="1">dbDelete(ctx, args.Shard, args.Account, args.Project, tl.Task, tl.Member, args.TimeLog)
                return nil</span>
        },
}

type getArgs struct {
        Shard   int    `json:"shard"`
        Account id.Id  `json:"account"`
        Project id.Id  `json:"project"`
        Task    *id.Id `json:"task,omitempty"`
        Member  *id.Id `json:"member,omitempty"`
        TimeLog *id.Id `json:"timeLog,omitempty"`
        SortAsc bool   `json:"sortAsc"`
        After   *id.Id `json:"after,omitempty"`
        Limit   int    `json:"limit"`
}

type getResp struct {
        TimeLogs []*timelog.TimeLog `json:"timeLogs"`
        More     bool               `json:"more"`
}

var get = &amp;endpoint.Endpoint{
        Path:                     "/api/v1/timeLog/get",
        RequiresSession:          false,
        ExampleResponseStructure: &amp;getResp{TimeLogs: []*timelog.TimeLog{{}}},
        GetArgsStruct: func() interface{} <span class="cov8" title="1">{
                return &amp;getArgs{}
        }</span>,
        CtxHandler: func(ctx ctx.Ctx, a interface{}) interface{} <span class="cov8" title="1">{
                args := a.(*getArgs)
                validate.MemberHasProjectReadAccess(db.GetAccountAndProjectRolesAndProjectIsPublic(ctx, args.Shard, args.Account, args.Project, ctx.TryMe()))
                return dbGetTimeLogs(ctx, args.Shard, args.Account, args.Project, args.Task, args.Member, args.TimeLog, args.SortAsc, args.After, validate.Limit(args.Limit, ctx.MaxProcessEntityCount()))
        }</span>,
}

var Endpoints = []*endpoint.Endpoint{
        create,
        createAndSetRemainingTime,
        edit,
        delete,
        get,
}

type Fields struct {
        Duration *field.UInt64    `json:"duration,omitempty"`
        Note     *field.StringPtr `json:"note,omitempty"`
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package crypt

import (
        "crypto/rand"
        "github.com/0xor1/panic"
        "golang.org/x/crypto/scrypt"
        "io"
        "math/big"
)

var urlSafeRunes = []rune("0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")

func Bytes(length int) []byte <span class="cov8" title="1">{
        k := make([]byte, length)
        _, e := io.ReadFull(rand.Reader, k)
        panic.IfNotNil(e)
        return k
}</span>

func UrlSafeString(length int) string <span class="cov8" title="1">{
        buf := make([]rune, length)
        urlSafeRunesLength := big.NewInt(int64(len(urlSafeRunes)))
        for i := range buf </span><span class="cov8" title="1">{
                randomIdx, e := rand.Int(rand.Reader, urlSafeRunesLength)
                panic.IfNotNil(e)
                buf[i] = urlSafeRunes[int(randomIdx.Int64())]
        }</span>
        <span class="cov8" title="1">return string(buf)</span>
}

func ScryptKey(password, salt []byte, N, r, p, keyLen int) []byte <span class="cov8" title="1">{
        key, e := scrypt.Key(password, salt, N, r, p, keyLen)
        panic.IfNotNil(e)
        return key
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package id

import (
        "github.com/0xor1/trees/server/util/err"
        "github.com/0xor1/trees/server/util/time"
        "bytes"
        "encoding/base64"
        "github.com/oklog/ulid"
        "math/rand"
        "net/http"
        "sync"
)

var (
        entropyMtx = &amp;sync.Mutex{}
        entropy    = rand.New(rand.NewSource(time.NowUnixMillis()))
)

//returns ulid as a byte slice
func New() Id <span class="cov8" title="1">{
        entropyMtx.Lock() //rand source is not safe for concurrent use :(
        defer entropyMtx.Unlock()
        id := ulid.MustNew(ulid.Timestamp(time.Now()), entropy)
        return Id(id[:])
}</span>

func Parse(id string) Id <span class="cov0" title="0">{
        b, e := base64.RawURLEncoding.DecodeString(id)
        err.HttpPanicf(e != nil || len(b) != 16, http.StatusBadRequest, "invalid id")
        return Id(b)
}</span>

type Id []byte

func (id Id) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return []byte(`"` + id.String() + `"`), nil
}</span>

func (id *Id) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        *id = Parse(string(bytes.Trim(data, `"`)))
        return nil
}</span>

func (id Id) String() string <span class="cov0" title="0">{
        return base64.RawURLEncoding.EncodeToString(id)
}</span>

func (id Id) Equal(other Id) bool <span class="cov8" title="1">{
        return bytes.Equal(id, other)
}</span>

func (id Id) Copy() Id <span class="cov8" title="1">{
        return Id(append(make([]byte, 0, 16), id...))
}</span>

type Identifiable interface {
        Id() Id
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package validate

import (
        "github.com/0xor1/trees/server/util/cnst"
        "github.com/0xor1/trees/server/util/err"
        "github.com/0xor1/panic"
        "net/http"
        "regexp"
        "unicode/utf8"
)

var (
        emailRegex = regexp.MustCompile(`.+@.+\..+`)
)

func HoursPerDay(hoursPerDay uint8) <span class="cov0" title="0">{
        panic.If(hoursPerDay == 0 || hoursPerDay &gt; 24, "invalid hoursPerDay must be &gt; 0 and &lt;= 24")
}</span>

func DaysPerWeek(daysPerWeek uint8) <span class="cov0" title="0">{
        panic.If(daysPerWeek == 0 || daysPerWeek &gt; 7, "invalid daysPerWeek must be &gt; 0 and &lt;= 7")
}</span>

func StringArg(argPurpose, arg string, minRuneCount, maxRuneCount int, regexMatchers []*regexp.Regexp) <span class="cov8" title="1">{
        valRuneCount := utf8.RuneCountInString(arg)
        err.HttpPanicf(valRuneCount &lt; minRuneCount || valRuneCount &gt; maxRuneCount, http.StatusBadRequest, "invalid %s arg, min rune count: %d max rune count: %d", argPurpose, minRuneCount, maxRuneCount)
        for _, regex := range regexMatchers </span><span class="cov8" title="1">{
                err.HttpPanicf(!regex.MatchString(arg), http.StatusBadRequest, "invalid %s arg, regex: %v", argPurpose, regex.String())
        }</span>
}

func Email(email string) <span class="cov8" title="1">{
        StringArg("email", email, 6, 254, []*regexp.Regexp{emailRegex})
}</span>

func Limit(limit, maxLimit int) int <span class="cov0" title="0">{
        if limit &lt; 1 || limit &gt; maxLimit </span><span class="cov0" title="0">{
                limit = maxLimit
        }</span>
        <span class="cov0" title="0">return limit</span>
}

func EntityCount(entityCount, maxLimit int) <span class="cov0" title="0">{
        err.HttpPanicf(entityCount &lt; 1 || entityCount &gt; maxLimit, http.StatusBadRequest, "invalid entity count")
}</span>

func MemberHasAccountOwnerAccess(accountRole *cnst.AccountRole) <span class="cov0" title="0">{
        checkUnauthorized(accountRole == nil || *accountRole != cnst.AccountOwner)
}</span>

func MemberHasAccountAdminAccess(accountRole *cnst.AccountRole) <span class="cov0" title="0">{
        checkUnauthorized(accountRole == nil || (*accountRole != cnst.AccountOwner &amp;&amp; *accountRole != cnst.AccountAdmin))
}</span>

func MemberHasProjectAdminAccess(accountRole *cnst.AccountRole, projectRole *cnst.ProjectRole) <span class="cov0" title="0">{
        checkUnauthorized(accountRole == nil || ((*accountRole != cnst.AccountOwner &amp;&amp; *accountRole != cnst.AccountAdmin) &amp;&amp; (projectRole == nil || *projectRole != cnst.ProjectAdmin)))
}</span>

func MemberHasProjectWriteAccess(accountRole *cnst.AccountRole, projectRole *cnst.ProjectRole) <span class="cov0" title="0">{
        checkUnauthorized(accountRole == nil || ((*accountRole != cnst.AccountOwner &amp;&amp; *accountRole != cnst.AccountAdmin) &amp;&amp; (projectRole == nil || (*projectRole != cnst.ProjectAdmin &amp;&amp; *projectRole != cnst.ProjectWriter))))
}</span>

func MemberIsAProjectMemberWithWriteAccess(projectRole *cnst.ProjectRole) <span class="cov0" title="0">{
        checkUnauthorized(projectRole == nil || (*projectRole != cnst.ProjectAdmin &amp;&amp; *projectRole != cnst.ProjectWriter))
}</span>

func MemberHasProjectReadAccess(accountRole *cnst.AccountRole, projectRole *cnst.ProjectRole, projectIsPublic *bool) <span class="cov0" title="0">{
        checkUnauthorized(projectIsPublic == nil || (!*projectIsPublic &amp;&amp; (accountRole == nil || ((*accountRole != cnst.AccountOwner &amp;&amp; *accountRole != cnst.AccountAdmin) &amp;&amp; (projectRole == nil || (*projectRole != cnst.ProjectAdmin &amp;&amp; *projectRole != cnst.ProjectWriter &amp;&amp; *projectRole != cnst.ProjectReader))))))
}</span>

func checkUnauthorized(condition bool) <span class="cov0" title="0">{
        err.HttpPanicf(condition, http.StatusUnauthorized, "unauthorized")
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
